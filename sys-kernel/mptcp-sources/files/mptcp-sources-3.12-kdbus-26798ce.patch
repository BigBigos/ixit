diff --git a/drivers/Kconfig b/drivers/Kconfig
index aa43b91..a4b377d 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -166,4 +166,6 @@ source "drivers/reset/Kconfig"
 
 source "drivers/fmc/Kconfig"
 
+source "drivers/kdbus/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index ab93de8..baca0e0 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -152,3 +152,4 @@ obj-$(CONFIG_VME_BUS)		+= vme/
 obj-$(CONFIG_IPACK_BUS)		+= ipack/
 obj-$(CONFIG_NTB)		+= ntb/
 obj-$(CONFIG_FMC)		+= fmc/
+obj-$(CONFIG_KDBUS)		+= kdbus/
diff --git a/drivers/kdbus/.gitignore b/drivers/kdbus/.gitignore
new file mode 100644
index 0000000..82cd80a
--- /dev/null
+++ b/drivers/kdbus/.gitignore
@@ -0,0 +1,17 @@
+*.cmd
+*.ko
+*.mod.c
+modules.order
+Module.symvers
+*.o
+*.swp
+.tmp_versions
+tags
+test/test-kdbus
+test/test-kdbus-daemon
+test/test-kdbus-namespace
+test/test-kdbus-fuzz
+test/test-kdbus-benchmark
+test/test-kdbus-monitor
+test/test-kdbus-activator
+test/test-kdbus-chat
diff --git a/drivers/kdbus/Kconfig b/drivers/kdbus/Kconfig
new file mode 100644
index 0000000..f093882
--- /dev/null
+++ b/drivers/kdbus/Kconfig
@@ -0,0 +1,6 @@
+config KDBUS
+	tristate "kdbus interprocess communication"
+	help
+	  D-Bus is a system for low-latency, low-overhead, easy to use
+	  interprocess communication (IPC).
+	  http://dbus.freedesktop.org/doc/dbus-specification.html
diff --git a/drivers/kdbus/Makefile b/drivers/kdbus/Makefile
new file mode 100644
index 0000000..cc384f1
--- /dev/null
+++ b/drivers/kdbus/Makefile
@@ -0,0 +1,56 @@
+kdbus$(EXT)-y := \
+	bus.o \
+	connection.o \
+	endpoint.o \
+	handle.o \
+	memfd.o \
+	main.o \
+	match.o \
+	message.o \
+	metadata.o \
+	names.o \
+	notify.o \
+	namespace.o \
+	policy.o \
+	pool.o
+
+obj-$(CONFIG_KDBUS) += kdbus$(EXT).o
+
+KERNELDIR 		?= /lib/modules/$(shell uname -r)/build
+PWD			:= $(shell pwd)
+
+all: module test
+
+test::
+	$(MAKE) -C test KBUILD_MODNAME=kdbus$(EXT)
+
+module:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD)
+
+clean:
+	rm -f *.o *~ core .depend .*.cmd *.ko *.mod.c
+	rm -f Module.markers Module.symvers modules.order
+	rm -rf .tmp_versions Modules.symvers $(hostprogs-y)
+	$(MAKE) -C test clean
+
+check:
+	test/test-kdbus
+
+install: module
+	mkdir -p /lib/modules/$(shell uname -r)/kernel/drivers/kdbus$(EXT)/
+	cp -f kdbus$(EXT).ko /lib/modules/$(shell uname -r)/kernel/drivers/kdbus$(EXT)/
+	depmod $(shell name -r)
+
+uninstall:
+	rm -f /lib/modules/$(shell uname -r)/kernel/drivers/kdbus/kdbus$(EXT).ko
+
+coccicheck:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) coccicheck
+
+tt: all
+	sudo sh -c 'dmesg -c > /dev/null'
+	-sudo sh -c 'rmmod kdbus$(EXT)'
+	sudo sh -c 'insmod kdbus$(EXT).ko'
+	-sudo sh -c 'sync; umount / 2> /dev/null'
+	test/test-kdbus
+	dmesg
diff --git a/drivers/kdbus/README b/drivers/kdbus/README
new file mode 100644
index 0000000..4842acf
--- /dev/null
+++ b/drivers/kdbus/README
@@ -0,0 +1,17 @@
+Linux kernel D-Bus implementation
+
+See kdbus.txt in this repository for kernel-side details.
+
+The userspace side is developed in systemd:
+  http://cgit.freedesktop.org/systemd/systemd/tree/src/libsystemd-bus
+
+Development repos:
+  https://github.com/gregkh/kdbus
+  https://code.google.com/p/d-bus/
+
+See also:
+  https://review.tizen.org/git/?p=platform/upstream/glib.git;a=shortlog;h=refs/heads/kdbus-dev
+  https://review.tizen.org/git/?p=platform/upstream/dbus.git;a=shortlog;h=refs/heads/kdbus-dev
+
+The code is LGPLv2+. We need to make sure, that we are able to freely
+share and copy code with the userspace library, which has the same licence.
diff --git a/drivers/kdbus/TODO b/drivers/kdbus/TODO
new file mode 100644
index 0000000..9e53a3b
--- /dev/null
+++ b/drivers/kdbus/TODO
@@ -0,0 +1,22 @@
+Features:
+  - whitelist chars in bus names, they show up in /dev
+
+  - account and limit number of messages a connection can have in-flight
+    for another connection, like a connection can have a maximum of 100
+    messages in-flight, but only 10 of them to the same connection
+
+  - allow to update the metadata subscription bit mask
+
+  - support the creation of anonymous buses
+
+  - limit the number of connections per uid
+
+  - actually return compatible/incompatible flags to users
+
+External API:
+  - rules for:
+      -unknown items to ignore in userspace lib?
+      -unknown items to ignore if SEND sees them?
+
+  - review all different structures of custom ioctls and items if they
+    can be further unified
diff --git a/drivers/kdbus/bus.c b/drivers/kdbus/bus.c
new file mode 100644
index 0000000..0b859ea
--- /dev/null
+++ b/drivers/kdbus/bus.c
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/hashtable.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "bus.h"
+#include "connection.h"
+#include "endpoint.h"
+#include "names.h"
+#include "namespace.h"
+
+bool kdbus_bus_uid_is_privileged(const struct kdbus_bus *bus)
+{
+	if (capable(CAP_IPC_OWNER))
+		return true;
+
+	if (uid_eq(bus->uid_owner, current_fsuid()))
+		return true;
+
+	return false;
+}
+
+/**
+ * kdbus_bus_ref() - increase the reference counter of a kdbus_bus
+ * @bus:		The bus to unref
+ *
+ * Every user of a bus, except for its creator, must add a reference to the
+ * kdbus_bus using this function.
+ */
+struct kdbus_bus *kdbus_bus_ref(struct kdbus_bus *bus)
+{
+	kref_get(&bus->kref);
+	return bus;
+}
+
+static void __kdbus_bus_free(struct kref *kref)
+{
+	struct kdbus_bus *bus = container_of(kref, struct kdbus_bus, kref);
+
+	kdbus_bus_disconnect(bus);
+	if (bus->name_registry)
+		kdbus_name_registry_free(bus->name_registry);
+	kdbus_ns_unref(bus->ns);
+	kfree(bus->name);
+	kfree(bus);
+}
+
+/**
+ * kdbus_bus_unref() - decrease the reference counter of a kdbus_bus
+ * @bus:		The bus to unref
+ *
+ * Release a reference. If the reference count drops to 0, the bus will be
+ * freed.
+ *
+ * Returns: NULL
+ */
+struct kdbus_bus *kdbus_bus_unref(struct kdbus_bus *bus)
+{
+	if (!bus)
+		return NULL;
+
+	kref_put(&bus->kref, __kdbus_bus_free);
+	return NULL;
+}
+
+/**
+ * kdbus_bus_find_conn_by_id() - find a connection with a given id
+ * @bus:		The bus to look for the connection
+ * @id:			The 64-bit connection id
+ *
+ * Looks up a connection with a given id. The returned connection
+ * is ref'ed, and needs to be unref'ed by the user. Returns NULL if
+ * the connection can't be found.
+ *
+ * This function must be called with bus->lock held.
+ */
+struct kdbus_conn *kdbus_bus_find_conn_by_id(struct kdbus_bus *bus, u64 id)
+{
+	struct kdbus_conn *conn, *found = NULL;
+
+	hash_for_each_possible(bus->conn_hash, conn, hentry, id)
+		if (conn->id == id) {
+			found = kdbus_conn_ref(conn);
+			break;
+		}
+
+	return found;
+}
+
+/**
+ * kdbus_bus_disconnect() - disconnect a bus
+ * @bus:		The kdbus reference
+ *
+ * The passed bus will be disconnected and the associated endpoint will be
+ * unref'ed.
+ */
+void kdbus_bus_disconnect(struct kdbus_bus *bus)
+{
+	struct kdbus_ep *ep, *tmp;
+
+	mutex_lock(&bus->lock);
+	if (bus->disconnected) {
+		mutex_unlock(&bus->lock);
+		return;
+	}
+
+	bus->disconnected = true;
+	mutex_unlock(&bus->lock);
+
+	/* disconnect from namespace */
+	mutex_lock(&bus->ns->lock);
+	if (bus->ns)
+		list_del(&bus->ns_entry);
+	mutex_unlock(&bus->ns->lock);
+
+	/* remove all endpoints attached to this bus */
+	list_for_each_entry_safe(ep, tmp, &bus->ep_list, bus_entry) {
+		kdbus_ep_disconnect(ep);
+		kdbus_ep_unref(ep);
+	}
+}
+
+static struct kdbus_bus *kdbus_bus_find(struct kdbus_ns *ns, const char *name)
+{
+	struct kdbus_bus *bus = NULL;
+	struct kdbus_bus *b;
+
+	mutex_lock(&ns->lock);
+	list_for_each_entry(b, &ns->bus_list, ns_entry) {
+		if (strcmp(b->name, name))
+			continue;
+
+		bus = kdbus_bus_ref(b);
+		break;
+	}
+
+	mutex_unlock(&ns->lock);
+	return bus;
+}
+
+/**
+ * kdbus_bus_new() - create a new bus
+ * @ns:			The namespace to work on
+ * @make:		Pointer to a struct kdbus_cmd_make containing the
+ *			details for the bus creation
+ * @name:		Name of the bus
+ * @bloom_size:		Size of the bloom filter on this bus
+ * @mode:		The access mode for the device node
+ * @uid:		The uid of the device node
+ * @gid:		The gid of the device node
+ * @bus:		Pointer to a reference where the new bus is stored
+ *
+ * This function will allocate a new kdbus_bus and link it to the given
+ * namespace.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_bus_new(struct kdbus_ns *ns,
+		  struct kdbus_cmd_make *make, const char *name,
+		  size_t bloom_size, umode_t mode, kuid_t uid,
+		  kgid_t gid, struct kdbus_bus **bus)
+{
+	char prefix[16];
+	struct kdbus_bus *b;
+	int ret;
+
+	BUG_ON(*bus);
+
+	/* enforce "$UID-" prefix */
+	snprintf(prefix, sizeof(prefix), "%u-",
+		 from_kuid(current_user_ns(), uid));
+	if (strncmp(name, prefix, strlen(prefix) != 0))
+		return -EINVAL;
+
+	b = kdbus_bus_find(ns, name);
+	if (b) {
+		kdbus_bus_unref(b);
+		return -EEXIST;
+	}
+
+	b = kzalloc(sizeof(struct kdbus_bus), GFP_KERNEL);
+	if (!b)
+		return -ENOMEM;
+
+	kref_init(&b->kref);
+	b->uid_owner = uid;
+	b->bus_flags = make->flags;
+	b->bloom_size = bloom_size;
+	b->conn_id_next = 1; /* connection 0 == kernel */
+	mutex_init(&b->lock);
+	hash_init(b->conn_hash);
+	INIT_LIST_HEAD(&b->ep_list);
+	INIT_LIST_HEAD(&b->monitors_list);
+
+	/* generate unique ID for this bus */
+	get_random_bytes(b->id128, sizeof(b->id128));
+
+	/* Set UUID version to 4 --- truly random generation */
+	b->id128[6] &= 0x0f;
+	b->id128[6] |= 0x40;
+
+	/* Set the UUID variant to DCE */
+	b->id128[8] &= 0x3f;
+	b->id128[8] |= 0x80;
+
+	b->name = kstrdup(name, GFP_KERNEL);
+	if (!b->name) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	ret = kdbus_name_registry_new(&b->name_registry);
+	if (ret < 0)
+		goto exit;
+
+	ret = kdbus_ep_new(b, ns, "bus", mode, uid, gid,
+			   b->bus_flags & KDBUS_MAKE_POLICY_OPEN);
+	if (ret < 0)
+		goto exit;
+
+	/* link into namespace */
+	mutex_lock(&ns->lock);
+	b->id = ns->bus_id_next++;
+	list_add_tail(&b->ns_entry, &ns->bus_list);
+	b->ns = kdbus_ns_ref(ns);
+	mutex_unlock(&ns->lock);
+
+	*bus = b;
+	return 0;
+
+exit:
+	kdbus_bus_unref(b);
+	return ret;
+}
+
+/**
+ * kdbus_bus_make_user() - create a kdbus_cmd_make from user-supplied data
+ * @buf:		The user supplied data from the ioctl() call
+ * @make:		Reference to the location where to store the result
+ * @name:		Shortcut to the requested name
+ * @bloom_size:		The bloom filter size as denoted in the make items
+ *
+ * This function is part of the connection ioctl() interface and will parse
+ * the user-supplied data.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_bus_make_user(void __user *buf, struct kdbus_cmd_make **make,
+			char **name, size_t *bloom_size)
+{
+	u64 size;
+	struct kdbus_cmd_make *m;
+	const char *n = NULL;
+	const struct kdbus_item *item;
+	u64 bsize = 0;
+	int ret;
+
+
+	if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_make))
+		return -EFAULT;
+
+	if (size < sizeof(struct kdbus_cmd_make) || size > KDBUS_MAKE_MAX_SIZE)
+		return -EMSGSIZE;
+
+	m = memdup_user(buf, size);
+	if (IS_ERR(m))
+		return PTR_ERR(m);
+
+	KDBUS_ITEM_FOREACH(item, m, items) {
+		if (!KDBUS_ITEM_VALID(item, m)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		switch (item->type) {
+		case KDBUS_ITEM_MAKE_NAME:
+			if (n) {
+				ret = -EEXIST;
+				goto exit;
+			}
+
+			if (item->size < KDBUS_ITEM_HEADER_SIZE + 2) {
+				ret = -EINVAL;
+				goto exit;
+			}
+
+			if (item->size > KDBUS_ITEM_HEADER_SIZE +
+					 KDBUS_MAKE_MAX_LEN + 1) {
+				ret = -ENAMETOOLONG;
+				goto exit;
+			}
+
+			if (!kdbus_validate_nul(item->str,
+					item->size - KDBUS_ITEM_HEADER_SIZE)) {
+				ret = -EINVAL;
+				goto exit;
+			}
+
+			n = item->str;
+			break;
+
+		case KDBUS_ITEM_BLOOM_SIZE:
+			if (item->size < KDBUS_ITEM_HEADER_SIZE + sizeof(u64)) {
+				ret = -EINVAL;
+				goto exit;
+			}
+
+			bsize = item->data64[0];
+			break;
+
+		default:
+			ret = -ENOTSUPP;
+			goto exit;
+		}
+	}
+
+	if (!KDBUS_ITEM_END(item, m)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (!n) {
+		ret = -EBADMSG;
+		goto exit;
+	}
+
+	if (!KDBUS_IS_ALIGNED8(bsize)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (bsize < 8 || bsize > SZ_16K) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	*make = m;
+	*name = (char *)n;
+	*bloom_size = (size_t)bsize;
+	return 0;
+
+exit:
+	kfree(m);
+	return ret;
+}
diff --git a/drivers/kdbus/bus.h b/drivers/kdbus/bus.h
new file mode 100644
index 0000000..1d58b45
--- /dev/null
+++ b/drivers/kdbus/bus.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_BUS_H
+#define __KDBUS_BUS_H
+
+#include <linux/hashtable.h>
+#include <linux/idr.h>
+
+#include "internal.h"
+
+/**
+ * struct kdbus_bus - bus in a namespace
+ * @kref:		Reference count
+ * @disconnected:	Invalidated data
+ * @uid_owner:		The uid of the owner of the bus
+ * @ns:			Namespace of this bus
+ * @name:		The bus name
+ * @id:			ID of this bus in the namespace
+ * @lock:		Bus data lock
+ * @ep_id_next:		Next endpoint id sequence number
+ * @conn_id_next:	Next connection id sequence number
+ * @msg_id_next:	Next message id sequence number
+ * @conn_idr:		Map of connection device minor nummbers
+ * @conn_hash:		Map of connection IDs
+ * @ep_list:		Endpoints on this bus
+ * @bus_flags:		Simple pass-through flags from userspace to userspace
+ * @bloom_size:		Bloom filter size
+ * @name_registry:	Namespace's list of buses
+ * @ns_entry:		Namespace's list of buses
+ * @monitors_list:	Connections that monitor this bus
+ * @id128:		Unique random 128 bit ID of this bus
+ *
+ * A bus provides a "bus" endpoint / device node.
+ *
+ * A bus is created by opening the control node and issuing the
+ * KDBUS_CMD_BUS_MAKE iotcl. Closing this file immediately destroys
+ * the bus.
+ */
+struct kdbus_bus {
+	struct kref kref;
+	bool disconnected;
+	kuid_t uid_owner;
+	struct kdbus_ns *ns;
+	const char *name;
+	u64 id;
+	struct mutex lock;
+	u64 ep_id_next;
+	u64 conn_id_next;
+	u64 msg_id_next;
+	struct idr conn_idr;
+	DECLARE_HASHTABLE(conn_hash, 6);
+	struct list_head ep_list;
+	u64 bus_flags;
+	size_t bloom_size;
+	struct kdbus_name_registry *name_registry;
+	struct list_head ns_entry;
+	struct list_head monitors_list;
+	u8 id128[16];
+};
+
+int kdbus_bus_make_user(void __user *buf, struct kdbus_cmd_make **make,
+			char **name, size_t *bsize);
+int kdbus_bus_new(struct kdbus_ns *ns, struct kdbus_cmd_make *make,
+		  const char *name, size_t bloom_size,
+		  umode_t mode, kuid_t uid, kgid_t gid, struct kdbus_bus **bus);
+struct kdbus_bus *kdbus_bus_ref(struct kdbus_bus *bus);
+struct kdbus_bus *kdbus_bus_unref(struct kdbus_bus *bus);
+void kdbus_bus_disconnect(struct kdbus_bus *bus);
+
+bool kdbus_bus_uid_is_privileged(const struct kdbus_bus *bus);
+struct kdbus_conn *kdbus_bus_find_conn_by_id(struct kdbus_bus *bus, u64 id);
+#endif
diff --git a/drivers/kdbus/connection.c b/drivers/kdbus/connection.c
new file mode 100644
index 0000000..b32b0cf
--- /dev/null
+++ b/drivers/kdbus/connection.c
@@ -0,0 +1,1644 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/hashtable.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/syscalls.h>
+#include <linux/uio.h>
+
+#include "bus.h"
+#include "connection.h"
+#include "endpoint.h"
+#include "match.h"
+#include "memfd.h"
+#include "message.h"
+#include "metadata.h"
+#include "names.h"
+#include "namespace.h"
+#include "notify.h"
+#include "policy.h"
+
+/**
+ * struct kdbus_conn_queue - messages waiting to be read
+ * @entry:		Entry in the connection's list
+ * @off:		Offset into the shmem file in the receiver's pool
+ * @size:		The number of bytes used in the pool
+ * @memfds:		Arrays of offsets where to update the installed
+ *			fd number
+ * @memfds_fp:		Array memfd files queued up for this message
+ * @memfds_count:	Number of memfds
+ * @fds:		Offset to array where to update the installed fd number
+ * @fds_fp:		Array passed files queued up for this message
+ * @fds_count:		Number of files
+ * @src_id:		The ID of the sender
+ * @cookie:		Message cookie, used for replies
+ * @dst_name_id:	The sequence number of the name this message is
+ *			addressed to, 0 for messages sent to an ID
+ */
+struct kdbus_conn_queue {
+	struct list_head entry;
+	size_t off;
+	size_t size;
+
+	size_t *memfds;
+	struct file **memfds_fp;
+	unsigned int memfds_count;
+
+	size_t fds;
+	struct file **fds_fp;
+	unsigned int fds_count;
+
+	u64 src_id;
+	u64 cookie;
+	u64 dst_name_id;
+};
+
+/**
+ * struct kdbus_conn_reply_entry - an entry of kdbus_conn's list of replies
+ * @entry:		The list_head entry of the connection's reply_from_list
+ * @conn:		The counterpart connection that is expected to answer
+ * @deadline_ns:	The deadline of the reply, in nanoseconds
+ * @cookie:		The cookie of the requesting message
+ */
+struct kdbus_conn_reply_entry {
+	struct list_head entry;
+	struct kdbus_conn *conn;
+	u64 deadline_ns;
+	u64 cookie;
+};
+
+static void kdbus_conn_reply_entry_free(struct kdbus_conn_reply_entry *reply)
+{
+	atomic_dec(&reply->conn->reply_count);
+	list_del(&reply->entry);
+	kdbus_conn_unref(reply->conn);
+	kfree(reply);
+}
+
+static void kdbus_conn_fds_unref(struct kdbus_conn_queue *queue)
+{
+	unsigned int i;
+
+	if (!queue->fds_fp)
+		return;
+
+	for (i = 0; i < queue->fds_count; i++) {
+		if (!queue->fds_fp[i])
+			break;
+
+		fput(queue->fds_fp[i]);
+	}
+
+	kfree(queue->fds_fp);
+	queue->fds_fp = NULL;
+
+	queue->fds_count = 0;
+}
+
+/* grab references of passed-in FDS for the queued message */
+static int kdbus_conn_fds_ref(struct kdbus_conn_queue *queue,
+			      const int *fds, unsigned int fds_count)
+{
+	unsigned int i;
+
+	queue->fds_fp = kcalloc(fds_count, sizeof(struct file *), GFP_KERNEL);
+	if (!queue->fds_fp)
+		return -ENOMEM;
+
+	for (i = 0; i < fds_count; i++) {
+		queue->fds_fp[i] = fget(fds[i]);
+		if (!queue->fds_fp[i]) {
+			kdbus_conn_fds_unref(queue);
+			return -EBADF;
+		}
+	}
+
+	return 0;
+}
+
+static void kdbus_conn_memfds_unref(struct kdbus_conn_queue *queue)
+{
+	unsigned int i;
+
+	if (!queue->memfds_fp)
+		return;
+
+	for (i = 0; i < queue->memfds_count; i++) {
+		if (!queue->memfds_fp[i])
+			break;
+
+		fput(queue->memfds_fp[i]);
+	}
+
+	kfree(queue->memfds_fp);
+	queue->memfds_fp = NULL;
+
+	kfree(queue->memfds);
+	queue->memfds = NULL;
+
+	queue->memfds_count = 0;
+}
+
+/* Validate the state of the incoming PAYLOAD_MEMFD, and grab a reference
+ * to put it into the receiver's queue. */
+static int kdbus_conn_memfd_ref(const struct kdbus_item *item,
+				struct file **file)
+{
+	struct file *fp;
+	int ret;
+
+	fp = fget(item->memfd.fd);
+	if (!fp)
+		return -EBADF;
+
+	/*
+	 * We only accept kdbus_memfd files as payload, other files need to
+	 * be passed with KDBUS_MSG_FDS.
+	 */
+	if (!kdbus_is_memfd(fp)) {
+		ret = -EMEDIUMTYPE;
+		goto exit_unref;
+	}
+
+	/* We only accept a sealed memfd file whose content cannot be altered
+	 * by the sender or anybody else while it is shared or in-flight. */
+	if (!kdbus_is_memfd_sealed(fp)) {
+		ret = -ETXTBSY;
+		goto exit_unref;
+	}
+
+	/* The specified size in the item cannot be larger than the file. */
+	if (item->memfd.size > kdbus_memfd_size(fp)) {
+		ret = -EBADF;
+		goto exit_unref;
+	}
+
+	*file = fp;
+	return 0;
+
+exit_unref:
+	fput(fp);
+	return ret;
+}
+
+static int kdbus_conn_payload_add(struct kdbus_conn *conn,
+				  struct kdbus_conn_queue *queue,
+				  const struct kdbus_kmsg *kmsg,
+				  size_t off, size_t items, size_t vec_data)
+{
+	const struct kdbus_item *item;
+	int ret;
+
+	if (kmsg->memfds_count > 0) {
+		queue->memfds = kcalloc(kmsg->memfds_count,
+					sizeof(size_t), GFP_KERNEL);
+		if (!queue->memfds)
+			return -ENOMEM;
+
+		queue->memfds_fp = kcalloc(kmsg->memfds_count,
+					   sizeof(struct file *), GFP_KERNEL);
+		if (!queue->memfds_fp)
+			return -ENOMEM;
+	}
+
+	KDBUS_ITEM_FOREACH(item, &kmsg->msg, items) {
+		switch (item->type) {
+		case KDBUS_ITEM_PAYLOAD_VEC: {
+			char tmp[KDBUS_ITEM_HEADER_SIZE +
+				 sizeof(struct kdbus_vec)];
+			struct kdbus_item *it = (struct kdbus_item *)tmp;
+
+			/* add item */
+			it->type = KDBUS_ITEM_PAYLOAD_OFF;
+			it->size = sizeof(tmp);
+
+			/* a NULL address specifies a \0-bytes record */
+			if (KDBUS_PTR(item->vec.address))
+				it->vec.offset = vec_data;
+			else
+				it->vec.offset = ~0ULL;
+			it->vec.size = item->vec.size;
+			ret = kdbus_pool_write(conn->pool, off + items,
+					       it, it->size);
+			if (ret < 0)
+				return ret;
+			items += KDBUS_ALIGN8(it->size);
+
+			/* \0-bytes record */
+			if (!KDBUS_PTR(item->vec.address)) {
+				size_t pad = item->vec.size % 8;
+
+				if (pad == 0)
+					break;
+
+				/*
+				 * Preserve the alignment for the next payload
+				 * record in the output buffer; write as many
+				 * null-bytes to the buffer which the \0-bytes
+				 * record would have shifted the alignment.
+				 */
+				kdbus_pool_write_user(conn->pool,
+						      off + vec_data,
+						      (char __user *)
+							"\0\0\0\0\0\0\0", pad);
+				vec_data += pad;
+				break;
+			}
+
+			/* copy kdbus_vec data from sender to receiver */
+			ret = kdbus_pool_write_user(conn->pool, off + vec_data,
+				KDBUS_PTR(item->vec.address), item->vec.size);
+			if (ret < 0)
+				return ret;
+
+			vec_data += item->vec.size;
+			break;
+		}
+
+		case KDBUS_ITEM_PAYLOAD_MEMFD: {
+			char tmp[KDBUS_ITEM_HEADER_SIZE +
+				 sizeof(struct kdbus_memfd)];
+			struct kdbus_item *it = (struct kdbus_item *)tmp;
+			struct file *fp;
+			size_t memfd;
+
+			/* add item */
+			it->type = KDBUS_ITEM_PAYLOAD_MEMFD;
+			it->size = sizeof(tmp);
+			it->memfd.size = item->memfd.size;
+			it->memfd.fd = -1;
+			ret = kdbus_pool_write(conn->pool, off + items,
+					       it, it->size);
+			if (ret < 0)
+				return ret;
+
+			/* grab reference of incoming file */
+			ret = kdbus_conn_memfd_ref(item, &fp);
+			if (ret < 0)
+				return ret;
+
+			/*
+			 * Remember the file and the location of the fd number
+			 * which will be updated at RECV time.
+			 */
+			memfd = items + offsetof(struct kdbus_item, memfd.fd);
+			queue->memfds[queue->memfds_count] = memfd;
+			queue->memfds_fp[queue->memfds_count] = fp;
+			queue->memfds_count++;
+
+			items += KDBUS_ALIGN8((it)->size);
+			break;
+		}
+
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static void kdbus_conn_queue_cleanup(struct kdbus_conn_queue *queue)
+{
+	kdbus_conn_memfds_unref(queue);
+	kdbus_conn_fds_unref(queue);
+	kfree(queue);
+}
+
+/* enqueue a message into the receiver's pool */
+static int kdbus_conn_queue_insert(struct kdbus_conn *conn,
+				   struct kdbus_kmsg *kmsg)
+{
+	struct kdbus_conn_queue *queue;
+	u64 msg_size;
+	size_t size;
+	size_t dst_name_len = 0;
+	size_t payloads = 0;
+	size_t fds = 0;
+	size_t meta = 0;
+	size_t vec_data;
+	size_t want, have;
+	size_t off;
+	int ret = 0;
+
+	if (kmsg->fds && !(conn->flags & KDBUS_HELLO_ACCEPT_FD))
+		return -ECOMM;
+
+	queue = kzalloc(sizeof(struct kdbus_conn_queue), GFP_KERNEL);
+	if (!queue)
+		return -ENOMEM;
+
+	/* copy message properties we need for the queue management */
+	queue->src_id = kmsg->msg.src_id;
+	queue->cookie = kmsg->msg.cookie;
+
+	/* space for the header */
+	if (kmsg->msg.src_id == KDBUS_SRC_ID_KERNEL)
+		size = kmsg->msg.size;
+	else
+		size = offsetof(struct kdbus_msg, items);
+	msg_size = size;
+
+	/* let the receiver know where the message was addressed to */
+	if (kmsg->dst_name) {
+		dst_name_len = strlen(kmsg->dst_name) + 1;
+		msg_size += KDBUS_ITEM_SIZE(dst_name_len);
+		queue->dst_name_id = kmsg->dst_name_id;
+	}
+
+	/* space for PAYLOAD items */
+	if ((kmsg->vecs_count + kmsg->memfds_count) > 0) {
+		payloads = msg_size;
+		msg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec)) *
+			    kmsg->vecs_count;
+		msg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_memfd)) *
+			    kmsg->memfds_count;
+	}
+
+	/* space for FDS item */
+	if (kmsg->fds_count > 0) {
+		fds = msg_size;
+		msg_size += KDBUS_ITEM_SIZE(kmsg->fds_count * sizeof(int));
+	}
+
+	/* space for metadata/credential items */
+	if (kmsg->meta && kmsg->meta->size > 0 &&
+	    kmsg->meta->ns == conn->meta->ns) {
+		meta = msg_size;
+		msg_size += kmsg->meta->size;
+	}
+
+	/* data starts after the message */
+	vec_data = KDBUS_ALIGN8(msg_size);
+
+	/* allocate the needed space in the pool of the receiver */
+	mutex_lock(&conn->lock);
+	if (conn->disconnected) {
+		ret = -ECONNRESET;
+		goto exit_unlock;
+	}
+
+	if (conn->msg_count > KDBUS_CONN_MAX_MSGS &&
+	    !kdbus_bus_uid_is_privileged(conn->ep->bus)) {
+		ret = -ENOBUFS;
+		goto exit_unlock;
+	}
+
+	/* do not give out more than half of the remaining space */
+	want = vec_data + kmsg->vecs_size;
+	have = kdbus_pool_remain(conn->pool);
+	if (want < have && want > have / 2) {
+		ret = -EXFULL;
+		goto exit_unlock;
+	}
+
+	ret = kdbus_pool_alloc_range(conn->pool, want, &off);
+	if (ret < 0)
+		goto exit_unlock;
+
+	/* copy the message header */
+	ret = kdbus_pool_write(conn->pool, off, &kmsg->msg, size);
+	if (ret < 0)
+		goto exit_pool_free;
+
+	/* update the size */
+	ret = kdbus_pool_write(conn->pool, off, &msg_size,
+			       sizeof(kmsg->msg.size));
+	if (ret < 0)
+		goto exit_pool_free;
+
+	if (dst_name_len  > 0) {
+		char tmp[KDBUS_ITEM_HEADER_SIZE + dst_name_len];
+		struct kdbus_item *it = (struct kdbus_item *)tmp;
+
+		it->size = KDBUS_ITEM_HEADER_SIZE + dst_name_len;
+		it->type = KDBUS_ITEM_DST_NAME;
+		memcpy(it->str, kmsg->dst_name, dst_name_len);
+
+		ret = kdbus_pool_write(conn->pool, off + size, it, it->size);
+		if (ret < 0)
+			goto exit_pool_free;
+	}
+
+	/* add PAYLOAD items */
+	if (payloads > 0) {
+		ret = kdbus_conn_payload_add(conn, queue, kmsg,
+					     off, payloads, vec_data);
+		if (ret < 0)
+			goto exit_pool_free;
+	}
+
+	/* add a FDS item; the array content will be updated at RECV time */
+	if (kmsg->fds_count > 0) {
+		char tmp[KDBUS_ITEM_HEADER_SIZE];
+		struct kdbus_item *it = (struct kdbus_item *)tmp;
+
+		it->type = KDBUS_ITEM_FDS;
+		it->size = KDBUS_ITEM_HEADER_SIZE +
+			   (kmsg->fds_count * sizeof(int));
+		ret = kdbus_pool_write(conn->pool, off + fds,
+				       it, KDBUS_ITEM_HEADER_SIZE);
+		if (ret < 0)
+			goto exit_pool_free;
+
+		ret = kdbus_conn_fds_ref(queue, kmsg->fds, kmsg->fds_count);
+		if (ret < 0)
+			goto exit_pool_free;
+
+		/* remember the array to update at RECV */
+		queue->fds = fds + offsetof(struct kdbus_item, fds);
+		queue->fds_count = kmsg->fds_count;
+	}
+
+	/* append message metadata/credential items */
+	if (meta > 0) {
+		ret = kdbus_pool_write(conn->pool, off + meta,
+				       kmsg->meta->data, kmsg->meta->size);
+		if (ret < 0)
+			goto exit_pool_free;
+	}
+
+	/* remember the offset to the message */
+	queue->off = off;
+	queue->size = want;
+
+	/* link the message into the receiver's queue */
+	list_add_tail(&queue->entry, &conn->msg_list);
+	conn->msg_count++;
+
+	mutex_unlock(&conn->lock);
+
+	/* wake up poll() */
+	wake_up_interruptible(&conn->ep->wait);
+	return 0;
+
+exit_pool_free:
+	kdbus_pool_free_range(conn->pool, off);
+
+exit_unlock:
+	mutex_unlock(&conn->lock);
+	kdbus_conn_queue_cleanup(queue);
+	return ret;
+}
+
+static void kdbus_conn_scan_timeout(struct kdbus_conn *conn)
+{
+	struct kdbus_conn_reply_entry *reply, *reply_tmp;
+	LIST_HEAD(notify_list);
+	LIST_HEAD(reply_list);
+	u64 deadline = ~0ULL;
+	struct timespec ts;
+	u64 now;
+
+	ktime_get_ts(&ts);
+	now = timespec_to_ns(&ts);
+
+	mutex_lock(&conn->lock);
+	list_for_each_entry_safe(reply, reply_tmp, &conn->reply_list, entry) {
+		if (reply->deadline_ns <= now) {
+
+			/*
+			 * Move to temporary cleanup list; we cannot unref and
+			 * possibly cleanup a connection that is holding a ref
+			 * back to us, while we are locking ourselves.
+			 */
+			list_move_tail(&reply->entry, &reply_list);
+
+			/*
+			 * A zero deadline means the connection died, was
+			 * cleaned up already and the notify sent.
+			 */
+			if (reply->deadline_ns == 0)
+				continue;
+
+			kdbus_notify_reply_timeout(reply->conn->id,
+						   reply->cookie,
+						   &notify_list);
+			continue;
+		}
+
+		/* remember next timeout */
+		if (reply->deadline_ns < deadline) {
+			deadline = reply->deadline_ns;
+			continue;
+		}
+	}
+	mutex_unlock(&conn->lock);
+
+	kdbus_conn_kmsg_list_send(conn->ep, &notify_list);
+
+	list_for_each_entry_safe(reply, reply_tmp, &reply_list, entry)
+		kdbus_conn_reply_entry_free(reply);
+
+	/* rearm timer with next timeout */
+	if (deadline != (~0ULL)) {
+		u64 usecs = deadline - now;
+
+		do_div(usecs, 1000ULL);
+		mod_timer(&conn->timer, jiffies + usecs_to_jiffies(usecs));
+	}
+}
+
+static void kdbus_conn_work(struct work_struct *work)
+{
+	struct kdbus_conn *conn = container_of(work, struct kdbus_conn, work);
+
+	kdbus_conn_scan_timeout(conn);
+}
+
+static void kdbus_conn_timeout_schedule_scan(struct kdbus_conn *conn)
+{
+	schedule_work(&conn->work);
+}
+
+static void kdbus_conn_timer_func(unsigned long val)
+{
+	struct kdbus_conn *conn = (struct kdbus_conn *) val;
+	kdbus_conn_timeout_schedule_scan(conn);
+}
+
+/* find and pin destination connection */
+static int kdbus_conn_get_conn_dst(struct kdbus_bus *bus,
+				   struct kdbus_kmsg *kmsg,
+				   struct kdbus_conn **conn)
+{
+	const struct kdbus_msg *msg = &kmsg->msg;
+	struct kdbus_conn *c;
+	bool disconnected;
+	int ret = 0;
+
+	if (msg->dst_id == KDBUS_DST_ID_NAME) {
+		const struct kdbus_name_entry *name_entry;
+
+		BUG_ON(!kmsg->dst_name);
+		name_entry = kdbus_name_lookup(bus->name_registry,
+					       kmsg->dst_name);
+		if (!name_entry)
+			return -ESRCH;
+
+		/*
+		 * Record the sequence number of the registered name;
+		 * it will be passed on to the queue, in case messages
+		 * addressed to a name need to be moved from or to
+		 * activator connections of the same name.
+		 */
+		kmsg->dst_name_id = name_entry->name_id;
+
+		if (!name_entry->conn && name_entry->activator)
+			c = kdbus_conn_ref(name_entry->activator);
+		else
+			c = kdbus_conn_ref(name_entry->conn);
+
+		if ((msg->flags & KDBUS_MSG_FLAGS_NO_AUTO_START) &&
+		    (c->flags & KDBUS_HELLO_ACTIVATOR)) {
+			ret = -EADDRNOTAVAIL;
+			goto exit_unref;
+		}
+	} else {
+		mutex_lock(&bus->lock);
+		c = kdbus_bus_find_conn_by_id(bus, msg->dst_id);
+		mutex_unlock(&bus->lock);
+
+		if (!c)
+			return -ENXIO;
+
+		/*
+		 * Special-purpose connections are not allowed to be addressed
+		 * via their unique IDs.
+		 */
+		if (c->flags & (KDBUS_HELLO_ACTIVATOR|KDBUS_HELLO_MONITOR)) {
+			ret = -ENXIO;
+			goto exit_unref;
+		}
+	}
+
+	mutex_lock(&c->lock);
+	disconnected = c->disconnected;
+	mutex_unlock(&c->lock);
+	if (disconnected) {
+		ret = -ECONNRESET;
+		goto exit_unref;
+	}
+
+	/* the connection is already ref'ed at this point */
+	*conn = c;
+
+	/* nullify it so it won't be freed below */
+	c = NULL;
+
+exit_unref:
+	kdbus_conn_unref(c);
+
+	return ret;
+}
+
+/**
+ * kdbus_conn_kmsg_send() - send a message
+ * @ep:			Endpoint to send from
+ * @conn_src:		Connection, kernel-generated messages do not have one
+ * @kmsg:		Message to send
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_conn_kmsg_send(struct kdbus_ep *ep,
+			 struct kdbus_conn *conn_src,
+			 struct kdbus_kmsg *kmsg)
+{
+	const struct kdbus_msg *msg = &kmsg->msg;
+	struct kdbus_conn *conn_dst = NULL;
+	struct kdbus_conn *c;
+	int ret;
+
+	/* non-kernel senders append credentials/metadata */
+	if (conn_src) {
+		ret = kdbus_meta_new(&kmsg->meta);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* broadcast message */
+	if (msg->dst_id == KDBUS_DST_ID_BROADCAST) {
+		unsigned int i;
+
+		mutex_lock(&ep->bus->lock);
+		hash_for_each(ep->bus->conn_hash, i, conn_dst, hentry) {
+			if (conn_dst->id == msg->src_id)
+				continue;
+
+			/*
+			 * Activator connections will not receive any
+			 * broadcast messages.
+			 */
+			if (conn_dst->flags & KDBUS_HELLO_ACTIVATOR)
+				continue;
+
+			if (!kdbus_match_db_match_kmsg(conn_dst->match_db,
+						       conn_src, kmsg))
+				continue;
+
+			/*
+			 * The first receiver which requests additional
+			 * metadata causes the message to carry it; all
+			 * receivers after that will see all of the added
+			 * data, even when they did not ask for it.
+			 */
+			if (conn_src)
+				kdbus_meta_append(kmsg->meta, conn_src,
+						  conn_dst->attach_flags);
+
+			kdbus_conn_queue_insert(conn_dst, kmsg);
+		}
+		mutex_unlock(&ep->bus->lock);
+
+		return 0;
+	}
+
+	/* direct message */
+	ret = kdbus_conn_get_conn_dst(ep->bus, kmsg, &conn_dst);
+	if (ret < 0)
+		return ret;
+
+	if (conn_src) {
+		bool allowed = false;
+		struct kdbus_conn_reply_entry *r;
+
+		/*
+		 * Walk the list of connection we expect a reply from.
+		 * If there's any matching entry, allow the message to
+		 * be sent, and remove the entry.
+		 */
+		if (msg->cookie_reply > 0) {
+			mutex_lock(&conn_dst->lock);
+			list_for_each_entry(r, &conn_dst->reply_list, entry) {
+				if (r->conn != conn_src)
+					continue;
+
+				if (r->cookie != msg->cookie_reply)
+					continue;
+
+				kdbus_conn_reply_entry_free(r);
+				allowed = true;
+				break;
+			}
+			mutex_unlock(&conn_dst->lock);
+		}
+
+		/* ... otherwise, ask the policy DB for permission */
+		if (!allowed && ep->policy_db) {
+			ret = kdbus_policy_db_check_send_access(ep->policy_db,
+								conn_src,
+								conn_dst);
+			if (ret < 0)
+				goto exit_unref;
+		}
+	}
+
+	/* If the message expects a reply, add a kdbus_conn_reply_entry */
+	if (conn_src && (msg->flags & KDBUS_MSG_FLAGS_EXPECT_REPLY)) {
+		struct kdbus_conn_reply_entry *reply;
+		struct timespec ts;
+
+		if (atomic_read(&conn_src->reply_count) >
+		    KDBUS_CONN_MAX_REQUESTS_PENDING) {
+			ret = -EMLINK;
+			goto exit_unref;
+		}
+
+		reply = kzalloc(sizeof(*reply), GFP_KERNEL);
+		if (!reply) {
+			ret = -ENOMEM;
+			goto exit_unref;
+		}
+
+		INIT_LIST_HEAD(&reply->entry);
+		reply->conn = kdbus_conn_ref(conn_dst);
+		reply->cookie = msg->cookie;
+
+		/* calculate the deadline based on the current time */
+		ktime_get_ts(&ts);
+		reply->deadline_ns = timespec_to_ns(&ts) + msg->timeout_ns;
+
+		mutex_lock(&conn_src->lock);
+		list_add(&reply->entry, &conn_src->reply_list);
+		atomic_inc(&reply->conn->reply_count);
+		mutex_unlock(&conn_src->lock);
+
+		kdbus_conn_timeout_schedule_scan(conn_dst);
+	}
+
+	if (conn_src) {
+		ret = kdbus_meta_append(kmsg->meta, conn_src,
+					conn_dst->attach_flags);
+		if (ret < 0)
+			goto exit_unref;
+	}
+
+	/*
+	 * Monitor connections get all messages; ignore possible errors
+	 * when sending messages to monitor connections.
+	 */
+	mutex_lock(&ep->bus->lock);
+	list_for_each_entry(c, &ep->bus->monitors_list, monitor_entry)
+		kdbus_conn_queue_insert(c, kmsg);
+	mutex_unlock(&ep->bus->lock);
+
+	ret = kdbus_conn_queue_insert(conn_dst, kmsg);
+	if (ret < 0)
+		goto exit_unref;
+
+exit_unref:
+	/* conn_dst got an extra ref from kdbus_conn_get_conn_dst */
+	kdbus_conn_unref(conn_dst);
+
+	return ret;
+}
+
+/**
+ * kdbus_conn_kmsg_free() - free a list of kmsg objects
+ * @kmsg_list:		List head of kmsg objects to free.
+ */
+void kdbus_conn_kmsg_list_free(struct list_head *kmsg_list)
+{
+	struct kdbus_kmsg *kmsg, *tmp;
+
+	list_for_each_entry_safe(kmsg, tmp, kmsg_list, queue_entry) {
+		list_del(&kmsg->queue_entry);
+		kdbus_kmsg_free(kmsg);
+	}
+}
+
+/**
+ * kdbus_conn_kmsg_list_send() - send a list of previously collected messages
+ * @ep:			The endpoint to use for sending
+ * @kmsg_list:		List head of kmsg objects to send.
+ *
+ * The list is cleared and freed after sending.
+ *
+ * Returns 0 on success.
+ */
+int kdbus_conn_kmsg_list_send(struct kdbus_ep *ep,
+			      struct list_head *kmsg_list)
+{
+	struct kdbus_kmsg *kmsg;
+	int ret = 0;
+
+	list_for_each_entry(kmsg, kmsg_list, queue_entry) {
+		ret = kdbus_conn_kmsg_send(ep, NULL, kmsg);
+		if (ret < 0)
+			break;
+	}
+
+	kdbus_conn_kmsg_list_free(kmsg_list);
+
+	return ret;
+}
+
+static int kdbus_conn_fds_install(struct kdbus_conn *conn,
+				  struct kdbus_conn_queue *queue)
+{
+	size_t size;
+	unsigned int i;
+	int *fds;
+	int ret;
+
+	/* get array of file descriptors */
+	size = queue->fds_count * sizeof(int);
+	fds = kmalloc(size, GFP_KERNEL);
+	if (!fds)
+		return -ENOMEM;
+
+	/* allocate new file descriptors in the receiver's process */
+	for (i = 0; i < queue->fds_count; i++) {
+		fds[i] = get_unused_fd();
+		if (fds[i] < 0) {
+			ret = fds[i];
+			goto remove_unused;
+		}
+	}
+
+	/* copy the array into the message item */
+	ret = kdbus_pool_write(conn->pool, queue->off + queue->fds, fds, size);
+	if (ret < 0)
+		goto remove_unused;
+
+	/* install files in the receiver's process */
+	for (i = 0; i < queue->fds_count; i++)
+		fd_install(fds[i], get_file(queue->fds_fp[i]));
+
+	kfree(fds);
+	return 0;
+
+remove_unused:
+	for (i = 0; i < queue->fds_count; i++) {
+		if (fds[i] < 0)
+			break;
+
+		put_unused_fd(fds[i]);
+	}
+
+	kfree(fds);
+	return ret;
+}
+
+static int kdbus_conn_memfds_install(struct kdbus_conn *conn,
+				     struct kdbus_conn_queue *queue,
+				     int **memfds)
+{
+	size_t size;
+	int *fds;
+	unsigned int i;
+	int ret = 0;
+
+	size = queue->memfds_count * sizeof(int);
+	fds = kmalloc(size, GFP_KERNEL);
+	if (!fds)
+		return -ENOMEM;
+
+	/* allocate new file descriptors in the receiver's process */
+	for (i = 0; i < queue->memfds_count; i++) {
+		fds[i] = get_unused_fd();
+		if (fds[i] < 0) {
+			ret = fds[i];
+			goto remove_unused;
+		}
+	}
+
+	/*
+	 * Update the file descriptor number in the items. We remembered
+	 * the locations of the values in the buffer.
+	 */
+	for (i = 0; i < queue->memfds_count; i++) {
+		ret = kdbus_pool_write(conn->pool,
+				       queue->off + queue->memfds[i],
+				       &fds[i], sizeof(int));
+		if (ret < 0)
+			goto remove_unused;
+	}
+
+	/* install files in the receiver's process */
+	for (i = 0; i < queue->memfds_count; i++)
+		fd_install(fds[i], get_file(queue->memfds_fp[i]));
+
+	*memfds = fds;
+	return 0;
+
+remove_unused:
+	for (i = 0; i < queue->memfds_count; i++) {
+		if (fds[i] < 0)
+			break;
+
+		put_unused_fd(fds[i]);
+	}
+
+	kfree(fds);
+	*memfds = NULL;
+	return ret;
+}
+
+/**
+ * kdbus_conn_recv_msg - receive a message from the queue
+ * @conn:		Connection to work on
+ * @buf:		The returned offset to the message in the pool
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_conn_recv_msg(struct kdbus_conn *conn, __u64 __user *buf)
+{
+	struct kdbus_conn_queue *queue;
+	int *memfds = NULL;
+	unsigned int i;
+	int ret;
+
+	mutex_lock(&conn->lock);
+	if (unlikely(conn->ep->disconnected)) {
+		ret = -ECONNRESET;
+		goto exit_unlock;
+	}
+
+	if (conn->msg_count == 0) {
+		ret = -EAGAIN;
+		goto exit_unlock;
+	}
+
+	/* return the address of the next message in the pool */
+	queue = list_first_entry(&conn->msg_list,
+				 struct kdbus_conn_queue, entry);
+
+	if (copy_to_user(buf, &queue->off, sizeof(__u64))) {
+		ret = -EFAULT;
+		goto exit_unlock;
+	}
+
+	/*
+	 * Install KDBUS_MSG_PAYLOAD_MEMFDs file descriptors, we return
+	 * the list of file descriptors to be able to cleanup on error.
+	 */
+	if (queue->memfds_count > 0) {
+		ret = kdbus_conn_memfds_install(conn, queue, &memfds);
+		if (ret < 0)
+			goto exit_unlock;
+	}
+
+	/* install KDBUS_MSG_FDS file descriptors */
+	if (queue->fds_count > 0) {
+		ret = kdbus_conn_fds_install(conn, queue);
+		if (ret < 0)
+			goto exit_rewind;
+	}
+
+	kfree(memfds);
+
+	list_del(&queue->entry);
+	conn->msg_count--;
+	mutex_unlock(&conn->lock);
+
+	kdbus_pool_flush_dcache(conn->pool, queue->off, queue->size);
+	kdbus_conn_queue_cleanup(queue);
+	return 0;
+
+exit_rewind:
+	for (i = 0; i < queue->memfds_count; i++)
+		sys_close(memfds[i]);
+	kfree(memfds);
+
+exit_unlock:
+	mutex_unlock(&conn->lock);
+	return ret;
+}
+
+/**
+ * kdbus_conn_drop_msg - receive a message from the queue
+ * @conn:		Connection to work on
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_conn_drop_msg(struct kdbus_conn *conn)
+{
+	struct kdbus_conn_queue *queue;
+	int ret;
+
+	mutex_lock(&conn->lock);
+	if (unlikely(conn->ep->disconnected)) {
+		ret = -ECONNRESET;
+		goto exit_unlock;
+	}
+
+	if (conn->msg_count == 0) {
+		ret = -EAGAIN;
+		goto exit_unlock;
+	}
+
+	queue = list_first_entry(&conn->msg_list,
+				 struct kdbus_conn_queue, entry);
+	list_del(&queue->entry);
+	conn->msg_count--;
+
+	kdbus_pool_free_range(conn->pool, queue->off);
+	mutex_unlock(&conn->lock);
+
+	kdbus_conn_queue_cleanup(queue);
+	return 0;
+
+exit_unlock:
+	mutex_unlock(&conn->lock);
+	return ret;
+}
+
+/**
+ * kdbus_conn_src_msg - return the sender of a message in the queue
+ * @conn:		Connection to work on
+ * @buf:		The ID of the sender of the next message in the queue
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_conn_src_msg(struct kdbus_conn *conn, __u64 __user *buf)
+{
+	struct kdbus_conn_queue *queue;
+	int ret;
+
+	mutex_lock(&conn->lock);
+	if (unlikely(conn->ep->disconnected)) {
+		ret = -ECONNRESET;
+		goto exit_unlock;
+	}
+
+	if (conn->msg_count == 0) {
+		ret = -EAGAIN;
+		goto exit_unlock;
+	}
+
+	queue = list_first_entry(&conn->msg_list,
+				 struct kdbus_conn_queue, entry);
+	if (copy_to_user(buf, &queue->src_id, sizeof(__u64))) {
+		ret = -EFAULT;
+		goto exit_unlock;
+	}
+
+	mutex_unlock(&conn->lock);
+	return 0;
+
+exit_unlock:
+	mutex_unlock(&conn->lock);
+	return ret;
+}
+
+/**
+ * kdbus_conn_disconnect() - disconnect a connection
+ * @conn:			The connection to disconnect
+ * @ensure_msg_list_empty:	Flag to indicate if the call should fail in
+ *				case the connection's message list is not
+ *				empty
+ *
+ * Returns 0 on success.
+ * If @ensure_msg_list_empty is true, and the connection has pending messages,
+ * -EBUSY is returned.
+ */
+int kdbus_conn_disconnect(struct kdbus_conn *conn, bool ensure_msg_list_empty)
+{
+	struct kdbus_conn_queue *queue, *tmp;
+	struct kdbus_bus *bus;
+	LIST_HEAD(notify_list);
+
+	mutex_lock(&conn->lock);
+	if (conn->disconnected) {
+		mutex_unlock(&conn->lock);
+		return -EALREADY;
+	}
+
+	if (ensure_msg_list_empty && !list_empty(&conn->msg_list)) {
+		mutex_unlock(&conn->lock);
+		return -EBUSY;
+	}
+
+	conn->disconnected = true;
+	mutex_unlock(&conn->lock);
+
+	bus = conn->ep->bus;
+
+	/* remove from bus */
+	mutex_lock(&bus->lock);
+	hash_del(&conn->hentry);
+	list_del(&conn->monitor_entry);
+	mutex_unlock(&bus->lock);
+
+	/* clean up any messages still left on this endpoint */
+	mutex_lock(&conn->lock);
+	list_for_each_entry_safe(queue, tmp, &conn->msg_list, entry) {
+		if (queue->src_id > 0)
+			kdbus_notify_reply_dead(queue->src_id,
+						queue->cookie, &notify_list);
+
+		list_del(&queue->entry);
+		kdbus_pool_free_range(conn->pool, queue->off);
+		kdbus_conn_queue_cleanup(queue);
+	}
+	mutex_unlock(&conn->lock);
+
+	/* if we die while other connections wait for our reply, notify them */
+	if (unlikely(atomic_read(&conn->reply_count) > 0)) {
+		struct kdbus_conn *c;
+		int i;
+		struct kdbus_conn_reply_entry *reply, *reply_tmp;
+
+		mutex_lock(&bus->lock);
+		hash_for_each(bus->conn_hash, i, c, hentry) {
+
+			mutex_lock(&c->lock);
+			list_for_each_entry_safe(reply, reply_tmp,
+						 &c->reply_list, entry) {
+				if (conn != reply->conn)
+					continue;
+
+				kdbus_notify_reply_dead(c->id, reply->cookie,
+							&notify_list);
+
+				/* mark entry as handled, and trigger timeout */
+				reply->deadline_ns = 0;
+				kdbus_conn_timeout_schedule_scan(c);
+			}
+			mutex_unlock(&c->lock);
+		}
+		mutex_unlock(&bus->lock);
+	}
+
+	kdbus_notify_id_change(KDBUS_ITEM_ID_REMOVE, conn->id, conn->flags,
+			       &notify_list);
+	kdbus_conn_kmsg_list_send(conn->ep, &notify_list);
+
+	del_timer(&conn->timer);
+	cancel_work_sync(&conn->work);
+	kdbus_name_remove_by_conn(bus->name_registry, conn);
+
+	return 0;
+}
+
+static void __kdbus_conn_free(struct kref *kref)
+{
+	struct kdbus_conn *conn = container_of(kref, struct kdbus_conn, kref);
+	struct kdbus_conn_reply_entry *reply, *reply_tmp;
+
+	kdbus_conn_disconnect(conn, false);
+	if (conn->ep->policy_db)
+		kdbus_policy_db_remove_conn(conn->ep->policy_db, conn);
+
+	list_for_each_entry_safe(reply, reply_tmp, &conn->reply_list, entry)
+		kdbus_conn_reply_entry_free(reply);
+
+	kdbus_meta_free(conn->owner_meta);
+	kdbus_match_db_free(conn->match_db);
+	kdbus_pool_free(conn->pool);
+	kdbus_ep_unref(conn->ep);
+	kfree(conn);
+}
+
+/**
+ * kdbus_conn_ref() - take a connection reference
+ * @conn:		Connection
+ *
+ * Returns: the connection itself
+ */
+struct kdbus_conn *kdbus_conn_ref(struct kdbus_conn *conn)
+{
+	kref_get(&conn->kref);
+	return conn;
+}
+
+/**
+ * kdbus_conn_unref() - drop a connection reference
+ * @conn:		Connection (may be NULL)
+ *
+ * When the last reference is dropped, the connection's internal structure
+ * is freed.
+ *
+ * Returns: NULL
+ */
+struct kdbus_conn *kdbus_conn_unref(struct kdbus_conn *conn)
+{
+	if (!conn)
+		return NULL;
+
+	kref_put(&conn->kref, __kdbus_conn_free);
+	return NULL;
+}
+
+/**
+ * kdbus_conn_move_messages() - move a message from one connection to another
+ * @conn_dst:		Connection to copy to
+ * @conn_src:		Connection to copy from
+ * @name_id:		Filter for the sequence number of the registered
+ *			name, 0 means no filtering.
+ *
+ * Move all messages from one connection to another. This is used when
+ * an ordinary connection is taking over a well-known name from a
+ * activator connection.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_conn_move_messages(struct kdbus_conn *conn_dst,
+			     struct kdbus_conn *conn_src,
+			     u64 name_id)
+{
+	struct kdbus_conn_queue *q, *tmp;
+	LIST_HEAD(msg_list);
+	int ret = 0;
+
+	BUG_ON(conn_src == conn_dst);
+
+	mutex_lock(&conn_src->lock);
+	list_splice_init(&conn_src->msg_list, &msg_list);
+	conn_src->msg_count = 0;
+	mutex_unlock(&conn_src->lock);
+
+	mutex_lock(&conn_dst->lock);
+	list_for_each_entry_safe(q, tmp, &msg_list, entry) {
+
+		/* filter messages for a specific name */
+		if (name_id > 0 && q->dst_name_id != name_id)
+			continue;
+
+		ret = kdbus_pool_move(conn_dst->pool, conn_src->pool,
+				      &q->off, q->size);
+		if (ret < 0)
+			goto exit_unlock_dst;
+
+		list_add_tail(&q->entry, &conn_dst->msg_list);
+		conn_dst->msg_count++;
+	}
+
+exit_unlock_dst:
+	mutex_unlock(&conn_dst->lock);
+
+	wake_up_interruptible(&conn_dst->ep->wait);
+
+	return ret;
+}
+
+/**
+ * kdbus_cmd_conn_info() - retrieve info about a connection
+ * @conn:		Connection
+ * @buf:		The returned offset to the message in the pool
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_cmd_conn_info(struct kdbus_conn *conn,
+			void __user *buf)
+{
+	struct kdbus_cmd_conn_info *cmd_info;
+	struct kdbus_conn_info info = {};
+	struct kdbus_conn *owner_conn = NULL;
+	size_t off, pos;
+	char *name = NULL;
+	struct kdbus_meta *meta = NULL;
+	u64 size;
+	u32 hash;
+	int ret = 0;
+
+	if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_conn_info))
+		return -EFAULT;
+
+	if (size < sizeof(struct kdbus_cmd_conn_info))
+		return -EINVAL;
+
+	if (size > sizeof(struct kdbus_cmd_conn_info) + KDBUS_NAME_MAX_LEN + 1)
+		return -EMSGSIZE;
+
+	cmd_info = memdup_user(buf, size);
+	if (IS_ERR(cmd_info))
+		return PTR_ERR(cmd_info);
+
+	if (cmd_info->id == 0) {
+		if (size == sizeof(struct kdbus_cmd_conn_info)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		if (!kdbus_name_is_valid(cmd_info->name)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		name = cmd_info->name;
+		hash = kdbus_str_hash(name);
+	} else {
+		struct kdbus_bus *bus = conn->ep->bus;
+
+		mutex_lock(&bus->lock);
+		owner_conn = kdbus_bus_find_conn_by_id(bus, cmd_info->id);
+		mutex_unlock(&bus->lock);
+	}
+
+	/*
+	 * If a lookup by name was requested, set owner_conn to the
+	 * matching entry's connection pointer. Otherwise, owner_conn
+	 * was already set above.
+	 */
+	if (name) {
+		struct kdbus_name_entry *e;
+
+		if (!kdbus_check_strlen(cmd_info, name)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		e = kdbus_name_lookup(conn->ep->bus->name_registry, name);
+		if (!e) {
+			ret = -ENOENT;
+			goto exit;
+		}
+
+		if (e->conn)
+			owner_conn = kdbus_conn_ref(e->conn);
+	}
+
+	if (!owner_conn) {
+		ret = -ENXIO;
+		goto exit;
+	}
+
+	info.size = sizeof(struct kdbus_conn_info);
+	info.id = owner_conn->id;
+	info.flags = owner_conn->flags;
+
+	/* do not leak namespace-specific credentials */
+	if (conn->meta->ns == owner_conn->meta->ns)
+		info.size += owner_conn->meta->size;
+
+	/*
+	 * Unlike the rest of the values which are cached at
+	 * connection creation time, the names are appended here
+	 * because at creation time a connection does not have
+	 * any name.
+	 */
+	if (cmd_info->flags & KDBUS_ATTACH_NAMES &&
+	    !(owner_conn->flags & KDBUS_HELLO_ACTIVATOR)) {
+		ret = kdbus_meta_new(&meta);
+		if (ret < 0)
+			goto exit;
+
+		ret = kdbus_meta_append(meta, owner_conn, KDBUS_ATTACH_NAMES);
+		if (ret < 0)
+			goto exit;
+
+		info.size += meta->size;
+	}
+
+	ret = kdbus_pool_alloc_range(conn->pool, info.size, &off);
+	if (ret < 0)
+		goto exit;
+
+	ret = kdbus_pool_write(conn->pool, off, &info, sizeof(info));
+	if (ret < 0)
+		goto exit_free;
+	pos = off + sizeof(struct kdbus_conn_info);
+
+	if (conn->meta->ns == owner_conn->meta->ns) {
+		ret = kdbus_pool_write(conn->pool, pos, owner_conn->meta->data,
+				       owner_conn->meta->size);
+		if (ret < 0)
+			goto exit_free;
+		pos += owner_conn->meta->size;
+	}
+
+	if (meta) {
+		ret = kdbus_pool_write(conn->pool, pos, meta->data, meta->size);
+		if (ret < 0)
+			goto exit_free;
+
+		pos += meta->size;
+	}
+
+	if (kdbus_offset_set_user(&off, buf, struct kdbus_cmd_conn_info)) {
+		ret = -EFAULT;
+		goto exit_free;
+	}
+
+exit_free:
+	if (ret < 0)
+		kdbus_pool_free_range(conn->pool, off);
+
+exit:
+	kdbus_meta_free(meta);
+	kdbus_conn_unref(owner_conn);
+	kfree(cmd_info);
+
+	return ret;
+}
+
+/**
+ * kdbus_conn_new() - create a new connection
+ * @ep:			The endpoint the connection is connected to
+ * @hello:		The kdbus_cmd_hello as passed in by the user
+ * @meta:		The metadata gathered at open() time of the handle
+ * @c:			Returned connection
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_conn_new(struct kdbus_ep *ep,
+		   struct kdbus_cmd_hello *hello,
+		   struct kdbus_meta *meta,
+		   struct kdbus_conn **c)
+{
+	struct kdbus_conn *conn;
+	struct kdbus_bus *bus = ep->bus;
+	const struct kdbus_item *item;
+	const char *activator_name = NULL;
+	const struct kdbus_creds *creds = NULL;
+	const char *seclabel = NULL;
+	size_t seclabel_len = 0;
+	LIST_HEAD(notify_list);
+	int ret;
+
+	BUG_ON(*c);
+
+	if (hello->conn_flags & KDBUS_HELLO_ACTIVATOR &&
+	    hello->conn_flags & KDBUS_HELLO_MONITOR)
+		return -EINVAL;
+
+	KDBUS_ITEM_FOREACH(item, hello, items) {
+		switch (item->type) {
+		case KDBUS_ITEM_NAME:
+			if (!(hello->conn_flags & KDBUS_HELLO_ACTIVATOR))
+				return -EINVAL;
+
+			if (activator_name)
+				return -EINVAL;
+			activator_name = item->str;
+			break;
+
+		case KDBUS_ITEM_CREDS:
+			/* privileged processes can impersonate somebody else */
+			if (!kdbus_bus_uid_is_privileged(bus))
+				return -EPERM;
+
+			if (item->size !=
+			    KDBUS_ITEM_SIZE(sizeof(struct kdbus_creds)))
+				return -EINVAL;
+
+			creds = &item->creds;
+			break;
+
+		case KDBUS_ITEM_SECLABEL:
+			/* privileged processes can impersonate somebody else */
+			if (!kdbus_bus_uid_is_privileged(bus))
+				return -EPERM;
+
+			seclabel = item->str;
+			seclabel_len = item->size - KDBUS_ITEM_HEADER_SIZE;
+			break;
+		}
+	}
+
+	if ((hello->conn_flags & KDBUS_HELLO_ACTIVATOR) && !activator_name)
+		return -EINVAL;
+
+	conn = kzalloc(sizeof(*conn), GFP_KERNEL);
+	if (!conn)
+		return -ENOMEM;
+
+	kref_init(&conn->kref);
+	mutex_init(&conn->lock);
+	INIT_LIST_HEAD(&conn->msg_list);
+	INIT_LIST_HEAD(&conn->names_list);
+	INIT_LIST_HEAD(&conn->names_queue_list);
+	INIT_LIST_HEAD(&conn->reply_list);
+	atomic_set(&conn->reply_count, 0);
+	INIT_WORK(&conn->work, kdbus_conn_work);
+	init_timer(&conn->timer);
+	conn->timer.expires = 0;
+	conn->timer.function = kdbus_conn_timer_func;
+	conn->timer.data = (unsigned long) conn;
+	add_timer(&conn->timer);
+
+	/* init entry, so we can unconditionally remove it */
+	INIT_LIST_HEAD(&conn->monitor_entry);
+
+	ret = kdbus_pool_new(&conn->pool, hello->pool_size);
+	if (ret < 0)
+		goto exit_unref;
+
+	ret = kdbus_match_db_new(&conn->match_db);
+	if (ret < 0)
+		goto exit_unref;
+
+	conn->ep = kdbus_ep_ref(ep);
+
+	/* link into bus; get new id for this connection */
+	mutex_lock(&bus->lock);
+	conn->id = bus->conn_id_next++;
+	hash_add(bus->conn_hash, &conn->hentry, conn->id);
+	mutex_unlock(&bus->lock);
+
+	/* return properties of this connection to the caller */
+	hello->bus_flags = bus->bus_flags;
+	hello->bloom_size = bus->bloom_size;
+	hello->id = conn->id;
+
+	BUILD_BUG_ON(sizeof(bus->id128) != sizeof(hello->id128));
+	memcpy(hello->id128, bus->id128, sizeof(hello->id128));
+
+	/* notify about the new active connection */
+	ret = kdbus_notify_id_change(KDBUS_ITEM_ID_ADD, conn->id, conn->flags,
+				     &notify_list);
+	if (ret < 0)
+		goto exit_unref;
+	kdbus_conn_kmsg_list_send(conn->ep, &notify_list);
+
+	conn->flags = hello->conn_flags;
+	conn->attach_flags = hello->attach_flags;
+
+	if (activator_name) {
+		u64 flags = KDBUS_NAME_ACTIVATOR;
+
+		ret = kdbus_name_acquire(bus->name_registry, conn,
+					 activator_name, &flags, NULL);
+		if (ret < 0)
+			goto exit_unref;
+	}
+
+	if (hello->conn_flags & KDBUS_HELLO_MONITOR) {
+		mutex_lock(&bus->lock);
+		list_add_tail(&conn->monitor_entry, &bus->monitors_list);
+		mutex_unlock(&bus->lock);
+	}
+
+	/* privileged processes can impersonate somebody else */
+	if (creds || seclabel) {
+		ret = kdbus_meta_new(&conn->owner_meta);
+		if (ret < 0)
+			goto exit_unref;
+
+		if (creds) {
+			ret = kdbus_meta_append_data(conn->owner_meta,
+					KDBUS_ITEM_CREDS,
+					creds, sizeof(struct kdbus_creds));
+			if (ret < 0)
+				goto exit_unref;
+		}
+
+		if (seclabel) {
+			ret = kdbus_meta_append_data(conn->owner_meta,
+						     KDBUS_ITEM_SECLABEL,
+						     seclabel, seclabel_len);
+			if (ret < 0)
+				goto exit_unref;
+		}
+
+		/* use the information provided with the HELLO call */
+		conn->meta = conn->owner_meta;
+	} else {
+		/* use the connection's metadata gathered at open() */
+		conn->meta = meta;
+	}
+
+	*c = conn;
+	return 0;
+
+exit_unref:
+	kdbus_conn_unref(conn);
+	return ret;
+}
+
+
+/**
+ * kdbus_conn_has_name() - check if a connection owns a name
+ * @conn:		Connection
+ * @name:		Well-know name to check for
+ *
+ * Returns true if the name is currently owned by the connection.
+ */
+bool kdbus_conn_has_name(struct kdbus_conn *conn, const char *name)
+{
+	struct kdbus_name_entry *e;
+	bool match = false;
+
+	mutex_lock(&conn->lock);
+	list_for_each_entry(e, &conn->names_list, conn_entry) {
+		if (strcmp(e->name, name) == 0) {
+			match = true;
+			break;
+		}
+	}
+	mutex_unlock(&conn->lock);
+
+	return match;
+}
diff --git a/drivers/kdbus/connection.h b/drivers/kdbus/connection.h
new file mode 100644
index 0000000..27babdf
--- /dev/null
+++ b/drivers/kdbus/connection.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_CONNECTION_H
+#define __KDBUS_CONNECTION_H
+
+#include "internal.h"
+#include "metadata.h"
+#include "pool.h"
+
+/**
+ * struct kdbus_conn - connection to a bus
+ * @kref:		Reference count
+ * @disconnected:	Invalidated data
+ * @ep:			The endpoint this connection belongs to
+ * @id:			Connection ID
+ * @flags:		KDBUS_HELLO_* flags
+ * @attach_flags:	KDBUS_ATTACH_* flags
+ * @lock:		Connection data lock
+ * @msg_list:		Queue of messages
+ * @hentry:		Entry in ID <-> connection map
+ * @monitor_entry:	The connection is a monitor
+ * @names_list:		List of well-known names
+ * @names_queue_list:	Well-known names this connection waits for
+ * @reply_list:		List of connections this connection expects
+ *			a reply from.
+ * @reply_count:	Number of requests this connection has issued, and
+ *			waits for replies from the peer
+ * @names:		Number of owned well-known names
+ * @work:		Support for poll()
+ * @timer:		Message reply timeout handling
+ * @match_db:		Subscription filter to broadcast messages
+ * @meta:		Active connection creator's metadata/credentials,
+ *			either from the handle of from HELLO
+ * @owner_meta:		The connection's metadata/credentials supplied by
+ *			HELLO
+ * @msg_count:		Number of queued messages
+ * @pool:		The user's buffer to receive messages
+ */
+struct kdbus_conn {
+	struct kref kref;
+	bool disconnected;
+	struct kdbus_ep *ep;
+	u64 id;
+	u64 flags;
+	u64 attach_flags;
+	struct mutex lock;
+	struct list_head msg_list;
+	struct hlist_node hentry;
+	struct list_head monitor_entry;
+	struct list_head names_list;
+	struct list_head names_queue_list;
+	struct list_head reply_list;
+	atomic_t reply_count;
+	size_t names;
+	struct work_struct work;
+	struct timer_list timer;
+	struct kdbus_match_db *match_db;
+	struct kdbus_meta *meta;
+	struct kdbus_meta *owner_meta;
+	unsigned int msg_count;
+	struct kdbus_pool *pool;
+};
+
+struct kdbus_kmsg;
+struct kdbus_conn_queue;
+struct kdbus_name_registry;
+
+int kdbus_conn_new(struct kdbus_ep *ep,
+		   struct kdbus_cmd_hello *hello,
+		   struct kdbus_meta *meta,
+		   struct kdbus_conn **conn);
+struct kdbus_conn *kdbus_conn_ref(struct kdbus_conn *conn);
+struct kdbus_conn *kdbus_conn_unref(struct kdbus_conn *conn);
+int kdbus_conn_disconnect(struct kdbus_conn *conn, bool ensure_msg_list_empty);
+
+int kdbus_conn_recv_msg(struct kdbus_conn *conn, __u64 __user *buf);
+int kdbus_conn_drop_msg(struct kdbus_conn *conn);
+int kdbus_conn_src_msg(struct kdbus_conn *conn, __u64 __user *buf);
+int kdbus_cmd_conn_info(struct kdbus_conn *conn,
+			void __user *buf);
+int kdbus_conn_kmsg_send(struct kdbus_ep *ep,
+			 struct kdbus_conn *conn_src,
+			 struct kdbus_kmsg *kmsg);
+void kdbus_conn_kmsg_list_free(struct list_head *kmsg_list);
+int kdbus_conn_kmsg_list_send(struct kdbus_ep *ep,
+			      struct list_head *kmsg_list);
+int kdbus_conn_move_messages(struct kdbus_conn *conn_dst,
+			     struct kdbus_conn *conn_src,
+			     u64 name_id);
+bool kdbus_conn_has_name(struct kdbus_conn *conn, const char *name);
+#endif
diff --git a/drivers/kdbus/endpoint.c b/drivers/kdbus/endpoint.c
new file mode 100644
index 0000000..ea7d95d
--- /dev/null
+++ b/drivers/kdbus/endpoint.c
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "bus.h"
+#include "endpoint.h"
+#include "namespace.h"
+#include "policy.h"
+
+/* endpoints are by default owned by the bus owner */
+static char *kdbus_devnode_ep(struct device *dev, umode_t *mode,
+			      kuid_t *uid, kgid_t *gid)
+{
+	struct kdbus_ep *ep = dev_get_drvdata(dev);
+
+	if (mode)
+		*mode = ep->mode;
+	if (uid)
+		*uid = ep->uid;
+	if (gid)
+		*gid = ep->gid;
+
+	return NULL;
+}
+
+static void kdbus_dev_release(struct device *dev)
+{
+	kfree(dev);
+}
+
+static struct device_type kdbus_devtype_ep = {
+	.name		= "ep",
+	.release	= kdbus_dev_release,
+	.devnode	= kdbus_devnode_ep,
+};
+
+struct kdbus_ep *kdbus_ep_ref(struct kdbus_ep *ep)
+{
+	kref_get(&ep->kref);
+	return ep;
+}
+
+/**
+ * kdbus_ep_disconnect() - disconnect an endpoint
+ * @ep:			Endpoint
+ */
+void kdbus_ep_disconnect(struct kdbus_ep *ep)
+{
+	mutex_lock(&ep->lock);
+	if (ep->disconnected) {
+		mutex_unlock(&ep->lock);
+		return;
+	}
+
+	ep->disconnected = true;
+	mutex_unlock(&ep->lock);
+
+	/* disconnect from bus */
+	mutex_lock(&ep->bus->lock);
+	if (ep->bus)
+		list_del(&ep->bus_entry);
+	mutex_unlock(&ep->bus->lock);
+
+	if (ep->dev) {
+		device_unregister(ep->dev);
+		ep->dev = NULL;
+	}
+	if (ep->minor > 0) {
+		idr_remove(&ep->bus->ns->idr, ep->minor);
+		ep->minor = 0;
+	}
+
+	/*
+	 * wake up the queue so the connections can report
+	 * POLLERR to their users.
+	 */
+	wake_up_interruptible(&ep->wait);
+}
+
+static void __kdbus_ep_free(struct kref *kref)
+{
+	struct kdbus_ep *ep = container_of(kref, struct kdbus_ep, kref);
+
+	kdbus_ep_disconnect(ep);
+	if (ep->policy_db)
+		kdbus_policy_db_free(ep->policy_db);
+	kdbus_bus_unref(ep->bus);
+	kfree(ep->name);
+	kfree(ep);
+}
+
+struct kdbus_ep *kdbus_ep_unref(struct kdbus_ep *ep)
+{
+	if (!ep)
+		return NULL;
+
+	kref_put(&ep->kref, __kdbus_ep_free);
+	return NULL;
+}
+
+static struct kdbus_ep *kdbus_ep_find(struct kdbus_bus *bus, const char *name)
+{
+	struct kdbus_ep *ep = NULL;
+	struct kdbus_ep *e;
+
+	mutex_lock(&bus->lock);
+	list_for_each_entry(e, &bus->ep_list, bus_entry) {
+		if (strcmp(e->name, name) != 0)
+			continue;
+
+		ep = kdbus_ep_ref(e);
+	}
+	mutex_unlock(&bus->lock);
+
+	return ep;
+}
+
+/**
+ * kdbus_ep_new() - create a new endpoint
+ * @bus:		The bus this endpoint will be created for
+ * @ns:			The namespace of the bus; needed separately when
+ *			creating the default endpoint for a new bus
+ * @name:		The name of the endpoint
+ * @mode:		The access mode for the device node
+ * @uid:		The uid of the device node
+ * @gid:		The gid of the device node
+ * @policy_open:	Default policy of allow or deny
+ *
+ * This function will create a new enpoint with the given
+ * name and properties for a given bus.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_ep_new(struct kdbus_bus *bus, struct kdbus_ns *ns, const char *name,
+		 umode_t mode, kuid_t uid, kgid_t gid, bool policy_open)
+{
+	struct kdbus_ep *e;
+	int ret;
+
+	e = kdbus_ep_find(bus, name);
+	if (e) {
+		kdbus_ep_unref(e);
+		return -EEXIST;
+	}
+
+	e = kzalloc(sizeof(struct kdbus_ep), GFP_KERNEL);
+	if (!e)
+		return -ENOMEM;
+
+	mutex_init(&e->lock);
+	kref_init(&e->kref);
+	e->uid = uid;
+	e->gid = gid;
+	e->mode = mode;
+	init_waitqueue_head(&e->wait);
+
+	e->name = kstrdup(name, GFP_KERNEL);
+	if (!e->name) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	mutex_lock(&ns->lock);
+	/* register minor in our endpoint map */
+	ret = idr_alloc(&ns->idr, e, 1, 0, GFP_KERNEL);
+	if (ret < 0) {
+		if (ret == -ENOSPC)
+			ret = -EEXIST;
+		mutex_unlock(&ns->lock);
+		goto exit;
+	}
+	e->minor = ret;
+	mutex_unlock(&ns->lock);
+
+	/* register bus endpoint device */
+	e->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
+	if (!e->dev) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	dev_set_name(e->dev, "%s/%s/%s", ns->devpath, bus->name, name);
+	e->dev->bus = &kdbus_subsys;
+	e->dev->type = &kdbus_devtype_ep;
+	e->dev->devt = MKDEV(ns->major, e->minor);
+	dev_set_drvdata(e->dev, e);
+	ret = device_register(e->dev);
+	if (ret < 0) {
+		put_device(e->dev);
+		e->dev = NULL;
+	}
+
+	/* install policy */
+	e->policy_open = policy_open;
+	if (!policy_open) {
+		ret = kdbus_policy_db_new(&e->policy_db);
+		if (ret < 0)
+			goto exit;
+	}
+
+	/* link into bus  */
+	mutex_lock(&bus->lock);
+	e->id = bus->ep_id_next++;
+	e->bus = kdbus_bus_ref(bus);
+	list_add_tail(&e->bus_entry, &bus->ep_list);
+	mutex_unlock(&bus->lock);
+	return 0;
+
+exit:
+	kdbus_ep_unref(e);
+	return ret;
+}
+
+/**
+ * kdbus_ep_make_user() - create endpoint data from user data
+ * @buf:		User data
+ * @make:		The returned copy of user data
+ * @name:		The name of the endpoint to create
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_ep_make_user(void __user *buf,
+		       struct kdbus_cmd_make **make, char **name)
+{
+	u64 size;
+	struct kdbus_cmd_make *m;
+	const struct kdbus_item *item;
+	const char *n = NULL;
+	int ret;
+
+	if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_make))
+		return -EFAULT;
+
+	if (size < sizeof(struct kdbus_cmd_make) || size > KDBUS_MAKE_MAX_SIZE)
+		return -EMSGSIZE;
+
+	m = memdup_user(buf, size);
+	if (IS_ERR(m)) {
+		ret = PTR_ERR(m);
+		goto exit;
+	}
+
+	KDBUS_ITEM_FOREACH(item, m, items) {
+		if (!KDBUS_ITEM_VALID(item, m)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		switch (item->type) {
+		case KDBUS_ITEM_MAKE_NAME:
+			if (n) {
+				ret = -EEXIST;
+				goto exit;
+			}
+
+			if (item->size < KDBUS_ITEM_HEADER_SIZE + 2) {
+				ret = -EINVAL;
+				goto exit;
+			}
+
+			if (item->size > KDBUS_ITEM_HEADER_SIZE +
+					 KDBUS_MAKE_MAX_LEN + 1) {
+				ret = -ENAMETOOLONG;
+				goto exit;
+			}
+
+			if (!kdbus_validate_nul(item->str,
+					item->size - KDBUS_ITEM_HEADER_SIZE)) {
+				ret = -EINVAL;
+				goto exit;
+			}
+
+			n = item->str;
+			continue;
+
+		default:
+			ret = -ENOTSUPP;
+			goto exit;
+		}
+	}
+
+	if (!KDBUS_ITEM_END(item, m)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (!n) {
+		ret = -EBADMSG;
+		goto exit;
+	}
+
+	*make = m;
+	*name = (char *)n;
+	return 0;
+
+exit:
+	kfree(m);
+	return ret;
+}
diff --git a/drivers/kdbus/endpoint.h b/drivers/kdbus/endpoint.h
new file mode 100644
index 0000000..0db1bda
--- /dev/null
+++ b/drivers/kdbus/endpoint.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_EP_H
+#define __KDBUS_EP_H
+
+#include "internal.h"
+
+/*
+ * struct kdbus_endpoint - enpoint to access a bus
+ * @kref		reference count
+ * @disconnected	invalidated data
+ * @bus			bus behind this endpoint
+ * @name		name of the endpoint
+ * @id			id of this endpoint on the bus
+ * @minor		minor of this endpoint in the namespace major
+ * @dev			device node of this endpoint
+ * @mode		file mode of this endpoint device node
+ * @uid			uid owning this endpoint
+ * @gid			gid owning this endpoint
+ * @bus_entry		bus' endpoints
+ * @wait		wake up this endpoint
+ * @lock		endpoint data lock
+ * @policy_db		uploaded policy
+ * @policy_open		default endpoint policy
+ *
+ * An enpoint offers access to a bus; the default device node name is "bus".
+ * Additional custom endpoints to the same bus can be created and they can
+ * carry their own policies/filters.
+ */
+struct kdbus_ep {
+	struct kref kref;
+	bool disconnected;
+	struct kdbus_bus *bus;
+	const char *name;
+	u64 id;
+	unsigned int minor;
+	struct device *dev;
+	umode_t mode;
+	kuid_t uid;
+	kgid_t gid;
+	struct list_head bus_entry;
+	wait_queue_head_t wait;
+	struct mutex lock;
+	struct kdbus_policy_db *policy_db;
+	bool policy_open:1;
+};
+
+struct kdbus_ns;
+
+int kdbus_ep_new(struct kdbus_bus *bus, struct kdbus_ns *ns, const char *name,
+		 umode_t mode, kuid_t uid, kgid_t gid, bool policy);
+struct kdbus_ep *kdbus_ep_ref(struct kdbus_ep *ep);
+struct kdbus_ep *kdbus_ep_unref(struct kdbus_ep *ep);
+void kdbus_ep_disconnect(struct kdbus_ep *ep);
+int kdbus_ep_make_user(void __user *buf,
+		       struct kdbus_cmd_make **make, char **name);
+#endif
diff --git a/drivers/kdbus/handle.c b/drivers/kdbus/handle.c
new file mode 100644
index 0000000..a33a1c4
--- /dev/null
+++ b/drivers/kdbus/handle.c
@@ -0,0 +1,668 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "bus.h"
+#include "connection.h"
+#include "endpoint.h"
+#include "handle.h"
+#include "match.h"
+#include "memfd.h"
+#include "message.h"
+#include "metadata.h"
+#include "names.h"
+#include "namespace.h"
+#include "notify.h"
+#include "policy.h"
+
+/**
+ * enum kdbus_handle_type - type a handle can be of
+ * @_KDBUS_HANDLE_NULL:			Uninitialized/invalid
+ * @KDBUS_HANDLE_CONTROL:		New file descriptor of a control node
+ * @KDBUS_HANDLE_CONTROL_NS_OWNER:	File descriptor to hold a namespace
+ * @KDBUS_HANDLE_CONTROL_BUS_OWNER:	File descriptor to hold a bus
+ * @KDBUS_HANDLE_EP:			New file descriptor of a bus node
+ * @KDBUS_HANDLE_EP_CONNECTED:		A bus connection after HELLO
+ * @KDBUS_HANDLE_EP_OWNER:		File descriptor to hold an endpoint
+ * @KDBUS_HANDLE_DISCONNECTED:		Handle is disconnected
+ */
+enum kdbus_handle_type {
+	_KDBUS_HANDLE_NULL,
+	KDBUS_HANDLE_CONTROL,
+	KDBUS_HANDLE_CONTROL_NS_OWNER,
+	KDBUS_HANDLE_CONTROL_BUS_OWNER,
+	KDBUS_HANDLE_EP,
+	KDBUS_HANDLE_EP_CONNECTED,
+	KDBUS_HANDLE_EP_OWNER,
+	KDBUS_HANDLE_DISCONNECTED,
+};
+
+/**
+ * struct kdbus_handle - a handle to the kdbus system
+ * @type:	Type of this handle (KDBUS_HANDLE_*)
+ * @ns:		Namespace for this handle
+ * @meta:	Cached connection creator's metadata/credentials
+ * @ep:		The endpoint this handle owns, in case @type
+ *		is KDBUS_HANDLE_EP
+ * @ns_owner:	The namespace this handle owns, in case @type
+ *		is KDBUS_HANDLE_CONTROL_NS_OWNER
+ * @bus_owner:	The bus this handle owns, in case @type
+ *		is KDBUS_HANDLE_CONTROL_BUS_OWNER
+ * @ep_owner	The endpoint this handle owns, in case @type
+ *		is KDBUS_HANDLE_EP_OWNER
+ * @conn	The connection this handle owns, in case @type
+ *		is KDBUS_HANDLE_EP, after HELLO it is
+ *		KDBUS_HANDLE_EP_CONNECTED
+ */
+struct kdbus_handle {
+	enum kdbus_handle_type type;
+	struct kdbus_ns *ns;
+	struct kdbus_meta *meta;
+	struct kdbus_ep *ep;
+	union {
+		struct kdbus_ns *ns_owner;
+		struct kdbus_bus *bus_owner;
+		struct kdbus_ep *ep_owner;
+		struct kdbus_conn *conn;
+	};
+};
+
+static int kdbus_handle_open(struct inode *inode, struct file *file)
+{
+	struct kdbus_handle *handle;
+	struct kdbus_ns *ns;
+	struct kdbus_ep *ep;
+	int ret;
+
+	handle = kzalloc(sizeof(struct kdbus_handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	/* find and reference namespace */
+	ns = kdbus_ns_find_by_major(MAJOR(inode->i_rdev));
+	if (!ns || ns->disconnected) {
+		kfree(handle);
+		return -ESHUTDOWN;
+	}
+	handle->ns = ns;
+	file->private_data = handle;
+
+	/* control device node */
+	if (MINOR(inode->i_rdev) == 0) {
+		handle->type = KDBUS_HANDLE_CONTROL;
+		return 0;
+	}
+
+	/* find endpoint for device node */
+	mutex_lock(&handle->ns->lock);
+	ep = idr_find(&handle->ns->idr, MINOR(inode->i_rdev));
+	if (!ep || ep->disconnected) {
+		ret = -ESHUTDOWN;
+		goto exit_unlock;
+	}
+
+	/* create endpoint connection */
+	handle->type = KDBUS_HANDLE_EP;
+	handle->ep = kdbus_ep_ref(ep);
+
+	/* cache the metadata/credentials of the creator of the connection */
+	ret = kdbus_meta_new(&handle->meta);
+	if (ret < 0)
+		goto exit_unlock;
+
+	ret = kdbus_meta_append(handle->meta, NULL,
+				KDBUS_ATTACH_CREDS |
+				KDBUS_ATTACH_COMM |
+				KDBUS_ATTACH_EXE |
+				KDBUS_ATTACH_CMDLINE |
+				KDBUS_ATTACH_CGROUP |
+				KDBUS_ATTACH_CAPS |
+				KDBUS_ATTACH_SECLABEL |
+				KDBUS_ATTACH_AUDIT);
+	if (ret < 0)
+		goto exit_unlock;
+
+	mutex_unlock(&handle->ns->lock);
+	return 0;
+
+exit_unlock:
+	mutex_unlock(&handle->ns->lock);
+	kdbus_ns_unref(handle->ns);
+	kfree(handle);
+	return ret;
+}
+
+static int kdbus_handle_release(struct inode *inode, struct file *file)
+{
+	struct kdbus_handle *handle = file->private_data;
+
+	switch (handle->type) {
+	case KDBUS_HANDLE_CONTROL_NS_OWNER:
+		kdbus_ns_disconnect(handle->ns_owner);
+		kdbus_ns_unref(handle->ns_owner);
+		break;
+
+	case KDBUS_HANDLE_CONTROL_BUS_OWNER:
+		kdbus_bus_disconnect(handle->bus_owner);
+		kdbus_bus_unref(handle->bus_owner);
+		break;
+
+	case KDBUS_HANDLE_EP_OWNER:
+		kdbus_ep_disconnect(handle->ep_owner);
+		kdbus_ep_unref(handle->ep_owner);
+		break;
+
+	case KDBUS_HANDLE_EP:
+		kdbus_ep_unref(handle->ep);
+		break;
+
+	case KDBUS_HANDLE_EP_CONNECTED:
+		kdbus_conn_disconnect(handle->conn, false);
+		kdbus_conn_unref(handle->conn);
+		break;
+
+	default:
+		break;
+	}
+
+	kdbus_meta_free(handle->meta);
+	kdbus_ns_unref(handle->ns);
+	kfree(handle);
+
+	return 0;
+}
+
+static bool kdbus_check_flags(u64 kernel_flags)
+{
+	/*
+	 * The higher 32bit are considered 'incompatible
+	 * flags'. Refuse them all for now.
+	 */
+	return kernel_flags <= 0xFFFFFFFFULL;
+}
+
+/* kdbus control device commands */
+static long kdbus_handle_ioctl_control(struct file *file, unsigned int cmd,
+				       void __user *buf)
+{
+	struct kdbus_handle *handle = file->private_data;
+	struct kdbus_cmd_make *make = NULL;
+	struct kdbus_bus *bus = NULL;
+	struct kdbus_ns *ns = NULL;
+	umode_t mode = 0600;
+	int ret;
+
+	switch (cmd) {
+	case KDBUS_CMD_BUS_MAKE: {
+		kgid_t gid = KGIDT_INIT(0);
+		size_t bloom_size;
+		char *name;
+
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_bus_make_user(buf, &make, &name, &bloom_size);
+		if (ret < 0)
+			break;
+
+		if (!kdbus_check_flags(make->flags)) {
+			ret = -ENOTSUPP;
+			break;
+		}
+
+		if (make->flags & KDBUS_MAKE_ACCESS_WORLD) {
+			mode = 0666;
+		} else if (make->flags & KDBUS_MAKE_ACCESS_GROUP) {
+			mode = 0660;
+			gid = current_fsgid();
+		}
+
+		ret = kdbus_bus_new(handle->ns, make, name, bloom_size,
+				    mode, current_fsuid(), gid, &bus);
+		if (ret < 0)
+			break;
+
+		/* turn the control fd into a new bus owner device */
+		handle->type = KDBUS_HANDLE_CONTROL_BUS_OWNER;
+		handle->bus_owner = bus;
+		break;
+	}
+
+	case KDBUS_CMD_NS_MAKE: {
+		char *name;
+
+		if (!capable(CAP_IPC_OWNER)) {
+			ret = -EPERM;
+			break;
+		}
+
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_ns_make_user(buf, &make, &name);
+		if (ret < 0)
+			break;
+
+		if (!kdbus_check_flags(make->flags)) {
+			ret = -ENOTSUPP;
+			break;
+		}
+
+		if (make->flags & KDBUS_MAKE_ACCESS_WORLD)
+			mode = 0666;
+
+		ret = kdbus_ns_new(kdbus_ns_init, name, mode, &ns);
+		if (ret < 0)
+			break;
+
+		/* turn the control fd into a new ns owner device */
+		handle->type = KDBUS_HANDLE_CONTROL_NS_OWNER;
+		handle->ns_owner = ns;
+		break;
+	}
+
+	case KDBUS_CMD_MEMFD_NEW: {
+		int fd;
+		int __user *addr = buf;
+
+		ret = kdbus_memfd_new(&fd);
+		if (ret < 0)
+			break;
+
+		if (put_user(fd, addr))
+			ret = -EFAULT;
+		break;
+	}
+
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	kfree(make);
+	return ret;
+}
+
+/* kdbus endpoint make commands */
+static long kdbus_handle_ioctl_ep(struct file *file, unsigned int cmd,
+				  void __user *buf)
+{
+	struct kdbus_handle *handle = file->private_data;
+	struct kdbus_cmd_make *make = NULL;
+	struct kdbus_cmd_hello *hello = NULL;
+	long ret = 0;
+
+	switch (cmd) {
+	case KDBUS_CMD_EP_MAKE: {
+		umode_t mode = 0;
+		kgid_t gid = KGIDT_INIT(0);
+		char *n;
+
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_ep_make_user(buf, &make, &n);
+		if (ret < 0)
+			break;
+
+		if (!kdbus_check_flags(make->flags)) {
+			ret = -ENOTSUPP;
+			break;
+		}
+
+		if (make->flags & KDBUS_MAKE_ACCESS_WORLD) {
+			mode = 0666;
+		} else if (make->flags & KDBUS_MAKE_ACCESS_GROUP) {
+			mode = 0660;
+			gid = current_fsgid();
+		}
+
+		ret = kdbus_ep_new(handle->ep->bus, handle->ep->bus->ns, n,
+				   mode, current_fsuid(), gid,
+				   make->flags & KDBUS_MAKE_POLICY_OPEN);
+
+		handle->type = KDBUS_HANDLE_EP_OWNER;
+		break;
+	}
+
+	case KDBUS_CMD_HELLO: {
+		/* turn this fd into a connection. */
+		size_t size;
+		void *v;
+
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_hello)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		if (size < sizeof(struct kdbus_cmd_hello) ||
+		    size > KDBUS_HELLO_MAX_SIZE) {
+			ret = -EMSGSIZE;
+			break;
+		}
+
+		v = memdup_user(buf, size);
+		if (IS_ERR(v)) {
+			ret = PTR_ERR(v);
+			break;
+		}
+		hello = v;
+
+		if (!kdbus_check_flags(hello->conn_flags)) {
+			ret = -ENOTSUPP;
+			break;
+		}
+
+		if (hello->pool_size == 0 ||
+		    !IS_ALIGNED(hello->pool_size, PAGE_SIZE)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_conn_new(handle->ep, hello, handle->meta,
+				     &handle->conn);
+		if (ret < 0)
+			break;
+
+		handle->type = KDBUS_HANDLE_EP_CONNECTED;
+
+		if (copy_to_user(buf, hello, sizeof(struct kdbus_cmd_hello))) {
+			kdbus_conn_unref(handle->conn);
+			ret = -EFAULT;
+		}
+
+		break;
+	}
+
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	kfree(make);
+	kfree(hello);
+
+	return ret;
+}
+
+/* kdbus endpoint commands for connected peers */
+static long kdbus_handle_ioctl_ep_connected(struct file *file, unsigned int cmd,
+					    void __user *buf)
+{
+	struct kdbus_handle *handle = file->private_data;
+	struct kdbus_conn *conn = handle->conn;
+	struct kdbus_bus *bus = conn->ep->bus;
+	long ret = 0;
+
+	switch (cmd) {
+	case KDBUS_CMD_BYEBYE:
+		ret = kdbus_conn_disconnect(conn, true);
+		if (ret == 0) {
+			kdbus_conn_unref(conn);
+			handle->type = KDBUS_HANDLE_DISCONNECTED;
+		}
+		break;
+
+	case KDBUS_CMD_EP_POLICY_SET:
+		/* upload a policy for this endpoint */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		if (!conn->ep->policy_db) {
+			ret = kdbus_policy_db_new(&conn->ep->policy_db);
+			if (ret < 0)
+				break;
+		}
+
+		ret = kdbus_cmd_policy_set_from_user(conn->ep->policy_db, buf);
+		break;
+
+	case KDBUS_CMD_NAME_ACQUIRE:
+		/* acquire a well-known name */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_cmd_name_acquire(bus->name_registry, conn, buf);
+		break;
+
+	case KDBUS_CMD_NAME_RELEASE:
+		/* release a well-known name */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_cmd_name_release(bus->name_registry, conn, buf);
+		break;
+
+	case KDBUS_CMD_NAME_LIST:
+		/* query current IDs and names */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_cmd_name_list(bus->name_registry, conn, buf);
+		break;
+
+	case KDBUS_CMD_CONN_INFO:
+		/* return the properties of a connection */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_cmd_conn_info(conn, buf);
+		break;
+
+	case KDBUS_CMD_MATCH_ADD:
+		/* subscribe to/filter for broadcast messages */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_match_db_add(conn, buf);
+		break;
+
+	case KDBUS_CMD_MATCH_REMOVE:
+		/* unsubscribe from broadcast messages */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_match_db_remove(conn, buf);
+		break;
+
+	case KDBUS_CMD_MSG_SEND: {
+		/* submit a message which will be queued in the receiver */
+		struct kdbus_kmsg *kmsg = NULL;
+
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_kmsg_new_from_user(conn, buf, &kmsg);
+		if (ret < 0)
+			break;
+
+		ret = kdbus_conn_kmsg_send(conn->ep, conn, kmsg);
+		kdbus_kmsg_free(kmsg);
+		break;
+	}
+
+	case KDBUS_CMD_MSG_RECV:
+		/* receive a pointer to a queued message */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = kdbus_conn_recv_msg(conn, buf);
+		break;
+
+	case KDBUS_CMD_FREE: {
+		u64 off;
+
+		/* free the memory used in the receiver's pool */
+		if (!KDBUS_IS_ALIGNED8((uintptr_t)buf)) {
+			ret = -EFAULT;
+			break;
+		}
+
+		if (copy_from_user(&off, buf, sizeof(__u64))) {
+			ret = -EFAULT;
+			break;
+		}
+
+		mutex_lock(&conn->lock);
+		ret = kdbus_pool_free_range(conn->pool, off);
+		mutex_unlock(&conn->lock);
+		break;
+	}
+
+	case KDBUS_CMD_MSG_DROP:
+		ret = kdbus_conn_drop_msg(conn);
+		break;
+
+	case KDBUS_CMD_MSG_SRC:
+		ret = kdbus_conn_src_msg(conn, buf);
+		break;
+
+	case KDBUS_CMD_MEMFD_NEW: {
+		int fd;
+		int __user *addr = buf;
+
+		ret = kdbus_memfd_new(&fd);
+		if (ret < 0)
+			break;
+
+		if (put_user(fd, addr))
+			ret = -EFAULT;
+		break;
+	}
+
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	return ret;
+}
+
+static long kdbus_handle_ioctl(struct file *file, unsigned int cmd,
+			       unsigned long arg)
+{
+	struct kdbus_handle *handle = file->private_data;
+	void __user *argp = (void __user *)arg;
+
+	switch (handle->type) {
+	case KDBUS_HANDLE_CONTROL:
+		return kdbus_handle_ioctl_control(file, cmd, argp);
+
+	case KDBUS_HANDLE_EP:
+		return kdbus_handle_ioctl_ep(file, cmd, argp);
+
+	case KDBUS_HANDLE_EP_CONNECTED:
+		return kdbus_handle_ioctl_ep_connected(file, cmd, argp);
+
+	default:
+		return -EBADFD;
+	}
+}
+
+static unsigned int kdbus_handle_poll(struct file *file,
+				      struct poll_table_struct *wait)
+{
+	struct kdbus_handle *handle = file->private_data;
+	struct kdbus_conn *conn;
+	unsigned int mask = 0;
+	bool disconnected;
+
+	/* Only a connected endpoint can read/write data */
+	if (handle->type != KDBUS_HANDLE_EP_CONNECTED)
+		return POLLERR | POLLHUP;
+
+	conn = handle->conn;
+
+	poll_wait(file, &conn->ep->wait, wait);
+
+	mutex_lock(&conn->lock);
+
+	mutex_lock(&conn->ep->lock);
+	disconnected = conn->ep->disconnected;
+	mutex_unlock(&conn->ep->lock);
+
+	if (unlikely(disconnected))
+		mask |= POLLERR | POLLHUP;
+	else if (!list_empty(&conn->msg_list))
+		mask |= POLLIN | POLLRDNORM;
+
+	mutex_unlock(&conn->lock);
+
+	return mask;
+}
+
+static int kdbus_handle_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct kdbus_handle *handle = file->private_data;
+
+	if (handle->type != KDBUS_HANDLE_EP_CONNECTED)
+		return -EPERM;
+
+	if (handle->conn->flags & KDBUS_HELLO_ACTIVATOR)
+		return -EPERM;
+
+	return kdbus_pool_mmap(handle->conn->pool, vma);
+}
+
+const struct file_operations kdbus_device_ops = {
+	.owner =		THIS_MODULE,
+	.open =			kdbus_handle_open,
+	.release =		kdbus_handle_release,
+	.poll =			kdbus_handle_poll,
+	.llseek =		noop_llseek,
+	.unlocked_ioctl =	kdbus_handle_ioctl,
+	.mmap =			kdbus_handle_mmap,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl =		kdbus_handle_ioctl,
+#endif
+};
diff --git a/drivers/kdbus/handle.h b/drivers/kdbus/handle.h
new file mode 100644
index 0000000..0eb409e
--- /dev/null
+++ b/drivers/kdbus/handle.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_HANDLE_H
+#define __KDBUS_HANDLE_H
+
+extern const struct file_operations kdbus_device_ops;
+#endif
diff --git a/drivers/kdbus/internal.h b/drivers/kdbus/internal.h
new file mode 100644
index 0000000..8daffc7
--- /dev/null
+++ b/drivers/kdbus/internal.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_INTERNAL_H
+#define __KDBUS_INTERNAL_H
+
+#include "kdbus.h"
+
+/* maximum size of message header and items */
+#define KDBUS_MSG_MAX_SIZE		SZ_8K
+
+/* maximum number of message items */
+#define KDBUS_MSG_MAX_ITEMS		128
+
+/* maximum number of passed file descriptors */
+#define KDBUS_MSG_MAX_FDS		256
+
+/* maximum message payload size */
+#define KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE	SZ_2M
+
+/* maximum length of well-known bus name */
+#define KDBUS_NAME_MAX_LEN		255
+
+/* maximum length of bus, ns, ep name */
+#define KDBUS_MAKE_MAX_LEN		63
+
+/* maximum size of make data */
+#define KDBUS_MAKE_MAX_SIZE		SZ_32K
+
+/* maximum size of hello data */
+#define KDBUS_HELLO_MAX_SIZE		SZ_32K
+
+/* maximum size of match data */
+#define KDBUS_MATCH_MAX_SIZE		SZ_32K
+
+/* maximum size of policy data */
+#define KDBUS_POLICY_MAX_SIZE		SZ_32K
+
+/* maximum number of queued messages per connection */
+#define KDBUS_CONN_MAX_MSGS		64
+
+/* maximum number of well-known names */
+#define KDBUS_CONN_MAX_NAMES		64
+
+/* maximum number of queud requests waiting ot a reply */
+#define KDBUS_CONN_MAX_REQUESTS_PENDING	64
+
+/* all exported addresses are 64 bit */
+#define KDBUS_PTR(addr) ((void __user *)(uintptr_t)(addr))
+
+/* all exported sizes are 64 bit and data aligned to 64 bit */
+#define KDBUS_ALIGN8(s) ALIGN((s), 8)
+#define KDBUS_IS_ALIGNED8(s) (IS_ALIGNED(s, 8))
+
+/* generic access and iterators over a stream of items */
+#define KDBUS_ITEM_HEADER_SIZE offsetof(struct kdbus_item, data)
+#define KDBUS_ITEM_SIZE(s) KDBUS_ALIGN8(KDBUS_ITEM_HEADER_SIZE + (s))
+#define KDBUS_ITEM_NEXT(item) \
+	(typeof(item))(((u8 *)item) + KDBUS_ALIGN8((item)->size))
+#define KDBUS_ITEM_FOREACH(item, head, first)				\
+	for (item = (head)->first;					\
+	     (u8 *)(item) < (u8 *)(head) + (head)->size;		\
+	     item = KDBUS_ITEM_NEXT(item))
+#define KDBUS_ITEM_VALID(item, head)					\
+	((item)->size > KDBUS_ITEM_HEADER_SIZE &&			\
+	 (u8 *)(item) + (item)->size <= (u8 *)(head) + (head)->size)
+#define KDBUS_ITEM_END(item, head)					\
+	((u8 *)item == ((u8 *)(head) + KDBUS_ALIGN8((head)->size)))
+
+/**
+ * kdbus_size_get_user - read the size variable from user memory
+ * @_s:			Size variable
+ * @_b:			Buffer to read from
+ * @_t:			Structure "size" is embedded in
+ *
+ * Returns: the result of copy_from_user()
+ */
+#define kdbus_size_get_user(_s, _b, _t)						\
+({										\
+	u64 __user *_sz = (void __user *)(_b) + offsetof(typeof(_t), size);	\
+	copy_from_user(_s, _sz, sizeof(__u64));					\
+})
+
+/**
+ * kdbus_offset_set_user - write the offset variable to user memory
+ * @_s:			Offset variable
+ * @_b:			Buffer to write to
+ * @_t:			Structure "offset" is embedded in
+ *
+ * Returns: the result of copy_to_user()
+ */
+#define kdbus_offset_set_user(_s, _b, _t)				\
+({									\
+	u64 __user *_sz = (void __user *)(_b) + offsetof(_t, offset);	\
+	copy_to_user(_sz, _s, sizeof(__u64));				\
+})
+
+/**
+ * kdbus_check_strlen - check length of a string at the end a structure
+ * @_p:			A pointer to a structure that has a size member and
+ * 			a variable string at its end
+ * @_s:			The name of the dynamically sized string member
+ *
+ * Returns: 1 if the string's end marker is withing the struct, or 0 otherwise.
+ */
+#define kdbus_check_strlen(_p, _s)					\
+({									\
+	size_t _max = (_p)->size - offsetof(typeof(*(_p)), _s);		\
+	_max == 0 || strnlen((_p)->_s, _max) != _max;			\
+})
+
+/**
+ * kdbus_validate_nul - check the validity of a sized string
+ * @s:			String
+ * @l:			Length of string
+ *
+ * Validate that a given string matches the given size, and the
+ * string is \0 terminated.
+ *
+ * Returns: true if the given string is valid
+ */
+static inline bool kdbus_validate_nul(const char *s, size_t l)
+{
+	return l > 0 && memchr(s, '\0', l) == s + l - 1;
+}
+
+/**
+ * kdbus_str_hash - calculate a hash
+ * @str:		String
+ *
+ * Returns: hash value
+ */
+static inline unsigned int kdbus_str_hash(const char *str)
+{
+	return full_name_hash(str, strlen(str));
+}
+#endif
diff --git a/drivers/kdbus/kdbus.h b/drivers/kdbus/kdbus.h
new file mode 100644
index 0000000..fbba085
--- /dev/null
+++ b/drivers/kdbus/kdbus.h
@@ -0,0 +1,824 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Linux Foundation
+ * Copyright (C) 2013 Lennart Poettering
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef _KDBUS_H_
+#define _KDBUS_H_
+
+#ifndef __KERNEL__
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <linux/types.h>
+#endif
+
+#define KDBUS_IOC_MAGIC			0x95
+#define KDBUS_SRC_ID_KERNEL		(0)
+#define KDBUS_DST_ID_NAME		(0)
+#define KDBUS_MATCH_ID_ANY		(~0ULL)
+#define KDBUS_DST_ID_BROADCAST		(~0ULL)
+
+/**
+ * struct kdbus_notify_id_change - name registry change message
+ * @id:			New or former owner of the name
+ * @flags:		flags field from KDBUS_HELLO_*
+ *
+ * Sent from kernel to userspace when the owner or activator of
+ * a well-known name changes.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_ID_ADD
+ *   KDBUS_ITEM_ID_REMOVE
+ */
+struct kdbus_notify_id_change {
+	__u64 id;
+	__u64 flags;
+};
+
+/**
+ * struct kdbus_notify_name_change - name registry change message
+ * @old:		ID and flags of former owner of a name
+ * @new:		ID and flags of new owner of a name
+ * @name:		Well-known name
+ *
+ * Sent from kernel to userspace when the owner or activator of
+ * a well-known name changes.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_NAME_ADD
+ *   KDBUS_ITEM_NAME_REMOVE
+ *   KDBUS_ITEM_NAME_CHANGE
+ */
+struct kdbus_notify_name_change {
+	struct kdbus_notify_id_change old;
+	struct kdbus_notify_id_change new;
+	char name[0];
+};
+
+/**
+ * struct kdbus_creds - process credentials
+ * @uid:		User ID
+ * @gid:		Group ID
+ * @pid:		Process ID
+ * @tid:		Thread ID
+ * @starttime:		Starttime of the process
+ *
+ * The starttime of the process PID. This is useful to detect PID overruns
+ * from the client side. i.e. if you use the PID to look something up in
+ * /proc/$PID/ you can afterwards check the starttime field of it, to ensure
+ * you didn't run into a PID overrun.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_CREDS
+ */
+struct kdbus_creds {
+	__u64 uid;
+	__u64 gid;
+	__u64 pid;
+	__u64 tid;
+	__u64 starttime;
+};
+
+/**
+ * struct kdbus_audit - audit information
+ * @sessionid:		The audit session ID
+ * @loginuid:		The audit login uid
+ *
+ * Attached to:
+ *   KDBUS_ITEM_AUDIT
+ */
+struct kdbus_audit {
+	__u64 sessionid;
+	__u64 loginuid;
+};
+
+/**
+ * struct kdbus_timestamp
+ * @monotonic_ns:	Monotonic timestamp, in nanoseconds
+ * @realtime_ns:	Realtime timestamp, in nanoseconds
+ *
+ * Attached to:
+ *   KDBUS_ITEM_TIMESTAMP
+ */
+struct kdbus_timestamp {
+	__u64 monotonic_ns;
+	__u64 realtime_ns;
+};
+
+/**
+ * struct kdbus_vec - I/O vector for kdbus payload items
+ * @size:		The size of the vector
+ * @address:		Memory address for memory addresses
+ * @offset:		Offset in the in-message payload memory,
+ *			relative to the message head
+ *
+ * Attached to:
+ *   KDBUS_ITEM_PAYLOAD_VEC
+ */
+struct kdbus_vec {
+	__u64 size;
+	union {
+		__u64 address;
+		__u64 offset;
+	};
+};
+
+/**
+ * struct kdbus_memfd - a kdbus memfd
+ * @size:		The memfd's size
+ * @fd:			The file descriptor number
+ * @__pad:		Padding to make the struct aligned
+ *
+ * Attached to:
+ *   KDBUS_ITEM_PAYLOAD_MEMFD
+ */
+struct kdbus_memfd {
+	__u64 size;
+	int fd;
+	__u32 __pad;
+};
+
+/**
+ * struct kdbus_name - a registered well-known name with its flags
+ * @flags:		flags from KDBUS_NAME_*
+ * @name:		well-known name
+ *
+ * Attached to:
+ *   KDBUS_ITEM_NAME
+ */
+struct kdbus_name {
+	__u64 flags;
+	char name[0];
+};
+
+/**
+ * struct kdbus_policy_access - policy access item
+ * @type:		One of KDBUS_POLICY_ACCESS_* types
+ * @bits:		Access to grant. One of KDBUS_POLICY_*
+ * @id:			For KDBUS_POLICY_ACCESS_USER, the uid
+ *			For KDBUS_POLICY_ACCESS_GROUP, the gid
+ *
+ * Embedded in:
+ *   struct kdbus_policy
+ */
+struct kdbus_policy_access {
+	__u64 type;	/* USER, GROUP, WORLD */
+	__u64 bits;	/* RECV, SEND, OWN */
+	__u64 id;	/* uid, gid, 0 */
+};
+
+/**
+ * struct kdbus_policy - a policy item
+ * @access:		Policy access details
+ * @name:		Well-known name to grant access to
+ *
+ * Attached to:
+ *   KDBUS_POLICY_ACCESS
+ *   KDBUS_ITEM_POLICY_NAME
+ */
+struct kdbus_policy {
+	union {
+		struct kdbus_policy_access access;
+		char name[0];
+	};
+};
+
+/**
+ * enum kdbus_item_type - item types to chain data in a list
+ * @_KDBUS_ITEM_NULL:		Uninitialized/invalid
+ * @_KDBUS_ITEM_USER_BASE:	Start of user items
+ * @KDBUS_ITEM_PAYLOAD_VEC:	Vector to data
+ * @KDBUS_ITEM_PAYLOAD_OFF:	Data at returned offset to message head
+ * @KDBUS_ITEM_PAYLOAD_MEMFD:	Data as sealed memfd
+ * @KDBUS_ITEM_FDS:		Attached file descriptors
+ * @KDBUS_ITEM_BLOOM:		For broadcasts, carries bloom filter
+ * @KDBUS_ITEM_BLOOM_SIZE:	Desired bloom size, used by KDBUS_CMD_BUS_MAKE
+ * @KDBUS_ITEM_DST_NAME:	Destination's well-known name
+ * @KDBUS_ITEM_MAKE_NAME:	Name of namespace, bus, endpoint
+ * @_KDBUS_ITEM_POLICY_BASE:	Start of policy items
+ * @KDBUS_ITEM_POLICY_NAME:	Policy in struct kdbus_policy
+ * @KDBUS_ITEM_POLICY_ACCESS:	Policy in struct kdbus_policy
+ * @_KDBUS_ITEM_ATTACH_BASE:	Start of metadata attach items
+ * @KDBUS_ITEM_NAME:		Well-know name with flags
+ * @KDBUS_ITEM_ID:		Connection ID
+ * @KDBUS_ITEM_TIMESTAMP:	Timestamp
+ * @KDBUS_ITEM_CREDS:		Process credential
+ * @KDBUS_ITEM_PID_COMM:	Process ID "comm" identifier
+ * @KDBUS_ITEM_TID_COMM:	Thread ID "comm" identifier
+ * @KDBUS_ITEM_EXE:		The path of the executable
+ * @KDBUS_ITEM_CMDLINE:		The process command line
+ * @KDBUS_ITEM_CGROUP:		The croup membership
+ * @KDBUS_ITEM_CAPS:		The process capabilities
+ * @KDBUS_ITEM_SECLABEL:	The security label
+ * @KDBUS_ITEM_AUDIT:		The audit IDs
+ * @_KDBUS_ITEM_KERNEL_BASE:	Start of kernel-generated message items
+ * @KDBUS_ITEM_NAME_ADD:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_NAME_REMOVE:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_NAME_CHANGE:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_ID_ADD:		Notify in struct kdbus_notify_id_change
+ * @KDBUS_ITEM_ID_REMOVE:	Notify in struct kdbus_notify_id_change
+ * @KDBUS_ITEM_REPLY_TIMEOUT:	Timeout has been reached
+ * @KDBUS_ITEM_REPLY_DEAD:	Destination died
+ */
+enum kdbus_item_type {
+	_KDBUS_ITEM_NULL,
+	_KDBUS_ITEM_USER_BASE,
+	KDBUS_ITEM_PAYLOAD_VEC	= _KDBUS_ITEM_USER_BASE,
+	KDBUS_ITEM_PAYLOAD_OFF,
+	KDBUS_ITEM_PAYLOAD_MEMFD,
+	KDBUS_ITEM_FDS,
+	KDBUS_ITEM_BLOOM,
+	KDBUS_ITEM_BLOOM_SIZE,
+	KDBUS_ITEM_DST_NAME,
+	KDBUS_ITEM_MAKE_NAME,
+
+	_KDBUS_ITEM_POLICY_BASE	= 0x400,
+	KDBUS_ITEM_POLICY_NAME = _KDBUS_ITEM_POLICY_BASE,
+	KDBUS_ITEM_POLICY_ACCESS,
+
+	_KDBUS_ITEM_ATTACH_BASE	= 0x600,
+	KDBUS_ITEM_NAME		= _KDBUS_ITEM_ATTACH_BASE,
+	KDBUS_ITEM_ID,
+	KDBUS_ITEM_TIMESTAMP,
+	KDBUS_ITEM_CREDS,
+	KDBUS_ITEM_PID_COMM,
+	KDBUS_ITEM_TID_COMM,
+	KDBUS_ITEM_EXE,
+	KDBUS_ITEM_CMDLINE,
+	KDBUS_ITEM_CGROUP,
+	KDBUS_ITEM_CAPS,
+	KDBUS_ITEM_SECLABEL,
+	KDBUS_ITEM_AUDIT,
+
+	_KDBUS_ITEM_KERNEL_BASE	= 0x800,
+	KDBUS_ITEM_NAME_ADD	= _KDBUS_ITEM_KERNEL_BASE,
+	KDBUS_ITEM_NAME_REMOVE,
+	KDBUS_ITEM_NAME_CHANGE,
+	KDBUS_ITEM_ID_ADD,
+	KDBUS_ITEM_ID_REMOVE,
+	KDBUS_ITEM_REPLY_TIMEOUT,
+	KDBUS_ITEM_REPLY_DEAD,
+};
+
+/**
+ * struct kdbus_item - chain of data blocks
+ * @size:		Overall data record size
+ * @type:		Kdbus_item type of data
+ * @data:		Generic bytes
+ * @data32:		Generic 32 bit array
+ * @data64:		Generic 64 bit array
+ * @str:		Generic string
+ * @id:			Connection ID
+ * @vec:		KDBUS_ITEM_PAYLOAD_VEC
+ * @creds:		KDBUS_ITEM_CREDS
+ * @audit:		KDBUS_ITEM_AUDIT
+ * @timestamp:		KDBUS_ITEM_TIMESTAMP
+ * @name:		KDBUS_ITEM_NAME
+ * @memfd:		KDBUS_ITEM_PAYLOAD_MEMFD
+ * @name_change:	KDBUS_ITEM_NAME_ADD
+ *			KDBUS_ITEM_NAME_REMOVE
+ *			KDBUS_ITEM_NAME_CHANGE
+ * @id_change:		KDBUS_ITEM_ID_ADD
+ *			KDBUS_ITEM_ID_REMOVE
+ * @policy:		KDBUS_ITEM_POLICY_NAME
+ *			KDBUS_ITEM_POLICY_ACCESS
+ */
+struct kdbus_item {
+	__u64 size;
+	__u64 type;
+	union {
+		__u8 data[0];
+		__u32 data32[0];
+		__u64 data64[0];
+		char str[0];
+
+		__u64 id;
+		struct kdbus_vec vec;
+		struct kdbus_creds creds;
+		struct kdbus_audit audit;
+		struct kdbus_timestamp timestamp;
+		struct kdbus_name name;
+		struct kdbus_memfd memfd;
+		int fds[0];
+		struct kdbus_notify_name_change name_change;
+		struct kdbus_notify_id_change id_change;
+		struct kdbus_policy policy;
+	};
+};
+
+/**
+ * enum kdbus_msg_flags - type of message
+ * @KDBUS_MSG_FLAGS_EXPECT_REPLY:	Expect a reply message, used for
+ *					method calls. The userspace-supplied
+ *					cookie identifies the message and the
+ *					respective reply carries the cookie
+ *					in cookie_reply
+ * @KDBUS_MSG_FLAGS_NO_AUTO_START:	Do not start a service, if the addressed
+ *					name is not currently active
+ */
+enum kdbus_msg_flags {
+	KDBUS_MSG_FLAGS_EXPECT_REPLY	= 1 << 0,
+	KDBUS_MSG_FLAGS_NO_AUTO_START	= 1 << 1,
+};
+
+/**
+ * enum kdbus_payload_type - type of payload carried by message
+ * @KDBUS_PAYLOAD_KERNEL:	Kernel-generated simple message
+ * @KDBUS_PAYLOAD_DBUS:		D-Bus marshalling "DBusDBus"
+ */
+enum kdbus_payload_type {
+	KDBUS_PAYLOAD_KERNEL,
+	KDBUS_PAYLOAD_DBUS	= 0x4442757344427573ULL,
+};
+
+/**
+ * struct kdbus_msg - the representation of a kdbus message
+ * @size:		Total size of the message
+ * @flags:		Message flags (KDBUS_MSG_FLAGS_*)
+ * @dst_id:		64-bit ID of the destination connection
+ * @src_id:		64-bit ID of the source connection
+ * @payload_type:	Payload type (KDBUS_PAYLOAD_*)
+ * @cookie:		Userspace-supplied cookie, for the connection
+ *			to identify its messages
+ * @cookie_reply:	A reply to the requesting message with the same
+ *			cookie. The requesting connection can match its
+ *			request and the reply with this value
+ * @timeout_ns:		The time to wait for a message reply from the peer.
+ *			If there is no reply, a kernel-generated message
+ *			with an attached KDBUS_ITEM_REPLY_TIMEOUT item
+ *			is sent to @src_id.
+ * @items:		A list of kdbus_items containing the message payload
+ */
+struct kdbus_msg {
+	__u64 size;
+	__u64 flags;
+	__u64 dst_id;
+	__u64 src_id;
+	__u64 payload_type;
+	__u64 cookie;
+	union {
+		__u64 cookie_reply;
+		__u64 timeout_ns;
+	};
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_policy_access_type - permissions of a policy record
+ * @_KDBUS_POLICY_ACCESS_NULL:	Uninitialized/invalid
+ * @KDBUS_POLICY_ACCESS_USER:	Grant access to a uid
+ * @KDBUS_POLICY_ACCESS_GROUP:	Grant access to gid
+ * @KDBUS_POLICY_ACCESS_WORLD:	World-accessible
+ */
+enum kdbus_policy_access_type {
+	_KDBUS_POLICY_ACCESS_NULL,
+	KDBUS_POLICY_ACCESS_USER,
+	KDBUS_POLICY_ACCESS_GROUP,
+	KDBUS_POLICY_ACCESS_WORLD,
+};
+
+/**
+ * enum kdbus_policy_access_flags - mode flags
+ * @KDBUS_POLICY_RECV:		Allow receive
+ * @KDBUS_POLICY_SEND:		Allow send
+ * @KDBUS_POLICY_OWN:		Allow to own a well-known name
+ */
+enum kdbus_policy_type {
+	KDBUS_POLICY_RECV		= 1 <<  2,
+	KDBUS_POLICY_SEND		= 1 <<  1,
+	KDBUS_POLICY_OWN		= 1 <<  0,
+};
+
+/**
+ * struct kdbus_cmd_policy - a series of policies to upload
+ * @size:		The total size of the structure
+ * @policies:		The policies to upload
+ *
+ * A KDBUS_POLICY_NAME must always preceeds a KDBUS_POLICY_ACCESS entry.
+ * A new KDBUS_POLICY_NAME can be added after KDBUS_POLICY_ACCESS for
+ * chaining multiple policies together.
+ */
+struct kdbus_cmd_policy {
+	__u64 size;
+	struct kdbus_item policies[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_hello_flags - flags for struct kdbus_cmd_hello
+ * @KDBUS_HELLO_ACCEPT_FD:	The connection allows the receiving of
+ *				any passed file descriptors
+ * @KDBUS_HELLO_ACTIVATOR:	Special-purpose connection which registers
+ *				a well-know name for a process to be started
+ *				when traffic arrives
+ * @KDBUS_HELLO_MONITOR:	Special-purpose connection to monitor
+ *				bus traffic
+ */
+enum kdbus_hello_flags {
+	KDBUS_HELLO_ACCEPT_FD		=  1 <<  0,
+	KDBUS_HELLO_ACTIVATOR		=  1 <<  1,
+	KDBUS_HELLO_MONITOR		=  1 <<  2,
+};
+
+/**
+ * enum kdbus_attach_flags - flags for metadata attachments
+ * @KDBUS_ATTACH_TIMESTAMP:	Timestamp
+ * @KDBUS_ATTACH_CREDS:		Credentials
+ * @KDBUS_ATTACH_NAMES:		Well-known names
+ * @KDBUS_ATTACH_COMM:		The "comm" process identifier
+ * @KDBUS_ATTACH_EXE:		The path of the executable
+ * @KDBUS_ATTACH_CMDLINE:	The process command line
+ * @KDBUS_ATTACH_CGROUP:	The croup membership
+ * @KDBUS_ATTACH_CAPS:		The process capabilities
+ * @KDBUS_ATTACH_SECLABEL:	The security label
+ * @KDBUS_ATTACH_AUDIT:		The audit IDs
+ */
+enum kdbus_attach_flags {
+	KDBUS_ATTACH_TIMESTAMP		=  1 <<  0,
+	KDBUS_ATTACH_CREDS		=  1 <<  1,
+	KDBUS_ATTACH_NAMES		=  1 <<  2,
+	KDBUS_ATTACH_COMM		=  1 <<  3,
+	KDBUS_ATTACH_EXE		=  1 <<  4,
+	KDBUS_ATTACH_CMDLINE		=  1 <<  5,
+	KDBUS_ATTACH_CGROUP		=  1 <<  6,
+	KDBUS_ATTACH_CAPS		=  1 <<  7,
+	KDBUS_ATTACH_SECLABEL		=  1 <<  8,
+	KDBUS_ATTACH_AUDIT		=  1 <<  9,
+};
+
+/**
+ * struct kdbus_cmd_hello - struct to say hello to kdbus
+ * @size:		The total size of the structure
+ * @conn_flags:		Connection flags (KDBUS_HELLO_*). The kernel will
+ *			return its capabilities in that field.
+ * @attach_flags:	Mask of metadata to attach to each message sent
+ *			(KDBUS_ATTACH_*)
+ * @bus_flags:		The flags field copied verbatim from the original
+ *			KDBUS_CMD_BUS_MAKE ioctl. It's intended to be useful
+ *			to do negotiation of features of the payload that is
+ *			transferred (kernel → userspace)
+ * @id:			The ID of this connection (kernel → userspace)
+ * @bloom_size:		The bloom filter size chosen by the owner
+ *			(kernel → userspace)
+ * @pool_size:		Size of the connection's buffer where the received
+ *			messages are placed
+ * @id128:		Unique 128-bit ID of the bus (kernel → userspace)
+ * @items:		A list of items
+ *
+ * This struct is used with the KDBUS_CMD_HELLO ioctl. See the ioctl
+ * documentation for more information.
+ */
+struct kdbus_cmd_hello {
+	__u64 size;
+	__u64 conn_flags;
+	__u64 attach_flags;
+	__u64 bus_flags;
+	__u64 id;
+	__u64 bloom_size;
+	__u64 pool_size;
+	__u8 id128[16];
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/* Flags for KDBUS_CMD_{BUS,EP,NS}_MAKE */
+enum kdbus_make_flags {
+	KDBUS_MAKE_ACCESS_GROUP		= 1 <<  0,
+	KDBUS_MAKE_ACCESS_WORLD		= 1 <<  1,
+	KDBUS_MAKE_POLICY_OPEN		= 1 <<  2,
+};
+
+/**
+ * struct kdbus_cmd_make - struct to make a bus, an endpoint or a namespace
+ * @size:		The total size of the struct
+ * @flags:		Properties for the bus/ep/ns to create
+ * @items:		Items describing details
+ *
+ * This structure is used with the KDBUS_CMD_BUS_MAKE, KDBUS_CMD_EP_MAKE and
+ * KDBUS_CMD_NS_MAKE ioctls.
+ */
+struct kdbus_cmd_make {
+	__u64 size;
+	__u64 flags;
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_name_flags - properties of a well-known name
+ * @KDBUS_NAME_REPLACE_EXISTING:	Try to replace name of other connections
+ * @KDBUS_NAME_ALLOW_REPLACEMENT:	Allow the replacement of the name
+ * @KDBUS_NAME_QUEUE:			Name should be queued if busy
+ * @KDBUS_NAME_IN_QUEUE:		Name is queued
+ * @KDBUS_NAME_ACTIVATOR:		Name is owned by a activator connection
+ */
+enum kdbus_name_flags {
+	KDBUS_NAME_REPLACE_EXISTING	= 1 <<  0,
+	KDBUS_NAME_ALLOW_REPLACEMENT	= 1 <<  1,
+	KDBUS_NAME_QUEUE		= 1 <<  2,
+	KDBUS_NAME_IN_QUEUE		= 1 <<  3,
+	KDBUS_NAME_ACTIVATOR		= 1 <<  4,
+};
+
+/**
+ * struct kdbus_cmd_name - struct to describe a well-known name
+ * @size:		The total size of the struct
+ * @flags:		Flags for a name entry (KDBUS_NAME_*)
+ * @owner_id:		The current owner of the name. For requests,
+ *			privileged users may set this field to
+ *			(de)register names on behalf of other connections.
+ * @conn_flags:		The flags of the owning connection (KDBUS_HELLO_*)
+ * @name:		The well-known name
+ *
+ * This structure is used with the KDBUS_CMD_NAME_ACQUIRE ioctl.
+ */
+struct kdbus_cmd_name {
+	__u64 size;
+	__u64 flags;
+	__u64 owner_id;
+	__u64 conn_flags;
+	char name[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_name_list_flags - what to include into the returned list
+ * @KDBUS_NAME_LIST_UNIQUE:	All active connections
+ * @KDBUS_NAME_LIST_NAMES:	All known well-known names
+ * @KDBUS_NAME_LIST_ACTIVATORS:	All activator connections
+ * @KDBUS_NAME_LIST_QUEUED:	All queued-up names
+ */
+enum kdbus_name_list_flags {
+	KDBUS_NAME_LIST_UNIQUE		= 1 <<  0,
+	KDBUS_NAME_LIST_NAMES		= 1 <<  1,
+	KDBUS_NAME_LIST_ACTIVATORS	= 1 <<  2,
+	KDBUS_NAME_LIST_QUEUED		= 1 <<  3,
+};
+
+/**
+ * struct kdbus_cmd_name_list - request a list of name entries
+ * @flags:		Flags for the query (KDBUS_NAME_LIST_*)
+ * @offset:		The returned offset in the caller's pool buffer.
+ *			The user must use KDBUS_CMD_FREE to free the
+ *			allocated memory.
+ *
+ * This structure is used with the KDBUS_CMD_NAME_LIST ioctl.
+ */
+struct kdbus_cmd_name_list {
+	__u64 flags;
+	__u64 offset;
+} __attribute__((aligned(8)));
+
+/**
+ * struct kdbus_name_list - information returned by KDBUS_CMD_NAME_LIST
+ * @size:		The total size of the structure
+ * @names:		A list of names
+ *
+ * Note that the user is responsible for freeing the allocated memory with
+ * the KDBUS_CMD_FREE ioctl.
+ */
+struct kdbus_name_list {
+	__u64 size;
+	struct kdbus_cmd_name names[0];
+};
+
+/**
+ * struct kdbus_cmd_conn_info - struct used for KDBUS_CMD_CONN_INFO ioctl
+ * @size:		The total size of the struct
+ * @flags:		KDBUS_ATTACH_* flags
+ * @id:			The 64-bit ID of the connection. If set to zero, passing
+ *			@name is required. kdbus will look up the name to
+ *			determine the ID in this case.
+ * @offset:		Returned offset in the caller's pool buffer where the
+ *			kdbus_conn_info struct result is stored. The user must
+ *			use KDBUS_CMD_FREE to free the allocated memory.
+ * @name:		The optional well-known name to look up. Only needed in
+ *			case @id is zero.
+ *
+ * On success, the KDBUS_CMD_CONN_INFO ioctl will return 0 and @offset will
+ * tell the user the offset in the connection pool buffer at which to find the
+ * result in a struct kdbus_conn_info.
+ */
+struct kdbus_cmd_conn_info {
+	__u64 size;
+	__u64 flags;
+	__u64 id;
+	__u64 offset;
+	char name[0];
+} __attribute__((aligned(8)));
+
+/**
+ * struct kdbus_conn_info - information returned by KDBUS_CMD_CONN_INFO
+ * @size:		The total size of the struct
+ * @id:			The connection's 64-bit ID
+ * @flags:		The connection's flags
+ * @items:		A list of struct kdbus_item
+ *
+ * Note that the user is responsible for freeing the allocated memory with
+ * the KDBUS_CMD_FREE ioctl.
+ */
+struct kdbus_conn_info {
+	__u64 size;
+	__u64 id;
+	__u64 flags;
+	struct kdbus_item items[0];
+};
+
+/**
+ * struct kdbus_cmd_match - struct to add or remove matches
+ * @size:		The total size of the struct
+ * @owner_id:		Privileged users may (de)register matches on behalf
+ *			of other peers
+ * @cookie:		Userspace supplied cookie. When removing, the cookie
+ *			identifies the match to remove
+ * @items:		A list of items for additional information
+ *
+ * This structure is used with the KDBUS_CMD_ADD_MATCH and
+ * KDBUS_CMD_REMOVE_MATCH ioctl.
+ */
+struct kdbus_cmd_match {
+	__u64 size;
+	__u64 owner_id;
+	__u64 cookie;
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_ioctl_type - Ioctl API
+ * @KDBUS_CMD_BUS_MAKE:		After opening the "control" device node, this
+ *				command creates a new bus with the specified
+ *				name. The bus is immediately shut down and
+ *				cleaned up when the opened "control" device node
+ *				is closed.
+ * @KDBUS_CMD_NS_MAKE:		Similar to KDBUS_CMD_BUS_MAKE, but it creates a
+ *				new kdbus namespace.
+ * @KDBUS_CMD_EP_MAKE:		Creates a new named special endpoint to talk to
+ *				the bus. Such endpoints usually carry a more
+ *				restrictive policy and grant restricted access
+ *				to specific applications.
+ * @KDBUS_CMD_HELLO:		By opening the bus device node a connection is
+ *				created. After a HELLO the opened connection
+ *				becomes an active peer on the bus.
+ * @KDBUS_CMD_BYEBYE:		Disconnect a connection. If the connection's
+ *				message list is empty, the calls succeeds, and
+ *				the handle is rendered unusable. Otherwise,
+ *				-EAGAIN is returned without any further side-
+ *				effects.
+ * @KDBUS_CMD_MSG_SEND:		Send a message and pass data from userspace to
+ *				the kernel.
+ * @KDBUS_CMD_MSG_RECV:		Receive a message from the kernel which is
+ *				placed in the receiver's pool.
+ * @KDBUS_CMD_FREE:		Release the allocated memory in the receiver's
+ *				pool.
+ * @KDBUS_CMD_DROP:		Drop and free the next queued message and all
+ *				its ressources without actually receiveing it.
+ * @KDBUS_CMD_SRC:		Return the sender's connection ID of the next
+ *				queued message.
+ * @KDBUS_CMD_NAME_ACQUIRE:	Request a well-known bus name to associate with
+ *				the connection. Well-known names are used to
+ *				address a peer on the bus.
+ * @KDBUS_CMD_NAME_RELEASE:	Release a well-known name the connection
+ *				currently owns.
+ * @KDBUS_CMD_NAME_LIST:	Retrieve the list of all currently registered
+ *				well-known and unique names.
+ * @KDBUS_CMD_CONN_INFO:	Retrieve credentials and properties of the
+ *				initial creator of the connection. The data was
+ *				stored at registration time and does not
+ *				necessarily represent the connected process or
+ *				the actual state of the process.
+ * @KDBUS_CMD_MATCH_ADD:	Install a match which broadcast messages should
+ *				be delivered to the connection.
+ * @KDBUS_CMD_MATCH_REMOVE:	Remove a current match for broadcast messages.
+ * @KDBUS_CMD_EP_POLICY_SET:	Set the policy of an endpoint. It is used to
+ *				restrict the access for endpoints created with
+ *				KDBUS_CMD_EP_MAKE.
+ * @KDBUS_CMD_MEMFD_NEW:	Return a new file descriptor which provides an
+ *				anonymous shared memory file and which can be
+ *				used to pass around larger chunks of data.
+ *				Kdbus memfd files can be sealed, which allows
+ *				the receiver to trust the data it has received.
+ *				Kdbus memfd files expose only very limited
+ *				operations, they can be mmap()ed, seek()ed,
+ *				(p)read(v)() and (p)write(v)(); most other
+ *				common file operations are not implemented.
+ *				Special caution needs to be taken with
+ *				read(v)()/write(v)() on a shared file; the
+ *				underlying file position is always shared
+ *				between all users of the file and race against
+ *				each other, pread(v)()/pwrite(v)() avoid these
+ *				issues.
+ * @KDBUS_CMD_MEMFD_SIZE_GET:	Return the size of the underlying file, which
+ *				changes with write().
+ * @KDBUS_CMD_MEMFD_SIZE_SET:	Truncate the underlying file to the specified
+ *				size.
+ * @KDBUS_CMD_MEMFD_SEAL_GET:	Return the state of the file sealing.
+ * @KDBUS_CMD_MEMFD_SEAL_SET:	Seal or break a seal of the file. Only files
+ *				which are not shared with other processes and
+ *				which are currently not mapped can be sealed.
+ *				The current process needs to be the one and
+ *				single owner of the file, the sealing cannot
+ *				be changed as long as the file is shared.
+ */
+enum kdbus_ioctl_type {
+	KDBUS_CMD_BUS_MAKE =		_IOW (KDBUS_IOC_MAGIC, 0x00, struct kdbus_cmd_make),
+	KDBUS_CMD_NS_MAKE =		_IOR (KDBUS_IOC_MAGIC, 0x10, struct kdbus_cmd_make),
+	KDBUS_CMD_EP_MAKE =		_IOW (KDBUS_IOC_MAGIC, 0x20, struct kdbus_cmd_make),
+
+	KDBUS_CMD_HELLO =		_IOWR(KDBUS_IOC_MAGIC, 0x30, struct kdbus_cmd_hello),
+	KDBUS_CMD_BYEBYE =		_IO  (KDBUS_IOC_MAGIC, 0x31),
+
+	KDBUS_CMD_MSG_SEND =		_IOW (KDBUS_IOC_MAGIC, 0x40, struct kdbus_msg),
+	KDBUS_CMD_MSG_RECV =		_IOR (KDBUS_IOC_MAGIC, 0x41, __u64 *),
+	KDBUS_CMD_FREE =		_IOW (KDBUS_IOC_MAGIC, 0x42, __u64 *),
+	KDBUS_CMD_MSG_DROP =		_IO  (KDBUS_IOC_MAGIC, 0x43),
+	KDBUS_CMD_MSG_SRC =		_IOR (KDBUS_IOC_MAGIC, 0x44, __u64 *),
+
+	KDBUS_CMD_NAME_ACQUIRE =	_IOWR(KDBUS_IOC_MAGIC, 0x50, struct kdbus_cmd_name),
+	KDBUS_CMD_NAME_RELEASE =	_IOW (KDBUS_IOC_MAGIC, 0x51, struct kdbus_cmd_name),
+	KDBUS_CMD_NAME_LIST =		_IOWR(KDBUS_IOC_MAGIC, 0x52, struct kdbus_cmd_name_list),
+
+	KDBUS_CMD_CONN_INFO =		_IOWR(KDBUS_IOC_MAGIC, 0x60, struct kdbus_cmd_conn_info),
+
+	KDBUS_CMD_MATCH_ADD =		_IOW (KDBUS_IOC_MAGIC, 0x70, struct kdbus_cmd_match),
+	KDBUS_CMD_MATCH_REMOVE =	_IOW (KDBUS_IOC_MAGIC, 0x71, struct kdbus_cmd_match),
+
+	KDBUS_CMD_EP_POLICY_SET =	_IOW (KDBUS_IOC_MAGIC, 0x80, struct kdbus_cmd_policy),
+
+	KDBUS_CMD_MEMFD_NEW =		_IOR (KDBUS_IOC_MAGIC, 0x90, int *),
+	KDBUS_CMD_MEMFD_SIZE_GET =	_IOR (KDBUS_IOC_MAGIC, 0x91, __u64 *),
+	KDBUS_CMD_MEMFD_SIZE_SET =	_IOW (KDBUS_IOC_MAGIC, 0x92, __u64 *),
+	KDBUS_CMD_MEMFD_SEAL_GET =	_IOR (KDBUS_IOC_MAGIC, 0x93, int *),
+	KDBUS_CMD_MEMFD_SEAL_SET =	_IO  (KDBUS_IOC_MAGIC, 0x94),
+};
+
+/*
+ * errno - api error codes
+ * @E2BIG:		A message contains too many records or items.
+ * @EADDRINUSE:		A well-known bus name is already taken by another
+ *			connection.
+ * @EADDRNOTAVAIL:	A message flagged not to activate a service, addressed
+ *			a service which is not currently running.
+ * @EAGAIN:		No messages are queued at the moment.
+ * @EBADF:		File descriptors passed with the message are not valid.
+ * @EBADFD:		A bus connection is in a corrupted state.
+ * @EBADMSG:		Passed data contains a combination of conflicting or
+ *			inconsistent types.
+ * @EBUSY:		The user tried to say BYEBYE to a connection, but the
+ *			connection had a non-empty message list.
+ * @ECONNRESET:		A connection is shut down, no further operations are
+ *			possible.
+ * @ECOMM:		A peer does not accept the file descriptors addressed
+ *			to it.
+ * @EDESTADDRREQ:	The well-known bus name is required but missing.
+ * @EDOM:		The size of data does not match the expectations. Used
+ *			for the size of the bloom filter bit field.
+ * @EEXIST:		A requested namespace, bus or endpoint with the same
+ *			name already exists.  A specific data type, which is
+ *			only expected once, is provided multiple times.
+ * @EFAULT:		The supplied memory could not be accessed, or the data
+ *			is not properly aligned.
+ * @EINVAL:		The provided data does not match its type or other
+ *			expectations, like a string which is not NUL terminated,
+ *			or a string length that points behind the first
+ *			\0-byte in the string.
+ * @EMEDIUMTYPE:	A file descriptor which is not a kdbus memfd was
+ *			refused to send as KDBUS_MSG_PAYLOAD_MEMFD.
+ * @EMFILE:		Too many file descriptors have been supplied with a
+ *			message.
+ * @EMLINK:		Too many requests from this connection to other peers
+ *			are queued and waiting for a reply
+ * @EMSGSIZE:		The supplied data is larger than the allowed maximum
+ *			size.
+ * @ENAMETOOLONG:	The requested name is larger than the allowed maximum
+ *			size.
+ * @ENOBUFS:		There is no space left for the submitted data to fit
+ *			into the receiver's pool.
+ * @ENOENT:		The name to query information about is currently not on
+ *			the bus.
+ * @ENOMEM:		Out of memory.
+ * @ENOSYS:		The requested functionality is not available.
+ * @ENOTCONN:		The addressed peer is not an active connection.
+ * @ENOTSUPP:		The feature negotiation failed, a not supported feature
+ *			was requested, or an unknown item type was received.
+ * @ENOTTY:		An unknown ioctl command was received.
+ * @ENOTUNIQ:		A specific data type was addressed to a broadcast
+ *			address, but only direct addresses support this kind of
+ *			data.
+ * @ENXIO:		A unique address does not exist, or an offset in the
+ *			receiver's pool does not represent a queued message.
+ * @EPERM:		The policy prevented an operation. The requested
+ *			resource is owned by another entity.
+ * @ESHUTDOWN:		A namespace or endpoint is currently shutting down;
+ *			no further operations will be possible.
+ * @ESRCH:		A requested well-known bus name is not found.
+ * @ETXTBSY:		A kdbus memfd file cannot be sealed or the seal removed,
+ *			because it is shared with other processes or still
+ *			mmap()ed.
+ * @EXFULL:		The size limits in the pool are reached, no data of
+ *			the size tried to submit can be queued.
+ */
+#endif
diff --git a/drivers/kdbus/kdbus.txt b/drivers/kdbus/kdbus.txt
new file mode 100644
index 0000000..8a8e669
--- /dev/null
+++ b/drivers/kdbus/kdbus.txt
@@ -0,0 +1,333 @@
+D-Bus is a system for low-latency, low-overhead, easy to use interprocess
+communication (IPC).
+
+The focus of this document is an overview of the low-level, native kernel D-Bus
+transport called kdbus. Kdbus in the kernel acts similar to a device driver,
+all communication between processes take place over special device nodes in
+/dev/kdbus/.
+
+For the general D-Bus protocol specification, the payload format, the
+marshaling, the communication semantics, please refer to:
+  http://dbus.freedesktop.org/doc/dbus-specification.html
+
+For a kdbus specific userspace library implementation please refer to:
+  http://cgit.freedesktop.org/systemd/systemd/tree/src/systemd/sd-bus.h
+  http://cgit.freedesktop.org/systemd/systemd/tree/src/systemd/sd-memfd.h
+
+===============================================================================
+Terminology
+===============================================================================
+  Namespace:
+    A namespace is a named object containing a number of buses. A system
+    container which contains its own init system and users usually also
+    runs in its own kdbus namespace. The /dev/kdbus/ns/<container-name>/
+    directory shows up inside the namespace as /dev/kdbus/. Every namespace
+    offers a "control" device node to create new buses or namespaces.
+    Namespaces have no connection to each other, cannot see or talk to
+    each other. Only from the initial namespace, given the process has the
+    needed access rights, the device nodes inside of other namespaces
+    can be seen.
+
+  Bus:
+    A bus is a named object inside a namespace. Clients exchange messages
+    over a bus. Multiple buses themselves have no connection to each other,
+    messages are only exchanged on the same bus. The default entry point to a
+    bus, where clients establish the connection to, is the "bus" device node
+    /dev/kdbus/<bus name>/bus.
+    Common operating system setups create one "system bus" per system, and one
+    "user bus" for every logged-in user. Applications or services can create
+    their own private named buses if they want to.
+
+  Endpoint:
+    An endpoint provides the device node to talk to a bus. Every bus has
+    a default endpoint called "bus". A bus can offer additional endpoints
+    with custom names to provide a restricted access to the same bus. Custom
+    endpoints can carry additional policy which can be used to give sandboxed
+    processes only a locked-down, limited, filtered access to a bus.
+
+  Connection:
+    A connection to a bus is created by opening an endpoint device node of
+    a bus, and becoming an active client with the HELLO exchange. Every
+    connected client connection has a unique identifier on the bus, and can
+    address messages to every other connection on the same bus by using
+    the peer's connection id as the destination.
+
+  Well-known Names:
+    A connection can, in addition to its implicit unique connection id, request
+    the ownership of a textual well-known name. Well-known names are noted
+    in reverse-domain notation like com.example.service. Connections offering
+    a service on a bus are usually reached by its well-known name. The analogy
+    of connection id and well-known name is an IP address and a DNS name
+    associated with that address.
+
+===============================================================================
+Device Node Layout
+===============================================================================
+  /sys/bus/kdbus
+  `-- devices
+    |-- kdbus!0-system!bus -> ../../../devices/virtual/kdbus/kdbus!0-system!bus
+    |-- kdbus!2702-user!bus -> ../../../devices/virtual/kdbus/kdbus!2702-user!bus
+    |-- kdbus!2702-user!ep.app -> ../../../devices/virtual/kdbus/kdbus!2702-user!ep.app
+    `-- kdbus!control -> ../../../devices/kdbus!control
+
+  /dev/kdbus
+  |-- control
+  |-- 0-system
+  |   |-- bus
+  |   `-- ep.apache
+  |-- 1000-user
+  |   `-- bus
+  |-- 2702-user
+  |   |-- bus
+  |   `-- ep.app
+  `-- ns
+      |-- fedoracontainer
+      |   |-- control
+      |   |-- 0-system
+      |   |   `-- bus
+      |   `-- 1000-user
+      |       `-- bus
+      `-- mydebiancontainer
+          |-- control
+          `-- 0-system
+              `-- bus
+
+Note:
+  The device node subdirectory layout is arranged that a future version of
+  kdbus could be implemented as a filesystem with a separate instance mounted
+  for each namespace. For any future changes, this always needs to be kept
+  in mind. Also the dependency on udev's userspace hookups or sysfs attribute
+  use should be limited for the same reason.
+
+===============================================================================
+Data Structures
+===============================================================================
+  +-------------------------------------------------------------------------+
+  | Namespace (Init Namespace)                                              |
+  | /dev/kdbus/control                                                      |
+  | +---------------------------------------------------------------------+ |
+  | | Bus (System Bus)                                                    | |
+  | | ./0-system/control                                                  | |
+  | | +-------------------------------+ +-------------------------------+ | |
+  | | | Endpoint                      | | Endpoint                      | | |
+  | | | ./bus                         | | ./ep.sandbox                  | | |
+  | | | +------------+ +------------+ | | +------------+ +------------+ | | |
+  | | | | Connection | | Connection | | | | Connection | | Connection | | | |
+  | | | | :1.22      | | :1.25      | | | | :1.55      | | :1:81      | | | |
+  | | | +------------+ +------------+ | | +------------+ +------------+ | | |
+  | | +-------------------------------+ +-------------------------------+ | |
+  | +---------------------------------------------------------------------+ |
+  |                                                                         |
+  | +---------------------------------------------------------------------+ |
+  | | Bus (User Bus for UID 2702)                                         | |
+  | | /dev/kdbus/2702-user/                                               | |
+  | | +-------------------------------+ +-------------------------------+ | |
+  | | | Endpoint                      | | Endpoint                      | | |
+  | | | /dev/kdbus/2702-user/bus      | | /dev/kdbus/2702-user/ep.app   | | |
+  | | | +------------+ +------------+ | | +------------+ +------------+ | | |
+  | | | | Connection | | Connection | | | | Connection | | Connection | | | |
+  | | | | :1.22      | | :1.25      | | | | :1.55      | | :1:81      | | | |
+  | | | +------------+ +------------+ | | +------------+ +------------+ | | |
+  | | +-------------------------------+ +-------------------------------+ | |
+  | +---------------------------------------------------------------------+ |
+  +-------------------------------------------------------------------------+
+  | Namespace (Container; inside it, fedoracontainer/ becomes /dev/kdbus/)  |
+  | /dev/kdbus/ns/fedoracontainer/control                                   |
+  | +---------------------------------------------------------------------+ |
+  | | Bus                                                                 | |
+  | | ./0-system/                                                         | |
+  | | +---------------------------------+                                 | |
+  | | | Endpoint                        |                                 | |
+  | | | ./bus                           |                                 | |
+  | | | +-------------+ +-------------+ |                                 | |
+  | | | | Connection  | | Connection  | |                                 | |
+  | | | | :1.22       | | :1.25       | |                                 | |
+  | | | +-------------+ +-------------+ |                                 | |
+  | | +---------------------------------+                                 | |
+  | +---------------------------------------------------------------------+ |
+  |                                                                         |
+  | +---------------------------------------------------------------------+ |
+  | | Bus                                                                 | |
+  | | /dev/kdbus/2702-user/                                               | |
+  | | +---------------------------------+                                 | |
+  | | | Endpoint                        |                                 | |
+  | | | /dev/kdbus/2702-user/bus        |                                 | |
+  | | | +-------------+ +-------------+ |                                 | |
+  | | | | Connection  | | Connection  | |                                 | |
+  | | | | :1.22       | | :1.25       | |                                 | |
+  | | | +-------------+ +-------------+ |                                 | |
+  | | +---------------------------------+                                 | |
+  | +---------------------------------------------------------------------+ |
+  +-------------------------------------------------------------------------+
+
+===============================================================================
+Creation of new Namespaces and Buses
+===============================================================================
+The initial kdbus namespace is unconditionally created by the kernel module. A
+namespace contains a "control" device node which allows to create a new bus or
+namespace. New namespaces do not have any buses created by default.
+
+Opening the control device node returns a file descriptor, it accepts the
+ioctls KDBUS_CMD_BUS_MAKE/KDBUS_CMD_NS_MAKE which specify the name of the new
+bus or namespace to create. The control file descriptor needs to be kept open
+for the entire life-time of the created bus or namespace, closing it will
+immediately cleanup the entire bus or namespace and all its associated
+resources and connections. Every control file descriptor can only be used once
+to create a new bus or namespace; from that point, it is not used for any
+further communication until the final close().
+
+===============================================================================
+Connection IDs and Well-Known Connection Names
+===============================================================================
+Connections are identified by their connection id, internally implemented as a
+uint64_t counter. The IDs of every newly created bus start at 1, and every new
+connection will increment the counter by 1. The ids are not reused.
+
+In higher level tools, the user visible representation of a connection is
+defined by the D-Bus protocol specification as ":1.<id>".
+
+Messages with a specific uint64_t destination id are directly delivered to
+the connection with the corresponding id. Messages with the special destination
+id 0xffffffffffffffff are broadcast messages and are potentially delivered
+to all known connections on the bus; clients interested in broadcast messages
+need to subscribe to the specific messages they are interested though, before
+any broadcast message reaches them.
+
+Messages synthesized and sent directly by the kernel, will carry the special
+source id 0.
+
+In addition to the unique uint64_t connection id, established connections can
+request the ownership of well-known names, under which they can be found and
+addressed by other bus clients. A well-known name is associated with one and
+only one connection at a time.
+
+Messages can specify the special destination id 0 and carry a well-known name
+in the message data. Such a message is delivered to the destination connection
+which owns that well-known name.
+
+  +-------------------------------------------------------------------------+
+  | +---------------+     +---------------------------+                     |
+  | | Connection    |     | Message                   | -----------------+  |
+  | | :1.22         | --> | src: 22                   |                  |  |
+  | |               |     | dst: 25                   |                  |  |
+  | |               |     |                           |                  |  |
+  | |               |     |                           |                  |  |
+  | |               |     +---------------------------+                  |  |
+  | |               |                                                    |  |
+  | |               | <--------------------------------------+           |  |
+  | +---------------+                                        |           |  |
+  |                                                          |           |  |
+  | +---------------+     +---------------------------+      |           |  |
+  | | Connection    |     | Message                   | -----+           |  |
+  | | :1.25         | --> | src: 25                   |                  |  |
+  | |               |     | dst: 0xffffffffffffffff   | -------------+   |  |
+  | |               |     |                           |              |   |  |
+  | |               |     |                           | ---------+   |   |  |
+  | |               |     +---------------------------+          |   |   |  |
+  | |               |                                            |   |   |  |
+  | |               | <--------------------------------------------------+  |
+  | +---------------+                                            |   |      |
+  |                                                              |   |      |
+  | +---------------+     +---------------------------+          |   |      |
+  | | Connection    |     | Message                   | --+      |   |      |
+  | | :1.55         | --> | src: 55                   |   |      |   |      |
+  | |               |     | dst: 0 / org.foo.bar      |   |      |   |      |
+  | |               |     |                           |   |      |   |      |
+  | |               |     |                           |   |      |   |      |
+  | |               |     +---------------------------+   |      |   |      |
+  | |               |                                     |      |   |      |
+  | |               | <------------------------------------------+   |      |
+  | +---------------+                                     |          |      |
+  |                                                       |          |      |
+  | +---------------+                                     |          |      |
+  | | Connection    |                                     |          |      |
+  | | :1.81         |                                     |          |      |
+  | | org.foo.bar   |                                     |          |      |
+  | |               |                                     |          |      |
+  | |               |                                     |          |      |
+  | |               | <-----------------------------------+          |      |
+  | |               |                                                |      |
+  | |               | <----------------------------------------------+      |
+  | +---------------+                                                       |
+  +-------------------------------------------------------------------------+
+
+===============================================================================
+Message Format, Content, Exchange
+===============================================================================
+Messages consist of fixed-size header followed directly be a list of
+variable-sized data records. The overall message size is specified in the
+header of the message. The chain of data records can contain well-defined
+message metadata fields, raw data, references to data, or file descriptors.
+
+Messages are passed to the kernel with the ioctl KDBUS_CMD_MSG_SEND. Depending
+on the the destination address of the message, the kernel delivers the message
+to the specific destination connection or to all connections on the same bus.
+Messages are always queued in the destination connection.
+
+Messages are received by the client with the ioctl KDBUS_CMD_MSG_RECV. The
+endpoint device node of the bus supports poll() to wake up the receiving
+process when new messages are queued up to be received.
+
+  +-------------------------------------------------------------------------+
+  | Message                                                                 |
+  | +---------------------------------------------------------------------+ |
+  | | Header                                                              | |
+  | | size: overall message size, including the data records              | |
+  | | destination: connection id of the receiver                          | |
+  | | source: connection id of the sender (set by kernel)                 | |
+  | | payload_type: "DBusVer1" textual identifier stored as uint64_t      | |
+  | +---------------------------------------------------------------------+ |
+  | +---------------------------------------------------------------------+ |
+  | | Data Record                                                         | |
+  | | size: overall record size (without padding)                         | |
+  | | type: type of data                                                  | |
+  | | data: reference to data (address or file descriptor)                | |
+  | +---------------------------------------------------------------------+ |
+  | +---------------------------------------------------------------------+ |
+  | | padding bytes to the next 8 byte alignment                          | |
+  | +---------------------------------------------------------------------+ |
+  | +---------------------------------------------------------------------+ |
+  | | Data Record                                                         | |
+  | | size: overall record size (without padding)                         | |
+  | | ...                                                                 | |
+  | +---------------------------------------------------------------------+ |
+  | +---------------------------------------------------------------------+ |
+  | | padding bytes to the next 8 byte alignment                          | |
+  | +---------------------------------------------------------------------+ |
+  | +---------------------------------------------------------------------+ |
+  | | Data Record                                                         | |
+  | | size: overall record size                                           | |
+  | | ...                                                                 | |
+  | +---------------------------------------------------------------------+ |
+  | +---------------------------------------------------------------------+ |
+  | | padding bytes to the next 8 byte alignment                          | |
+  | +---------------------------------------------------------------------+ |
+  +-------------------------------------------------------------------------+
+
+===============================================================================
+Passing of Payload Data
+===============================================================================
+When connecting to the bus, receivers request a memory pool of a given size,
+large enough to carry all backlog of data enqueued for the connection. The
+pool is internally backed by a shared memory file which can be mmap()ed by
+the receiver.
+
+KDBUS_MSG_PAYLOAD_VEC:
+Messages are directly copied by the sending process into the receiver's pool,
+that way two peers can exchange data by effectively doing a single-copy from
+one process to another, the kernel will not buffer the data anywhere else.
+
+KDBUS_MSG_PAYLOAD_MEMFD:
+Messages can reference kdbus_memfd special files which contain the data.
+Kdbus_memfd files have special semantics, which allow the sealing of the
+content of the file, sealing prevents all writable access to the file content.
+Only sealed kdbus_memfd files are accepted as payload data, which enforces
+reliable passing of data; the receiver can assume that the sender and nobody
+else can alter the content after the message is sent.
+
+Apart from the sender filling-in the content into the kdbus_memfd file, the
+data will be passed as zero-copy from one process to another, read-only, shared
+between the peers.
+
+The sealing of a kdbus_memfd can be removed again by the sender or the
+receiver, as soon as the kdbus_memfd is not shared anymore.
diff --git a/drivers/kdbus/main.c b/drivers/kdbus/main.c
new file mode 100644
index 0000000..f7f1e53
--- /dev/null
+++ b/drivers/kdbus/main.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#define pr_fmt(fmt)    KBUILD_MODNAME ": " fmt
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+
+#include "internal.h"
+#include "namespace.h"
+
+static int __init kdbus_init(void)
+{
+	int ret;
+
+	ret = subsys_virtual_register(&kdbus_subsys, NULL);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Create the initial namespace; it is world-accessible and
+	 * provides the /dev/kdbus/control device node.
+	 */
+	ret = kdbus_ns_new(NULL, NULL, 0666, &kdbus_ns_init);
+	if (ret < 0) {
+		bus_unregister(&kdbus_subsys);
+		pr_err("failed to initialize, error=%i\n", ret);
+		return ret;
+	}
+
+	pr_info("initialized\n");
+	return 0;
+}
+
+static void __exit kdbus_exit(void)
+{
+	kdbus_ns_disconnect(kdbus_ns_init);
+	kdbus_ns_unref(kdbus_ns_init);
+	bus_unregister(&kdbus_subsys);
+}
+
+module_init(kdbus_init);
+module_exit(kdbus_exit);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("kdbus interprocess communication");
diff --git a/drivers/kdbus/match.c b/drivers/kdbus/match.c
new file mode 100644
index 0000000..da8a33b
--- /dev/null
+++ b/drivers/kdbus/match.c
@@ -0,0 +1,546 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/hash.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "bus.h"
+#include "connection.h"
+#include "endpoint.h"
+#include "match.h"
+#include "message.h"
+
+/**
+ * struct kdbus_match_db - message filters
+ * @entries_list:	List of matches
+ * @entries_lock:	Match data lock
+ */
+struct kdbus_match_db {
+	struct list_head	entries_list;
+	struct mutex		entries_lock;
+};
+
+/**
+ * struct kdbus_match_entry - a match database entry
+ * @cookie:		User-supplied cookie to lookup the entry
+ * @list_entry:		The list entry element for the db list
+ * @rules_list:		The list head for tracking rules of this entry
+ */
+struct kdbus_match_entry {
+	u64			cookie;
+	struct list_head	list_entry;
+	struct list_head	rules_list;
+};
+
+/**
+ * struct kdbus_match_rule - a rule appended to a match entry
+ * @type:		An item type to match agains
+ * @name:		Name to match against
+ * @bloom:		Bloom filter to match against
+ * @old_id:		For KDBUS_ITEM_ID_REMOVE and KDBUS_ITEM_NAME_REMOVE or
+ *			KDBUS_ITEM_NAME_CHANGE, stores a connection ID
+ * @src_id:		For KDBUS_ITEM_ID, stores a connection ID
+ * @new_id:		For KDBUS_ITEM_ID_ADD, KDBUS_ITEM_NAME_ADD or
+ *			KDBUS_ITEM_NAME_CHANGE, stores a connection ID
+ * @rules_entry:	List entry to the entry's rules list
+ */
+struct kdbus_match_rule {
+	u64			type;
+	union {
+		char		*name;
+		u64		*bloom;
+	};
+	union {
+		u64		old_id;
+		u64		src_id;
+	};
+	u64			new_id;
+
+	struct list_head	rules_entry;
+};
+
+static void kdbus_match_rule_free(struct kdbus_match_rule *rule)
+{
+	switch (rule->type) {
+	case KDBUS_ITEM_BLOOM:
+		kfree(rule->bloom);
+		break;
+
+	case KDBUS_ITEM_NAME:
+	case KDBUS_ITEM_NAME_ADD:
+	case KDBUS_ITEM_NAME_REMOVE:
+	case KDBUS_ITEM_NAME_CHANGE:
+		kfree(rule->name);
+		break;
+
+	case KDBUS_ITEM_ID:
+	case KDBUS_ITEM_ID_ADD:
+	case KDBUS_ITEM_ID_REMOVE:
+		break;
+
+	default:
+		BUG();
+	}
+
+	list_del(&rule->rules_entry);
+	kfree(rule);
+}
+
+static void kdbus_match_entry_free(struct kdbus_match_entry *entry)
+{
+	struct kdbus_match_rule *r, *tmp;
+
+	list_for_each_entry_safe(r, tmp, &entry->rules_list, rules_entry)
+		kdbus_match_rule_free(r);
+}
+
+/**
+ * kdbus_match_db_free() - free match db resources
+ * @db:			The match database
+ */
+void kdbus_match_db_free(struct kdbus_match_db *db)
+{
+	struct kdbus_match_entry *entry, *tmp;
+
+	mutex_lock(&db->entries_lock);
+	list_for_each_entry_safe(entry, tmp, &db->entries_list, list_entry)
+		kdbus_match_entry_free(entry);
+	mutex_unlock(&db->entries_lock);
+
+	kfree(db);
+}
+
+/**
+ * kdbus_match_db_new() - create a new match database
+ * @db:			Pointer location for the returned database
+ *
+ * Returns 0 on success, any other value in case of errors.
+ */
+int kdbus_match_db_new(struct kdbus_match_db **db)
+{
+	struct kdbus_match_db *d;
+
+	d = kzalloc(sizeof(*d), GFP_KERNEL);
+	if (!d)
+		return -ENOMEM;
+
+	mutex_init(&d->entries_lock);
+	INIT_LIST_HEAD(&d->entries_list);
+
+	*db = d;
+	return 0;
+}
+
+static bool kdbus_match_bloom(const u64 *filter, const u64 *mask,
+		       const struct kdbus_conn *conn)
+{
+	unsigned int i;
+
+	for (i = 0; i < conn->ep->bus->bloom_size / sizeof(u64); i++)
+		if ((filter[i] & mask[i]) != mask[i])
+			return false;
+
+	return true;
+}
+
+static bool kdbus_match_rules(const struct kdbus_match_entry *entry,
+			      struct kdbus_conn *conn_src,
+			      struct kdbus_kmsg *kmsg)
+{
+	struct kdbus_match_rule *r;
+
+	/*
+	 * Walk all the rules and bail out immediately
+	 * if any of them is unsatisfied.
+	 */
+
+	list_for_each_entry(r, &entry->rules_list, rules_entry) {
+
+		if (conn_src == NULL) {
+			/* kernel notifications */
+
+			if (kmsg->notify_type != r->type)
+				return false;
+
+			switch (r->type) {
+			case KDBUS_ITEM_ID_ADD:
+				if (r->new_id != KDBUS_MATCH_ID_ANY &&
+				    r->new_id != kmsg->notify_new_id)
+					return false;
+
+				break;
+
+			case KDBUS_ITEM_ID_REMOVE:
+				if (r->old_id != KDBUS_MATCH_ID_ANY &&
+				    r->old_id != kmsg->notify_old_id)
+					return false;
+
+				break;
+
+			case KDBUS_ITEM_NAME_ADD:
+			case KDBUS_ITEM_NAME_CHANGE:
+			case KDBUS_ITEM_NAME_REMOVE:
+				if ((r->old_id != KDBUS_MATCH_ID_ANY &&
+				     r->old_id != kmsg->notify_old_id) ||
+				    (r->new_id != KDBUS_MATCH_ID_ANY &&
+				     r->new_id != kmsg->notify_new_id) ||
+				    (r->name && kmsg->notify_name &&
+				     strcmp(r->name, kmsg->notify_name) != 0))
+					return false;
+
+				break;
+
+			default:
+				return false;
+			}
+		} else {
+			/* messages from userspace */
+
+			switch (r->type) {
+			case KDBUS_ITEM_BLOOM:
+				if (!kdbus_match_bloom(kmsg->bloom,
+						       r->bloom, conn_src))
+					return false;
+				break;
+
+			case KDBUS_ITEM_ID:
+				if (r->src_id != conn_src->id &&
+				    r->src_id != KDBUS_MATCH_ID_ANY)
+					return false;
+
+				break;
+
+			case KDBUS_ITEM_NAME:
+				if (!kdbus_conn_has_name(conn_src, r->name))
+					return false;
+
+				break;
+
+			default:
+				return false;
+			}
+		}
+	}
+
+	return true;
+}
+
+/**
+ * kdbus_match_db_match_kmsg() - match a kmsg object agains the database entries
+ * @db:			The match database
+ * @conn_src:		The connection object originating the message
+ * @kmsg:		The kmsg to perform the match on
+ *
+ * This function will walk through all the database entries previously uploaded
+ * with kdbus_match_db_add(). As soon as any of them has an all-satisfied rule
+ * set, this function will return true.
+ *
+ * Returns true in if there was a matching database entry, false otherwise.
+ */
+bool kdbus_match_db_match_kmsg(struct kdbus_match_db *db,
+			       struct kdbus_conn *conn_src,
+			       struct kdbus_kmsg *kmsg)
+{
+	struct kdbus_match_entry *entry;
+	bool matched = false;
+
+	mutex_lock(&db->entries_lock);
+	list_for_each_entry(entry, &db->entries_list, list_entry) {
+		matched = kdbus_match_rules(entry, conn_src, kmsg);
+		if (matched)
+			break;
+	}
+	mutex_unlock(&db->entries_lock);
+
+	return matched;
+}
+
+static int cmd_match_from_user(const struct kdbus_conn *conn,
+			       void __user *buf, bool items,
+			       struct kdbus_cmd_match **m)
+{
+	struct kdbus_cmd_match *cmd_match;
+	u64 size;
+
+	if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_match))
+		return -EFAULT;
+
+	if (size < sizeof(*cmd_match) || size > KDBUS_MATCH_MAX_SIZE)
+		return -EMSGSIZE;
+
+	/* remove does not accept any items */
+	if (!items && size != sizeof(*cmd_match))
+		return -EMSGSIZE;
+
+	cmd_match = memdup_user(buf, size);
+	if (IS_ERR(cmd_match))
+		return PTR_ERR(cmd_match);
+
+	/* privileged users can act on behalf of someone else */
+	if (cmd_match->owner_id == 0)
+		cmd_match->owner_id = conn->id;
+	else if (cmd_match->owner_id != conn->id &&
+		 !kdbus_bus_uid_is_privileged(conn->ep->bus)) {
+		kfree(cmd_match);
+		return -EPERM;
+	}
+
+	*m = cmd_match;
+
+	return 0;
+}
+
+/**
+ * kdbus_match_db_add() - add an entry to the match database
+ * @conn:		The connection that was used in the ioctl call
+ * @buf:		The __user buffer that was provided by the ioctl call
+ *
+ * Returns 0 in success, any other value in case of errors.
+ * This function is used in the context of the KDBUS_CMD_MATCH_ADD ioctl
+ * interface.
+ *
+ * One call to this function (or one ioctl(KDBUS_CMD_MATCH_ADD), respectively,
+ * adds one new database entry with n rules attached to it. Each rule is
+ * described with an kdbus_item, and an entry is considered matching if all
+ * its rules are satisfied.
+ *
+ * The items attached to a kdbus_cmd_match struct have the following mapping:
+ *
+ * KDBUS_ITEM_BLOOM:		Denotes a bloom mask
+ * KDBUS_ITEM_NAME:		Denotes a connection's source name
+ * KDBUS_ITEM_ID:		Denotes a connection's ID
+ * KDBUS_ITEM_NAME_ADD:
+ * KDBUS_ITEM_NAME_REMOVE:
+ * KDBUS_ITEM_NAME_CHANGE:	Describe kdbus_notify_name_change prototypes
+ * KDBUS_ITEM_ID_ADD:
+ * KDBUS_ITEM_ID_REMOVE:	Describe kdbus_notify_id_change prototypes
+ *
+ * For kdbus_notify_{id,name}_change structs, only the ID and name fields
+ * are looked at at when adding an entry. The flags are unused.
+ *
+ * Also note that KDBUS_ITEM_BLOOM, KDBUS_ITEM_NAME and KDBUS_ITEM_ID are
+ * used to match messages from userspace, while the others apply to kernel-
+ * generated notifications.
+ */
+int kdbus_match_db_add(struct kdbus_conn *conn, void __user *buf)
+{
+	struct kdbus_conn *target_conn = NULL;
+	struct kdbus_match_entry *entry = NULL;
+	struct kdbus_cmd_match *cmd_match;
+	struct kdbus_match_db *db;
+	struct kdbus_item *item;
+	LIST_HEAD(list);
+	int ret;
+
+	ret = cmd_match_from_user(conn, buf, true, &cmd_match);
+	if (ret < 0)
+		return ret;
+
+	if (cmd_match->owner_id != 0 && cmd_match->owner_id != conn->id) {
+		struct kdbus_bus *bus = conn->ep->bus;
+
+		mutex_lock(&bus->lock);
+		target_conn = kdbus_bus_find_conn_by_id(bus,
+							cmd_match->owner_id);
+		mutex_unlock(&bus->lock);
+
+		if (!target_conn) {
+			ret = -ENXIO;
+			goto exit_free;
+		}
+
+		db = target_conn->match_db;
+	} else {
+		db = conn->match_db;
+	}
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry) {
+		ret = -ENOMEM;
+		goto exit_free;
+	}
+
+	entry->cookie = cmd_match->cookie;
+
+	INIT_LIST_HEAD(&entry->rules_list);
+
+	KDBUS_ITEM_FOREACH(item, cmd_match, items) {
+		struct kdbus_match_rule *rule;
+		size_t size = item->size - offsetof(struct kdbus_item, data);
+
+		if (!KDBUS_ITEM_VALID(item, cmd_match)) {
+			ret = -EINVAL;
+			break;
+		}
+
+		rule = kzalloc(sizeof(*rule), GFP_KERNEL);
+		if (!rule) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		rule->type = item->type;
+
+		switch (item->type) {
+		case KDBUS_ITEM_BLOOM:
+			if (size != conn->ep->bus->bloom_size) {
+				ret = -EBADMSG;
+				break;
+			}
+
+			rule->bloom = kmemdup(item->data, size, GFP_KERNEL);
+			if (!rule->bloom) {
+				ret = -ENOMEM;
+				break;
+			}
+
+			break;
+
+		case KDBUS_ITEM_NAME:
+			if (size == 0) {
+				ret = -EINVAL;
+				break;
+			}
+
+			rule->name = kstrdup(item->str, GFP_KERNEL);
+			if (!rule->name)
+				ret = -ENOMEM;
+
+			break;
+
+		case KDBUS_ITEM_ID:
+			if (size < sizeof(u64)) {
+				ret = -EINVAL;
+				break;
+			}
+
+			rule->src_id = item->id;
+			break;
+
+		case KDBUS_ITEM_NAME_ADD:
+		case KDBUS_ITEM_NAME_REMOVE:
+		case KDBUS_ITEM_NAME_CHANGE: {
+			if (size < sizeof(struct kdbus_notify_name_change)) {
+				ret = -EINVAL;
+				break;
+			}
+
+			rule->old_id = item->name_change.old.id;
+			rule->new_id = item->name_change.new.id;
+
+			if (size > sizeof(struct kdbus_notify_name_change)) {
+				rule->name = kstrdup(item->name_change.name,
+						     GFP_KERNEL);
+				if (!rule->name)
+					ret = -ENOMEM;
+			}
+
+			break;
+		}
+
+		case KDBUS_ITEM_ID_ADD:
+		case KDBUS_ITEM_ID_REMOVE:
+			if (size < sizeof(struct kdbus_notify_id_change)) {
+				ret = -EINVAL;
+				break;
+			}
+
+			if (item->type == KDBUS_ITEM_ID_ADD)
+				rule->new_id = item->id_change.id;
+			else
+				rule->old_id = item->id_change.id;
+
+			break;
+
+		default:
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret < 0)
+			break;
+
+		list_add_tail(&rule->rules_entry, &entry->rules_list);
+	}
+
+	if (ret == 0 && !KDBUS_ITEM_END(item, cmd_match))
+		ret = -EINVAL;
+
+	if (ret == 0)
+		list_add_tail(&entry->list_entry, &db->entries_list);
+	else
+		kdbus_match_entry_free(entry);
+
+exit_free:
+	kdbus_conn_unref(target_conn);
+	kfree(cmd_match);
+
+	return ret;
+}
+
+/**
+ * kdbus_match_db_remove() - remove an entry from the match database
+ * @conn:		The connection that was used in the ioctl call
+ * @buf:		The __user buffer that was provided by the ioctl call
+ *
+ * Returns 0 in success, any other value in case of errors.
+ * This function is used in the context of the KDBUS_CMD_MATCH_REMOVE
+ * ioctl interface.
+ */
+int kdbus_match_db_remove(struct kdbus_conn *conn, void __user *buf)
+{
+	struct kdbus_conn *target_conn = NULL;
+	struct kdbus_match_db *db;
+	struct kdbus_cmd_match *cmd_match = NULL;
+	struct kdbus_match_entry *entry, *tmp;
+	int ret;
+
+	ret = cmd_match_from_user(conn, buf, false, &cmd_match);
+	if (ret < 0)
+		return ret;
+
+	if (cmd_match->owner_id != 0 && cmd_match->owner_id != conn->id) {
+		struct kdbus_bus *bus = conn->ep->bus;
+
+		mutex_lock(&bus->lock);
+		target_conn = kdbus_bus_find_conn_by_id(bus,
+							cmd_match->owner_id);
+		mutex_unlock(&bus->lock);
+
+		if (!target_conn) {
+			kfree(cmd_match);
+			return -ENXIO;
+		}
+
+		db = target_conn->match_db;
+	} else {
+		db = conn->match_db;
+	}
+
+	mutex_lock(&db->entries_lock);
+	list_for_each_entry_safe(entry, tmp, &db->entries_list, list_entry)
+		if (entry->cookie == cmd_match->cookie)
+			kdbus_match_entry_free(entry);
+	mutex_unlock(&db->entries_lock);
+
+	kdbus_conn_unref(target_conn);
+	kfree(cmd_match);
+
+	return 0;
+}
diff --git a/drivers/kdbus/match.h b/drivers/kdbus/match.h
new file mode 100644
index 0000000..48249fe
--- /dev/null
+++ b/drivers/kdbus/match.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_MATCH_H
+#define __KDBUS_MATCH_H
+
+struct kdbus_conn;
+struct kdbus_kmsg;
+struct kdbus_match_db;
+
+int kdbus_match_db_new(struct kdbus_match_db **db);
+void kdbus_match_db_free(struct kdbus_match_db *db);
+int kdbus_match_db_add(struct kdbus_conn *conn, void __user *buf);
+int kdbus_match_db_remove(struct kdbus_conn *conn, void __user *buf);
+bool kdbus_match_db_match_kmsg(struct kdbus_match_db *db,
+			       struct kdbus_conn *conn_src,
+			       struct kdbus_kmsg *kmsg);
+#endif
diff --git a/drivers/kdbus/memfd.c b/drivers/kdbus/memfd.c
new file mode 100644
index 0000000..2c08891
--- /dev/null
+++ b/drivers/kdbus/memfd.c
@@ -0,0 +1,375 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/aio.h>
+#include <linux/anon_inodes.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/mman.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/shmem_fs.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "memfd.h"
+
+static const struct file_operations kdbus_memfd_fops;
+
+/**
+ * struct kdbus_memfile - protectable shared memory file
+ * @sealed:		Flag if the content is writable
+ * @lock:		Locking
+ * @fp:			Shared memory backing file
+ */
+struct kdbus_memfile {
+	bool sealed;
+	struct mutex lock;
+	struct file *fp;
+};
+
+/**
+ * kdbus_is_memfd() - check if a file is one of our memfds
+ * @fp:			File to check
+ *
+ * Returns: true if the file is a memfd
+ */
+bool kdbus_is_memfd(const struct file *fp)
+{
+	return fp->f_op == &kdbus_memfd_fops;
+}
+
+/**
+ * kdbus_is_memfd_sealed() - check if a memfd is protected
+ * @fp:			Memfd file to check
+ *
+ * Returns: true if the memfd is protected
+ */
+bool kdbus_is_memfd_sealed(const struct file *fp)
+{
+	struct kdbus_memfile *mf = fp->private_data;
+	bool sealed;
+
+	mutex_lock(&mf->lock);
+	sealed = mf->sealed;
+	mutex_unlock(&mf->lock);
+
+	return sealed;
+}
+
+/**
+ * kdbus_memfd_size() - return the actual size of a memfd
+ * @fp:			Memfd file to check
+ *
+ * Returns: the actual size of the file in bytes
+ */
+u64 kdbus_memfd_size(const struct file *fp)
+{
+	struct kdbus_memfile *mf = fp->private_data;
+	u64 size;
+
+	mutex_lock(&mf->lock);
+	size = i_size_read(file_inode(mf->fp));
+	mutex_unlock(&mf->lock);
+
+	return size;
+}
+
+/**
+ * kdbus_memfd_new() - create and install a memfd and file descriptor
+ * @fd:			installed file descriptor
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_memfd_new(int *fd)
+{
+	struct kdbus_memfile *mf;
+	struct file *shmemfp;
+	struct file *fp;
+	int f;
+	int ret;
+
+	mf = kzalloc(sizeof(struct kdbus_memfile), GFP_KERNEL);
+	if (!mf)
+		return -ENOMEM;
+
+	mutex_init(&mf->lock);
+
+	/* allocate a new unlinked shmem file */
+	shmemfp = shmem_file_setup(KBUILD_MODNAME "-memfd", 0, 0);
+	if (IS_ERR(shmemfp)) {
+		ret = PTR_ERR(shmemfp);
+		goto exit;
+	}
+	mf->fp = shmemfp;
+
+	f = get_unused_fd_flags(O_CLOEXEC);
+	if (f < 0) {
+		ret = f;
+		goto exit_shmem;
+	}
+
+	/* The anonymous exported inode ops cannot reach the otherwise
+	 * invisible shmem inode. We rely on the fact that nothing else
+	 * can create a new file for the shmem inode, like by opening the
+	 * fd in /proc/$PID/fd/ */
+	fp = anon_inode_getfile("[" KBUILD_MODNAME "]",
+				&kdbus_memfd_fops, mf, O_RDWR);
+	if (IS_ERR(fp)) {
+		ret = PTR_ERR(fp);
+		goto exit_fd;
+	}
+
+	fp->f_mode |= FMODE_LSEEK|FMODE_PREAD|FMODE_PWRITE;
+	fp->f_mapping = shmemfp->f_mapping;
+	fd_install(f, fp);
+
+	*fd = f;
+	return 0;
+
+exit_fd:
+	put_unused_fd(f);
+exit_shmem:
+	fput(shmemfp);
+exit:
+	kfree(mf);
+	return ret;
+}
+
+static int kdbus_memfd_release(struct inode *ignored, struct file *file)
+{
+	struct kdbus_memfile *mf = file->private_data;
+
+	fput(mf->fp);
+	kfree(mf);
+	return 0;
+}
+
+static loff_t kdbus_memfd_llseek(struct file *file, loff_t offset, int whence)
+{
+	struct kdbus_memfile *mf = file->private_data;
+	loff_t ret;
+
+	mutex_lock(&mf->lock);
+	ret = mf->fp->f_op->llseek(mf->fp, offset, whence);
+	if (ret < 0)
+		goto exit;
+
+	/* update the anonymous file */
+	file->f_pos = mf->fp->f_pos;
+
+exit:
+	mutex_unlock(&mf->lock);
+	return ret;
+}
+
+static ssize_t kdbus_memfd_readv(struct kiocb *iocb, const struct iovec *iov,
+				 unsigned long iov_count, loff_t pos)
+{
+	struct kdbus_memfile *mf = iocb->ki_filp->private_data;
+	ssize_t ret;
+
+	mutex_lock(&mf->lock);
+	iocb->ki_filp = mf->fp;
+	ret = mf->fp->f_op->aio_read(iocb, iov, iov_count, pos);
+	if (ret < 0)
+		goto exit;
+
+	/* update the shmem file */
+	mf->fp->f_pos = iocb->ki_pos;
+
+exit:
+	mutex_unlock(&mf->lock);
+	return ret;
+}
+
+static ssize_t kdbus_memfd_writev(struct kiocb *iocb, const struct iovec *iov,
+				  unsigned long iov_count, loff_t pos)
+{
+	struct kdbus_memfile *mf = iocb->ki_filp->private_data;
+	ssize_t ret;
+
+	mutex_lock(&mf->lock);
+
+	/* deny write access to a sealed file */
+	if (mf->sealed) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	iocb->ki_filp = mf->fp;
+	ret = mf->fp->f_op->aio_write(iocb, iov, iov_count, pos);
+	if (ret < 0)
+		goto exit;
+
+	/* update the shmem file */
+	mf->fp->f_pos = iocb->ki_pos;
+
+exit:
+	mutex_unlock(&mf->lock);
+	return ret;
+}
+
+static int kdbus_memfd_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct kdbus_memfile *mf = file->private_data;
+	int ret = 0;
+
+	if (vma->vm_flags & VM_WRITE) {
+		size_t size;
+		struct inode *inode;
+
+		/*
+		 * Deny a writable mapping to a sealed file.
+		 *
+		 * Avoid a deadlock and do not take mf->lock here, the call to
+		 * mmap() already holds mm->mmap_sem.
+		 * To protect KDBUS_CMD_MEMFD_SEAL_SET racing against us,
+		 * mf->sealed is changed only with mm->mmap_sem held.
+		 */
+		if (mf->sealed) {
+			ret = -EPERM;
+			goto exit;
+		}
+
+		/*
+		 * Extend the size of the shmem file to the
+		 * size of the mapping
+		 */
+		size = (vma->vm_end - vma->vm_start) +
+		       (vma->vm_pgoff << PAGE_SHIFT);
+		inode = file_inode(mf->fp);
+		if (size > PAGE_ALIGN(i_size_read(inode)))
+			i_size_write(inode, size);
+	}
+
+	/* replace the anoymous inode file with our shmem file */
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = get_file(mf->fp);
+	ret = mf->fp->f_op->mmap(file, vma);
+
+exit:
+	return ret;
+}
+
+static long
+kdbus_memfd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct kdbus_memfile *mf = file->private_data;
+	long ret = 0;
+
+	mutex_lock(&mf->lock);
+	switch (cmd) {
+	case KDBUS_CMD_MEMFD_SIZE_GET: {
+		u64 size = i_size_read(file_inode(mf->fp));
+
+		if (!KDBUS_IS_ALIGNED8(arg)) {
+			ret = -EFAULT;
+			goto exit;
+		}
+
+		if (copy_to_user(argp, &size, sizeof(__u64))) {
+			ret = -EFAULT;
+			goto exit;
+		}
+		break;
+	}
+
+	case KDBUS_CMD_MEMFD_SIZE_SET: {
+		u64 size;
+
+		if (!KDBUS_IS_ALIGNED8(arg)) {
+			ret = -EFAULT;
+			goto exit;
+		}
+
+		if (copy_from_user(&size, argp, sizeof(__u64))) {
+			ret = -EFAULT;
+			goto exit;
+		}
+
+		/* deny a writable access to a sealed file */
+		if (mf->sealed) {
+			if (size == i_size_read(file_inode(mf->fp)))
+				ret = -EALREADY;
+			else
+				ret = -EPERM;
+			goto exit;
+		}
+
+		if (size != i_size_read(file_inode(mf->fp)))
+			ret = vfs_truncate(&mf->fp->f_path, size);
+		break;
+	}
+
+	case KDBUS_CMD_MEMFD_SEAL_GET: {
+		int __user *addr = argp;
+
+		if (put_user(mf->sealed, addr)) {
+			ret = -EFAULT;
+			goto exit;
+		}
+		break;
+	}
+
+	case KDBUS_CMD_MEMFD_SEAL_SET: {
+		struct mm_struct *mm = current->mm;
+
+		/*
+		 * Make sure we have only one single user of the file
+		 * before we seal, we rely on the fact there is no
+		 * any other possibly writable references to the file.
+		 *
+		 * Protect mmap() racing against us, take mm->mmap_sem
+		 * when accessing mf->sealed.
+		 */
+		down_read(&mm->mmap_sem);
+		if (file_count(mf->fp) != 1) {
+			if (mf->sealed == !!argp)
+				ret = -EALREADY;
+			else
+				ret = -ETXTBSY;
+		}
+
+		if (ret == 0)
+			mf->sealed = !!argp;
+		up_read(&mm->mmap_sem);
+		break;
+	}
+
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+exit:
+	mutex_unlock(&mf->lock);
+	return ret;
+}
+
+static const struct file_operations kdbus_memfd_fops = {
+	.owner =		THIS_MODULE,
+	.release =		kdbus_memfd_release,
+	.aio_read =		kdbus_memfd_readv,
+	.aio_write =		kdbus_memfd_writev,
+	.llseek =		kdbus_memfd_llseek,
+	.mmap =			kdbus_memfd_mmap,
+	.unlocked_ioctl =	kdbus_memfd_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl =		kdbus_memfd_ioctl,
+#endif
+};
diff --git a/drivers/kdbus/memfd.h b/drivers/kdbus/memfd.h
new file mode 100644
index 0000000..7fc327a
--- /dev/null
+++ b/drivers/kdbus/memfd.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_MEMFD_H
+#define __KDBUS_MEMFD_H
+
+#include "internal.h"
+
+bool kdbus_is_memfd(const struct file *fp);
+bool kdbus_is_memfd_sealed(const struct file *fp);
+u64 kdbus_memfd_size(const struct file *fp);
+int kdbus_memfd_new(int *fd);
+#endif
diff --git a/drivers/kdbus/message.c b/drivers/kdbus/message.c
new file mode 100644
index 0000000..0340b55
--- /dev/null
+++ b/drivers/kdbus/message.c
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/capability.h>
+#include <linux/cgroup.h>
+#include <linux/cred.h>
+#include <linux/device.h>
+#include <linux/file.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "bus.h"
+#include "connection.h"
+#include "endpoint.h"
+#include "match.h"
+#include "message.h"
+#include "names.h"
+#include "policy.h"
+
+#define KDBUS_KMSG_HEADER_SIZE offsetof(struct kdbus_kmsg, msg)
+
+/**
+ * kdbus_kmsg_free() - free allocated message
+ * @kmsg:		Message
+ */
+void kdbus_kmsg_free(struct kdbus_kmsg *kmsg)
+{
+	kdbus_meta_free(kmsg->meta);
+	kfree(kmsg);
+}
+
+/**
+ * kdbus_kmsg_new() - allocate message
+ * @extra_size:		additional size to reserve for data
+ * @kmsg:			Returned Message
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_kmsg_new(size_t extra_size, struct kdbus_kmsg **kmsg)
+{
+	struct kdbus_kmsg *m;
+	size_t size;
+
+	BUG_ON(*kmsg);
+
+	size = sizeof(struct kdbus_kmsg) + KDBUS_ITEM_SIZE(extra_size);
+	m = kzalloc(size, GFP_KERNEL);
+	if (!m)
+		return -ENOMEM;
+
+	m->msg.size = size - KDBUS_KMSG_HEADER_SIZE;
+	m->msg.items[0].size = KDBUS_ITEM_SIZE(extra_size);
+
+	*kmsg = m;
+	return 0;
+}
+
+/*
+ * kdbus_msg_scan_items - validate incoming data and prepare parsing
+ * @conn:		Connection
+ * @kmsg:		Message
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+static int kdbus_msg_scan_items(struct kdbus_conn *conn,
+				struct kdbus_kmsg *kmsg)
+{
+	const struct kdbus_msg *msg = &kmsg->msg;
+	const struct kdbus_item *item;
+	size_t vecs_size = 0;
+	unsigned int items_count = 0;
+	bool has_fds = false;
+	bool has_name = false;
+	bool has_bloom = false;
+
+	KDBUS_ITEM_FOREACH(item, msg, items) {
+		size_t payload_size;
+
+		if (!KDBUS_ITEM_VALID(item, msg))
+			return -EINVAL;
+
+		if (++items_count > KDBUS_MSG_MAX_ITEMS)
+			return -E2BIG;
+
+		payload_size = item->size - KDBUS_ITEM_HEADER_SIZE;
+
+		switch (item->type) {
+		case KDBUS_ITEM_PAYLOAD_VEC:
+			if (payload_size != sizeof(struct kdbus_vec))
+				return -EINVAL;
+
+			/* empty payload is invalid */
+			if (item->vec.size == 0)
+				return -EINVAL;
+
+			vecs_size += item->vec.size;
+			if (vecs_size > KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE &&
+			    !kdbus_bus_uid_is_privileged(conn->ep->bus))
+				return -EMSGSIZE;
+
+			/* \0-bytes records store only the alignment bytes */
+			if (KDBUS_PTR(item->vec.address))
+				kmsg->vecs_size += item->vec.size;
+			else
+				kmsg->vecs_size += item->vec.size % 8;
+			kmsg->vecs_count++;
+			break;
+
+		case KDBUS_ITEM_PAYLOAD_MEMFD:
+			if (payload_size != sizeof(struct kdbus_memfd))
+				return -EINVAL;
+
+			/* do not allow to broadcast file descriptors */
+			if (msg->dst_id == KDBUS_DST_ID_BROADCAST)
+				return -ENOTUNIQ;
+
+			if (item->memfd.fd < 0)
+				return -EBADF;
+
+			/* empty payload is invalid */
+			if (item->memfd.size == 0)
+				return -EINVAL;
+
+			kmsg->memfds_count++;
+			break;
+
+		case KDBUS_ITEM_FDS: {
+			unsigned int n;
+
+			/* do not allow multiple fd arrays */
+			if (has_fds)
+				return -EEXIST;
+			has_fds = true;
+
+			/* do not allow to broadcast file descriptors */
+			if (msg->dst_id == KDBUS_DST_ID_BROADCAST)
+				return -ENOTUNIQ;
+
+			n = payload_size / sizeof(int);
+			if (n > KDBUS_MSG_MAX_FDS)
+				return -EMFILE;
+
+			kmsg->fds = item->fds;
+			kmsg->fds_count = n;
+			break;
+		}
+
+		case KDBUS_ITEM_BLOOM:
+			/* do not allow multiple bloom filters */
+			if (has_bloom)
+				return -EEXIST;
+			has_bloom = true;
+
+			/* bloom filters are only for broadcast messages */
+			if (msg->dst_id != KDBUS_DST_ID_BROADCAST)
+				return -EBADMSG;
+
+			/* allow only bloom sizes of a multiple of 64bit */
+			if (!KDBUS_IS_ALIGNED8(payload_size))
+				return -EFAULT;
+
+			/* do not allow mismatching bloom filter sizes */
+			if (payload_size != conn->ep->bus->bloom_size)
+				return -EDOM;
+
+			kmsg->bloom = item->data64;
+			break;
+
+		case KDBUS_ITEM_DST_NAME:
+			/* do not allow multiple names */
+			if (has_name)
+				return -EEXIST;
+			has_name = true;
+
+			/* enforce NUL-terminated strings */
+			if (!kdbus_validate_nul(item->str, payload_size))
+				return -EINVAL;
+
+			if (!kdbus_name_is_valid(item->str))
+				return -EINVAL;
+
+			kmsg->dst_name = item->str;
+			break;
+
+		default:
+			return -ENOTSUPP;
+		}
+	}
+
+	if (!KDBUS_ITEM_END(item, msg))
+		return -EINVAL;
+
+	/* name is needed if no ID is given */
+	if (msg->dst_id == KDBUS_DST_ID_NAME && !has_name)
+		return -EDESTADDRREQ;
+
+	/* name and ID should not be given at the same time */
+	if (msg->dst_id > KDBUS_DST_ID_NAME &&
+	    msg->dst_id < KDBUS_DST_ID_BROADCAST && has_name)
+		return -EBADMSG;
+
+	if (msg->dst_id == KDBUS_DST_ID_BROADCAST) {
+		/* broadcast messages require a bloom filter */
+		if (!has_bloom)
+			return -EBADMSG;
+
+		/* timeouts are not allowed for broadcasts */
+		if (msg->timeout_ns > 0)
+			return -ENOTUNIQ;
+	}
+
+	/* bloom filters are for undirected messages only */
+	if (has_name && has_bloom)
+		return -EBADMSG;
+
+	return 0;
+}
+
+/**
+ * kdbus_kmsg_new_from_user() - copy message from user memory
+ * @conn:		Connection
+ * @msg:		User-provided message
+ * @kmsg:		Copy of message
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_kmsg_new_from_user(struct kdbus_conn *conn,
+			     struct kdbus_msg __user *msg,
+			     struct kdbus_kmsg **kmsg)
+{
+	struct kdbus_kmsg *m;
+	u64 size, alloc_size;
+	int ret;
+
+	BUG_ON(*kmsg);
+
+	if (!KDBUS_IS_ALIGNED8((unsigned long)msg))
+		return -EFAULT;
+
+	if (kdbus_size_get_user(&size, msg, struct kdbus_msg))
+		return -EFAULT;
+
+	if (size < sizeof(struct kdbus_msg) || size > KDBUS_MSG_MAX_SIZE)
+		return -EMSGSIZE;
+
+	alloc_size = size + KDBUS_KMSG_HEADER_SIZE;
+
+	m = kmalloc(alloc_size, GFP_KERNEL);
+	if (!m)
+		return -ENOMEM;
+	memset(m, 0, KDBUS_KMSG_HEADER_SIZE);
+
+	if (copy_from_user(&m->msg, msg, size)) {
+		ret = -EFAULT;
+		goto exit_free;
+	}
+
+	/* do not accept kernel-generated messages */
+	if (m->msg.payload_type == 0) {
+		ret = -EINVAL;
+		goto exit_free;
+	}
+
+	/* requests for replies need a timeout */
+	if (m->msg.flags & KDBUS_MSG_FLAGS_EXPECT_REPLY &&
+	    m->msg.timeout_ns == 0) {
+		ret = -EINVAL;
+		goto exit_free;
+	}
+
+	ret = kdbus_msg_scan_items(conn, m);
+	if (ret < 0)
+		goto exit_free;
+
+	/* patch-in the source of this message */
+	m->msg.src_id = conn->id;
+
+	*kmsg = m;
+	return 0;
+
+exit_free:
+	kdbus_kmsg_free(m);
+	return ret;
+}
diff --git a/drivers/kdbus/message.h b/drivers/kdbus/message.h
new file mode 100644
index 0000000..1fc6f2ef
--- /dev/null
+++ b/drivers/kdbus/message.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_MESSAGE_H
+#define __KDBUS_MESSAGE_H
+
+#include "internal.h"
+#include "metadata.h"
+
+/**
+ * struct kdbus_kmsg - internal message handling data
+ * @notify_type:	Short-cut for faster lookup
+ * @notify_old_id:	Short-cut for faster lookup
+ * @notify_new_id:	Short-cut for faster lookup
+ * @notify_name:	Short-cut for faster lookup
+ * @dst_name:		Short-cut to msg for faster lookup
+ * @dst_name_id:	Short-cut to msg for faster lookup
+ * @bloom:		Short-cut to msg for faster lookup
+ * @bloom_size:		Short-cut to msg for faster lookup
+ * @fds:		Array of file descriptors to pass
+ * @fds_count:		Number of file descriptors to pass
+ * @meta:		Appended SCM-like metadata of the sending process
+ * @vecs_size:		Size of PAYLOAD data
+ * @vecs_count:		Number of PAYLOAD vectors
+ * @memfds_count:	Number of memfds to pass
+ * @queue_entry:	List of kernel-generated notifications
+ * @msg:		Message from or to userspace
+ */
+struct kdbus_kmsg {
+	u64 notify_type;
+	u64 notify_old_id;
+	u64 notify_new_id;
+	const char *notify_name;
+
+	const char *dst_name;
+	u64 dst_name_id;
+	const u64 *bloom;
+	unsigned int bloom_size;
+	const int *fds;
+	unsigned int fds_count;
+	struct kdbus_meta *meta;
+	size_t vecs_size;
+	unsigned int vecs_count;
+	unsigned int memfds_count;
+	struct list_head queue_entry;
+
+	/* variable size, must be the last member */
+	struct kdbus_msg msg;
+};
+
+struct kdbus_ep;
+struct kdbus_conn;
+
+int kdbus_kmsg_new(size_t extra_size, struct kdbus_kmsg **kmsg);
+int kdbus_kmsg_new_from_user(struct kdbus_conn *conn,
+			     struct kdbus_msg __user *msg,
+			     struct kdbus_kmsg **kmsg);
+void kdbus_kmsg_free(struct kdbus_kmsg *kmsg);
+#endif
diff --git a/drivers/kdbus/metadata.c b/drivers/kdbus/metadata.c
new file mode 100644
index 0000000..364d9cd
--- /dev/null
+++ b/drivers/kdbus/metadata.c
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/audit.h>
+#include <linux/capability.h>
+#include <linux/cgroup.h>
+#include <linux/cred.h>
+#include <linux/file.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/pid_namespace.h>
+#include <linux/sched.h>
+#include <linux/security.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "connection.h"
+#include "metadata.h"
+#include "names.h"
+
+/**
+ * kdbus_meta_new() - create new metadata object
+ * @meta:		New metadata object
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_meta_new(struct kdbus_meta **meta)
+{
+	struct kdbus_meta *m;
+
+	BUG_ON(*meta);
+
+	m = kzalloc(sizeof(struct kdbus_meta), GFP_KERNEL);
+	if (!m)
+		return -ENOMEM;
+
+	/*
+	 * Remember the PID namespace our credentials belong to; we
+	 * need to prevent leaking authorization and security-relevant
+	 * data across different namespaces.
+	 */
+	m->ns = task_active_pid_ns(current);
+
+	*meta = m;
+	return 0;
+}
+
+/**
+ * kdbus_meta_free() - release metadata
+ * @meta:		Metadata object
+ */
+void kdbus_meta_free(struct kdbus_meta *meta)
+{
+	if (!meta)
+		return;
+
+	kfree(meta->data);
+	kfree(meta);
+}
+
+static struct kdbus_item *
+kdbus_meta_append_item(struct kdbus_meta *meta, size_t extra_size)
+{
+	struct kdbus_item *item;
+	size_t size;
+
+	/* get new metadata buffer, pre-allocate at least 512 bytes */
+	if (!meta->data) {
+		size = roundup_pow_of_two(256 + KDBUS_ALIGN8(extra_size));
+		meta->data = kzalloc(size, GFP_KERNEL);
+		if (!meta->data)
+			return ERR_PTR(-ENOMEM);
+
+		meta->allocated_size = size;
+	}
+
+	/* double the pre-allocated buffer size if needed */
+	size = meta->size + KDBUS_ALIGN8(extra_size);
+	if (size > meta->allocated_size) {
+		size_t size_diff;
+		struct kdbus_item *data;
+
+		size = roundup_pow_of_two(size);
+		size_diff = size - meta->allocated_size;
+		data = kmalloc(size, GFP_KERNEL);
+		if (!data)
+			return ERR_PTR(-ENOMEM);
+
+		memcpy(data, meta->data, meta->size);
+		memset((u8 *)data + meta->allocated_size, 0, size_diff);
+
+		kfree(meta->data);
+		meta->data = data;
+		meta->allocated_size = size;
+
+	}
+
+	/* insert new record */
+	item = (struct kdbus_item *)((u8 *)meta->data + meta->size);
+	meta->size += KDBUS_ALIGN8(extra_size);
+
+	return item;
+}
+
+/**
+ * kdbus_meta_append_data() - append given raw data to metadata object
+ * @meta:		Metadata object
+ * @type:		KDBUS_ITEM_* type
+ * @data:		pointer to data to copy from
+ * @len:		number of bytes to copy
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_meta_append_data(struct kdbus_meta *meta, u64 type,
+				  const void *data, size_t len)
+{
+	struct kdbus_item *item;
+	u64 size;
+
+	if (len == 0)
+		return 0;
+
+	size = KDBUS_ITEM_SIZE(len);
+	item = kdbus_meta_append_item(meta, size);
+	if (IS_ERR(item))
+		return PTR_ERR(item);
+
+	item->type = type;
+	item->size = KDBUS_ITEM_HEADER_SIZE + len;
+	memcpy(item->data, data, len);
+
+	return 0;
+}
+
+static int kdbus_meta_append_str(struct kdbus_meta *meta, u64 type,
+				 const char *str)
+{
+	return kdbus_meta_append_data(meta, type, str, strlen(str) + 1);
+}
+
+static int kdbus_meta_append_timestamp(struct kdbus_meta *meta)
+{
+	struct kdbus_item *item;
+	u64 size = KDBUS_ITEM_SIZE(sizeof(struct kdbus_timestamp));
+	struct timespec ts;
+
+	item = kdbus_meta_append_item(meta, size);
+	if (IS_ERR(item))
+		return PTR_ERR(item);
+
+	item->type = KDBUS_ITEM_TIMESTAMP;
+	item->size = size;
+
+	ktime_get_ts(&ts);
+	item->timestamp.monotonic_ns = timespec_to_ns(&ts);
+
+	ktime_get_real_ts(&ts);
+	item->timestamp.realtime_ns = timespec_to_ns(&ts);
+
+	return 0;
+}
+
+static int kdbus_meta_append_cred(struct kdbus_meta *meta)
+{
+	struct kdbus_creds creds = {};
+
+	creds.uid = from_kuid(current_user_ns(), current_uid());
+	creds.gid = from_kgid(current_user_ns(), current_gid());
+	creds.pid = task_pid_vnr(current);
+	creds.tid = task_tgid_vnr(current);
+	creds.starttime = timespec_to_ns(&current->start_time);
+
+	return kdbus_meta_append_data(meta, KDBUS_ITEM_CREDS,
+				      &creds, sizeof(struct kdbus_creds));
+}
+
+static int kdbus_meta_append_src_names(struct kdbus_meta *meta,
+				       struct kdbus_conn *conn)
+{
+	struct kdbus_name_entry *e;
+	int ret = 0;
+
+	if (!conn)
+		return 0;
+
+	mutex_lock(&conn->lock);
+	list_for_each_entry(e, &conn->names_list, conn_entry) {
+		struct kdbus_item *item;
+		size_t len;
+		size_t size;
+
+		len = strlen(e->name) + 1;
+		size = KDBUS_ITEM_SIZE(sizeof(struct kdbus_name) + len);
+
+		item = kdbus_meta_append_item(meta, size);
+		if (IS_ERR(item)) {
+			ret = PTR_ERR(item);
+			break;
+		}
+
+		item->type = KDBUS_ITEM_NAME;
+		item->size = KDBUS_ITEM_HEADER_SIZE +
+				sizeof(struct kdbus_name) + len;
+		item->name.flags = e->flags;
+		memcpy(item->name.name, e->name, len);
+	}
+	mutex_unlock(&conn->lock);
+
+	return ret;
+}
+
+static int kdbus_meta_append_exe(struct kdbus_meta *meta)
+{
+	struct mm_struct *mm = get_task_mm(current);
+	struct path *exe_path = NULL;
+	int ret = 0;
+
+	if (mm) {
+		down_read(&mm->mmap_sem);
+		if (mm->exe_file) {
+			path_get(&mm->exe_file->f_path);
+			exe_path = &mm->exe_file->f_path;
+		}
+		up_read(&mm->mmap_sem);
+		mmput(mm);
+	}
+
+	if (exe_path) {
+		char *tmp;
+		char *pathname;
+
+		tmp = (char *) __get_free_page(GFP_TEMPORARY | __GFP_ZERO);
+		if (!tmp) {
+			path_put(exe_path);
+			return -ENOMEM;
+		}
+
+		pathname = d_path(exe_path, tmp, PAGE_SIZE);
+		if (!IS_ERR(pathname)) {
+			size_t len = tmp + PAGE_SIZE - pathname;
+			ret = kdbus_meta_append_data(meta, KDBUS_ITEM_EXE,
+						     pathname, len);
+		}
+
+		free_page((unsigned long) tmp);
+		path_put(exe_path);
+	}
+
+	return ret;
+}
+
+static int kdbus_meta_append_cmdline(struct kdbus_meta *meta)
+{
+	struct mm_struct *mm = current->mm;
+	char *tmp;
+	int ret = 0;
+
+	tmp = (char *) __get_free_page(GFP_TEMPORARY | __GFP_ZERO);
+	if (!tmp)
+		return -ENOMEM;
+
+	if (mm && mm->arg_end) {
+		size_t len = mm->arg_end - mm->arg_start;
+
+		if (len > PAGE_SIZE)
+			len = PAGE_SIZE;
+
+		ret = copy_from_user(tmp, (const char __user *)mm->arg_start,
+				     len);
+		if (ret == 0)
+			ret = kdbus_meta_append_data(meta, KDBUS_ITEM_CMDLINE,
+						     tmp, len);
+	}
+
+	free_page((unsigned long) tmp);
+	return ret;
+}
+
+static int kdbus_meta_append_caps(struct kdbus_meta *meta)
+{
+	const struct cred *cred;
+	struct caps {
+		u32 cap[_KERNEL_CAPABILITY_U32S];
+	} cap[4];
+	unsigned int i;
+
+	rcu_read_lock();
+	cred = __task_cred(current);
+	for (i = 0; i < _KERNEL_CAPABILITY_U32S; i++) {
+		cap[0].cap[i] = cred->cap_inheritable.cap[i];
+		cap[1].cap[i] = cred->cap_permitted.cap[i];
+		cap[2].cap[i] = cred->cap_effective.cap[i];
+		cap[3].cap[i] = cred->cap_bset.cap[i];
+	}
+	rcu_read_unlock();
+
+	/* clear unused bits */
+	for (i = 0; i < 4; i++)
+		cap[i].cap[CAP_TO_INDEX(CAP_LAST_CAP)] &=
+			CAP_TO_MASK(CAP_LAST_CAP + 1) - 1;
+
+	return kdbus_meta_append_data(meta, KDBUS_ITEM_CAPS,
+				      cap, sizeof(cap));
+}
+
+#ifdef CONFIG_CGROUPS
+static int kdbus_meta_append_cgroup(struct kdbus_meta *meta)
+{
+	char *tmp;
+	int ret;
+
+	tmp = (char *) __get_free_page(GFP_TEMPORARY | __GFP_ZERO);
+	if (!tmp)
+		return -ENOMEM;
+
+	ret = task_cgroup_path(current, tmp, PAGE_SIZE);
+	if (ret >= 0)
+		ret = kdbus_meta_append_str(meta, KDBUS_ITEM_CGROUP, tmp);
+
+	free_page((unsigned long) tmp);
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_AUDITSYSCALL
+static int kdbus_meta_append_audit(struct kdbus_meta *meta)
+{
+	struct kdbus_audit audit;
+	const struct cred *cred;
+	uid_t uid;
+
+	rcu_read_lock();
+	cred = __task_cred(current);
+	uid = from_kuid(cred->user_ns, audit_get_loginuid(current));
+	rcu_read_unlock();
+
+	audit.loginuid = uid;
+	audit.sessionid = audit_get_sessionid(current);
+
+	return kdbus_meta_append_data(meta, KDBUS_ITEM_AUDIT,
+				      &audit, sizeof(struct kdbus_audit));
+}
+#endif
+
+#ifdef CONFIG_SECURITY
+static int kdbus_meta_append_seclabel(struct kdbus_meta *meta)
+{
+	u32 sid;
+	char *label;
+	u32 len;
+	int ret;
+
+	security_task_getsecid(current, &sid);
+	ret = security_secid_to_secctx(sid, &label, &len);
+	if (ret == -EOPNOTSUPP)
+		return 0;
+	if (ret < 0)
+		return ret;
+
+	if (label && len > 0)
+		ret = kdbus_meta_append_data(meta, KDBUS_ITEM_SECLABEL,
+					     label, len);
+	security_release_secctx(label, len);
+
+	return ret;
+}
+#endif
+
+/**
+ * kdbus_meta_append() - collect metadata from current process
+ * @meta:		Metadata object
+ * @conn:		Current connection to read names from
+ * @which:		KDBUS_ATTACH_* flags which typ of data to attach
+ *
+ * Collect the data specified in flags and allocate or extend
+ * the buffer in the metadata object.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_meta_append(struct kdbus_meta *meta,
+		      struct kdbus_conn *conn,
+		      u64 which)
+{
+	int ret = 0;
+
+	/* all metadata already added */
+	if ((which & meta->attached) == which)
+		return 0;
+
+	if (which & KDBUS_ATTACH_TIMESTAMP &&
+	    !(meta->attached & KDBUS_ATTACH_TIMESTAMP)) {
+		ret = kdbus_meta_append_timestamp(meta);
+		if (ret < 0)
+			goto exit;
+	}
+
+	if (which & KDBUS_ATTACH_CREDS &&
+	    !(meta->attached & KDBUS_ATTACH_CREDS)) {
+		ret = kdbus_meta_append_cred(meta);
+		if (ret < 0)
+			goto exit;
+	}
+
+	if (which & KDBUS_ATTACH_NAMES && conn &&
+	    !(meta->attached & KDBUS_ATTACH_NAMES)) {
+		ret = kdbus_meta_append_src_names(meta, conn);
+		if (ret < 0)
+			goto exit;
+	}
+
+	if (which & KDBUS_ATTACH_COMM &&
+	    !(meta->attached & KDBUS_ATTACH_COMM)) {
+		char comm[TASK_COMM_LEN];
+
+		get_task_comm(comm, current->group_leader);
+		ret = kdbus_meta_append_str(meta, KDBUS_ITEM_TID_COMM, comm);
+		if (ret < 0)
+			goto exit;
+
+		get_task_comm(comm, current);
+		ret = kdbus_meta_append_str(meta, KDBUS_ITEM_PID_COMM, comm);
+		if (ret < 0)
+			goto exit;
+	}
+
+	if (which & KDBUS_ATTACH_EXE &&
+	    !(meta->attached & KDBUS_ATTACH_EXE)) {
+
+		ret = kdbus_meta_append_exe(meta);
+		if (ret < 0)
+			goto exit;
+	}
+
+	if (which & KDBUS_ATTACH_CMDLINE &&
+	    !(meta->attached & KDBUS_ATTACH_CMDLINE)) {
+		ret = kdbus_meta_append_cmdline(meta);
+		if (ret < 0)
+			goto exit;
+	}
+
+	/* we always return a 4 elements, the element size is 1/4  */
+	if (which & KDBUS_ATTACH_CAPS &&
+	    !(meta->attached & KDBUS_ATTACH_CAPS)) {
+		ret = kdbus_meta_append_caps(meta);
+		if (ret < 0)
+			goto exit;
+	}
+
+#ifdef CONFIG_CGROUPS
+	/* attach the path of the one group hierarchy specified for the bus */
+	if (which & KDBUS_ATTACH_CGROUP &&
+	    !(meta->attached & KDBUS_ATTACH_CGROUP)) {
+		ret = kdbus_meta_append_cgroup(meta);
+		if (ret < 0)
+			goto exit;
+	}
+#endif
+
+#ifdef CONFIG_AUDITSYSCALL
+	if (which & KDBUS_ATTACH_AUDIT &&
+	    !(meta->attached & KDBUS_ATTACH_AUDIT)) {
+		ret = kdbus_meta_append_audit(meta);
+		if (ret < 0)
+			goto exit;
+	}
+#endif
+
+#ifdef CONFIG_SECURITY
+	if (which & KDBUS_ATTACH_SECLABEL &&
+	    !(meta->attached & KDBUS_ATTACH_SECLABEL)) {
+		ret = kdbus_meta_append_seclabel(meta);
+		if (ret < 0)
+			goto exit;
+	}
+#endif
+	/*
+	 * We tried to add everything we got asked for; do not get
+	 * here again for the same question.
+	 */
+	meta->attached |= which;
+
+exit:
+	return ret;
+}
diff --git a/drivers/kdbus/metadata.h b/drivers/kdbus/metadata.h
new file mode 100644
index 0000000..f3fdc46
--- /dev/null
+++ b/drivers/kdbus/metadata.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_METADATA_H
+#define __KDBUS_METADATA_H
+
+/**
+ * struct kdbus_meta - metadata buffer
+ * @attached:		Flags for already attached data
+ * @ns:			Namespace the metadata belongs to
+ * @data:		Allocated buffer
+ * @size:		Number of bytes used
+ * @allocated_size:	Size of buffer
+ *
+ * Used to collect and store connection metadata in a pre-compiled
+ * buffer containing struct kdbus_item.
+ */
+struct kdbus_meta {
+	u64 attached;
+	const struct pid_namespace *ns;
+	struct kdbus_item *data;
+	size_t size;
+	size_t allocated_size;
+};
+
+struct kdbus_conn;
+
+int kdbus_meta_new(struct kdbus_meta **meta);
+int kdbus_meta_append_data(struct kdbus_meta *meta, u64 type,
+			   const void *buf, size_t len);
+int kdbus_meta_append(struct kdbus_meta *meta,
+		      struct kdbus_conn *conn,
+		      u64 which);
+void kdbus_meta_free(struct kdbus_meta *meta);
+#endif
diff --git a/drivers/kdbus/names.c b/drivers/kdbus/names.c
new file mode 100644
index 0000000..af6c225
--- /dev/null
+++ b/drivers/kdbus/names.c
@@ -0,0 +1,866 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/hash.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "bus.h"
+#include "connection.h"
+#include "endpoint.h"
+#include "names.h"
+#include "notify.h"
+#include "policy.h"
+
+/**
+ * struct kdbus_name_queue_item - a queue item for a name
+ * @conn:		The associated connection
+ * @entry:		Name entry queuing up for
+ * @flags:		The queuing flags
+ * @entry_entry:	List element for the list in @entry
+ * @conn_entry:		List element for the list in @conn
+ */
+struct kdbus_name_queue_item {
+	struct kdbus_conn	*conn;
+	struct kdbus_name_entry	*entry;
+	u64			flags;
+	struct list_head	entry_entry;
+	struct list_head	conn_entry;
+};
+
+static void kdbus_name_entry_free(struct kdbus_name_entry *e)
+{
+	hash_del(&e->hentry);
+	kfree(e->name);
+	kfree(e);
+}
+
+/**
+ * kdbus_name_registry_free() - drop a name reg's reference
+ * @reg:		The name registry
+ *
+ * Cleanup the name registry's internal structures.
+ */
+void kdbus_name_registry_free(struct kdbus_name_registry *reg)
+{
+	struct kdbus_name_entry *e;
+	struct hlist_node *tmp;
+	unsigned int i;
+
+	mutex_lock(&reg->entries_lock);
+	hash_for_each_safe(reg->entries_hash, i, tmp, e, hentry)
+		kdbus_name_entry_free(e);
+	mutex_unlock(&reg->entries_lock);
+
+	kfree(reg);
+}
+
+/**
+ * kdbus_name_registry_new() - create a new name registry
+ * @reg:		The returned name registry
+ *
+ * Returns 0 on success, -ENOMEM if memory allocation failed.
+ */
+int kdbus_name_registry_new(struct kdbus_name_registry **reg)
+{
+	struct kdbus_name_registry *r;
+
+	r = kzalloc(sizeof(*r), GFP_KERNEL);
+	if (!r)
+		return -ENOMEM;
+
+	hash_init(r->entries_hash);
+	mutex_init(&r->entries_lock);
+	r->name_id_next = 1;
+
+	*reg = r;
+
+	return 0;
+}
+
+static struct kdbus_name_entry *
+__kdbus_name_lookup(struct kdbus_name_registry *reg,
+		    u32 hash, const char *name)
+{
+	struct kdbus_name_entry *e;
+
+	hash_for_each_possible(reg->entries_hash, e, hentry, hash)
+		if (strcmp(e->name, name) == 0)
+			return e;
+
+	return NULL;
+}
+
+static void kdbus_name_queue_item_free(struct kdbus_name_queue_item *q)
+{
+	list_del(&q->entry_entry);
+	list_del(&q->conn_entry);
+	kfree(q);
+}
+
+static void kdbus_name_entry_remove_owner(struct kdbus_name_entry *e)
+{
+	struct kdbus_conn *conn = e->conn;
+
+	BUG_ON(!e->conn);
+
+	mutex_lock(&conn->lock);
+	conn->names--;
+	list_del(&e->conn_entry);
+	mutex_unlock(&conn->lock);
+
+	kdbus_conn_unref(conn);
+	e->conn = NULL;
+}
+
+static void kdbus_name_entry_set_owner(struct kdbus_name_entry *e,
+				       struct kdbus_conn *conn)
+{
+	BUG_ON(e->conn);
+
+	mutex_lock(&conn->lock);
+	e->conn = kdbus_conn_ref(conn);
+	list_add_tail(&e->conn_entry, &e->conn->names_list);
+	conn->names++;
+	mutex_unlock(&conn->lock);
+}
+
+static int kdbus_name_entry_release(struct kdbus_name_entry *e,
+				     struct list_head *notify_list)
+{
+	struct kdbus_name_queue_item *q;
+
+	if (list_empty(&e->queue_list)) {
+		/* if the name has an activator connection, hand it back */
+		if (e->activator && e->activator != e->conn) {
+			u64 flags = KDBUS_NAME_ACTIVATOR;
+			int ret;
+
+			kdbus_notify_name_change(KDBUS_ITEM_NAME_CHANGE,
+						 e->conn->id, e->activator->id,
+						 e->flags, flags,
+						 e->name, notify_list);
+
+			/*
+			 * Move messages still queued in the old connection
+			 * and addressed to that name to the new connection.
+			 * This allows a race and loss-free name and message
+			 * takeover and exit-on-idle services.
+			 */
+			ret = kdbus_conn_move_messages(e->activator, e->conn,
+						       e->name_id);
+			if (ret < 0)
+				return ret;
+
+			e->flags = flags;
+			kdbus_name_entry_remove_owner(e);
+			kdbus_name_entry_set_owner(e, e->activator);
+
+			return 0;
+		}
+
+		/* release the name */
+		kdbus_notify_name_change(KDBUS_ITEM_NAME_REMOVE,
+					 e->conn->id, 0,
+					 e->flags, 0, e->name,
+					 notify_list);
+		kdbus_name_entry_remove_owner(e);
+		kdbus_name_entry_free(e);
+
+		return 0;
+	}
+
+	/* give it to first waiter in the queue */
+	q = list_first_entry(&e->queue_list,
+			     struct kdbus_name_queue_item,
+			     entry_entry);
+	kdbus_notify_name_change(KDBUS_ITEM_NAME_CHANGE,
+				 e->conn->id, q->conn->id,
+				 e->flags, q->flags, e->name, notify_list);
+	e->flags = q->flags;
+	kdbus_name_entry_remove_owner(e);
+	kdbus_name_entry_set_owner(e, q->conn);
+	kdbus_name_queue_item_free(q);
+
+	return 0;
+}
+
+static int kdbus_name_release(struct kdbus_name_entry *e,
+			      struct kdbus_conn *conn,
+			      struct list_head *notify_list)
+{
+	struct kdbus_name_queue_item *q_tmp, *q;
+
+	/* Is the connection already the real owner of the name? */
+	if (e->conn == conn)
+		return kdbus_name_entry_release(e, notify_list);
+
+	/*
+	 * Otherwise, walk the list of queued entries and search for
+	 * items for the connection.
+	 */
+	list_for_each_entry_safe(q, q_tmp, &e->queue_list, entry_entry) {
+		if (q->conn != conn)
+			continue;
+		kdbus_name_queue_item_free(q);
+		return 0;
+	}
+
+	/* the name belongs to somebody else */
+	return -EADDRINUSE;
+}
+
+/**
+ * kdbus_name_remove_by_conn() - remove all name entries of a given connection
+ * @reg:		The name registry
+ * @conn:		The connection which entries to remove
+ *
+ * This function removes all name entry held by a given connection.
+ */
+void kdbus_name_remove_by_conn(struct kdbus_name_registry *reg,
+			       struct kdbus_conn *conn)
+{
+	struct kdbus_name_entry *e_tmp, *e;
+	struct kdbus_name_queue_item *q_tmp, *q;
+	LIST_HEAD(notify_list);
+	LIST_HEAD(names_queue_list);
+	LIST_HEAD(names_list);
+
+	mutex_lock(&conn->lock);
+	list_splice_init(&conn->names_list, &names_list);
+	list_splice_init(&conn->names_queue_list, &names_queue_list);
+	mutex_unlock(&conn->lock);
+
+	mutex_lock(&reg->entries_lock);
+	list_for_each_entry_safe(q, q_tmp, &names_queue_list, conn_entry)
+		kdbus_name_queue_item_free(q);
+	list_for_each_entry_safe(e, e_tmp, &names_list, conn_entry)
+		kdbus_name_entry_release(e, &notify_list);
+	mutex_unlock(&reg->entries_lock);
+
+	kdbus_conn_kmsg_list_send(conn->ep, &notify_list);
+}
+
+/**
+ * kdbus_name_lookup() - look up a name in a name registry
+ * @reg:		The name registry
+ * @name:		The name to look up
+ *
+ * Returns the name entry, if found. Otherwise, NULL is returned.
+ */
+struct kdbus_name_entry *kdbus_name_lookup(struct kdbus_name_registry *reg,
+					   const char *name)
+{
+	struct kdbus_name_entry *e = NULL;
+	u32 hash = kdbus_str_hash(name);
+
+	mutex_lock(&reg->entries_lock);
+	e = __kdbus_name_lookup(reg, hash, name);
+	mutex_unlock(&reg->entries_lock);
+
+	return e;
+}
+
+static int kdbus_name_queue_conn(struct kdbus_conn *conn, u64 flags,
+				  struct kdbus_name_entry *e)
+{
+	struct kdbus_name_queue_item *q;
+
+	q = kzalloc(sizeof(*q), GFP_KERNEL);
+	if (!q)
+		return -ENOMEM;
+
+	q->conn = conn;
+	q->flags = flags;
+	q->entry = e;
+
+	list_add_tail(&q->entry_entry, &e->queue_list);
+	list_add_tail(&q->conn_entry, &conn->names_queue_list);
+
+	return 0;
+}
+
+/* called with entries_lock held */
+static int kdbus_name_replace_owner(struct kdbus_name_registry *reg,
+				    struct kdbus_conn *conn,
+				    struct kdbus_name_entry *e, u64 flags,
+				    struct list_head *notify_list)
+{
+	int ret;
+
+	ret = kdbus_notify_name_change(KDBUS_ITEM_NAME_CHANGE,
+				       e->conn->id, conn->id,
+				       e->flags, flags,
+				       e->name, notify_list);
+	if (ret < 0)
+		return ret;
+
+	/* hand over ownership */
+	kdbus_name_entry_remove_owner(e);
+	kdbus_name_entry_set_owner(e, conn);
+	e->flags = flags;
+
+	return 0;
+}
+
+/**
+ * kdbus_name_is_valid() - check if a name is value
+ * @p:			The name to check
+ *
+ * A name is valid if all of the following criterias are met:
+ *
+ *  - The name has one or more elements separated by a period ('.') character.
+ *    All elements must contain at least one character.
+ *  - Each element must only contain the ASCII characters "[A-Z][a-z][0-9]_"
+ *    and must not begin with a digit.
+ *  - The name must contain at least one '.' (period) character
+ *    (and thus at least two elements).
+ *  - The name must not begin with a '.' (period) character.
+ *  - The name must not exceed KDBUS_NAME_MAX_LEN.
+ */
+bool kdbus_name_is_valid(const char *p)
+{
+	const char *q;
+	bool dot, found_dot;
+
+	for (dot = true, q = p; *q; q++) {
+		if (*q == '.') {
+			if (dot)
+				return false;
+
+			found_dot = dot = true;
+		} else {
+			bool good;
+
+			good = isalpha(*q) || (!dot && isdigit(*q)) ||
+				*q == '_' || *q == '-';
+
+			if (!good)
+				return false;
+
+			dot = false;
+		}
+	}
+
+	if (q - p > KDBUS_NAME_MAX_LEN)
+		return false;
+
+	if (dot)
+		return false;
+
+	if (!found_dot)
+		return false;
+
+	return true;
+}
+
+/**
+ * kdbus_name_acquire() - acquire a name
+ * @reg:		The name registry
+ * @conn:		The connection to pin this entry to
+ * @name:		The name to acquire
+ * @flags:		Acquisition flags (KDBUS_NAME_*)
+ * @entry:		Return pointer for the entry (may be NULL)
+ *
+ * Returns 0 on success, other values on error.
+ */
+int kdbus_name_acquire(struct kdbus_name_registry *reg,
+		       struct kdbus_conn *conn,
+		       const char *name, u64 *flags,
+		       struct kdbus_name_entry **entry)
+{
+	struct kdbus_name_entry *e = NULL;
+	LIST_HEAD(notify_list);
+	int ret = 0;
+	u32 hash;
+
+	hash = kdbus_str_hash(name);
+
+	mutex_lock(&reg->entries_lock);
+	e = __kdbus_name_lookup(reg, hash, name);
+	if (e) {
+		/* connection already owns that name */
+		if (e->conn == conn) {
+			ret = -EALREADY;
+			goto exit_unlock;
+		}
+
+		/* an activator can only own a single name */
+		if (conn->flags & KDBUS_HELLO_ACTIVATOR) {
+			ret = -EALREADY;
+			goto exit_unlock;
+		}
+
+		/* take over the name of an activator connection */
+		if (e->flags & KDBUS_NAME_ACTIVATOR) {
+
+			/*
+			 * Take over the messages queued in the activator
+			 * connection, the activator itself never reads them.
+			 */
+			ret = kdbus_conn_move_messages(conn, e->activator, 0);
+			if (ret < 0)
+				goto exit_unlock;
+
+			ret = kdbus_name_replace_owner(reg, conn, e, *flags,
+						       &notify_list);
+			goto exit_unlock;
+		}
+
+		/* take over the name if both parties agree */
+		if ((*flags & KDBUS_NAME_REPLACE_EXISTING) &&
+		    (e->flags & KDBUS_NAME_ALLOW_REPLACEMENT)) {
+
+			/*
+			 * Move name back to the queue, in case we take it away
+			 * from a connection which asked for queuing.
+			 */
+			if (e->flags & KDBUS_NAME_QUEUE) {
+				ret = kdbus_name_queue_conn(e->conn,
+							    e->flags, e);
+				if (ret < 0)
+					goto exit_unlock;
+			}
+
+			ret = kdbus_name_replace_owner(reg, conn, e, *flags,
+						       &notify_list);
+			goto exit_unlock;
+		}
+
+		/* add it to the queue waiting for the name */
+		if (*flags & KDBUS_NAME_QUEUE) {
+			ret = kdbus_name_queue_conn(conn, *flags, e);
+
+			/* tell the caller that we queued it */
+			*flags |= KDBUS_NAME_IN_QUEUE;
+
+			goto exit_unlock;
+		}
+
+		/* the name is busy, return a failure */
+		ret = -EEXIST;
+		goto exit_unlock;
+	}
+
+	/* new name entry */
+	e = kzalloc(sizeof(*e), GFP_KERNEL);
+	if (!e) {
+		ret = -ENOMEM;
+		goto exit_unlock;
+	}
+
+	e->name = kstrdup(name, GFP_KERNEL);
+	if (!e->name) {
+		kfree(e);
+		ret = -ENOMEM;
+		goto exit_unlock;
+	}
+
+	if (conn->flags & KDBUS_HELLO_ACTIVATOR)
+		e->activator = kdbus_conn_ref(conn);
+
+	e->flags = *flags;
+	INIT_LIST_HEAD(&e->queue_list);
+	e->name_id = reg->name_id_next++;
+	hash_add(reg->entries_hash, &e->hentry, hash);
+	kdbus_name_entry_set_owner(e, conn);
+
+	kdbus_notify_name_change(KDBUS_ITEM_NAME_ADD,
+				 0, e->conn->id,
+				 0, e->flags, e->name,
+				 &notify_list);
+
+	if (entry)
+		*entry = e;
+
+exit_unlock:
+	mutex_unlock(&reg->entries_lock);
+	kdbus_conn_kmsg_list_send(conn->ep, &notify_list);
+
+	return ret;
+}
+
+/**
+ * kdbus_cmd_name_acquire() - acquire a name from a ioctl command buffer
+ * @reg:		The name registry
+ * @conn:		The connection to pin this entry to
+ * @buf:		The __user buffer as passed in by the ioctl
+ *
+ * Returns 0 on success, other values on error.
+ */
+int kdbus_cmd_name_acquire(struct kdbus_name_registry *reg,
+			   struct kdbus_conn *conn,
+			   void __user *buf)
+{
+	u64 allowed;
+	struct kdbus_name_entry *e = NULL;
+	struct kdbus_cmd_name *cmd_name;
+	LIST_HEAD(notify_list);
+	u64 size;
+	u32 hash;
+	int ret = 0;
+
+	if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_name))
+		return -EFAULT;
+
+	/* monitor connection may not own names */
+	if (conn->flags & KDBUS_HELLO_MONITOR)
+		return -EPERM;
+
+	if ((size < sizeof(struct kdbus_cmd_name)) ||
+	    (size > (sizeof(struct kdbus_cmd_name) + KDBUS_NAME_MAX_LEN + 1)))
+		return -EMSGSIZE;
+
+	if (conn->names > KDBUS_CONN_MAX_NAMES)
+		return -E2BIG;
+
+	cmd_name = memdup_user(buf, size);
+	if (IS_ERR(cmd_name))
+		return PTR_ERR(cmd_name);
+
+	/* refuse improper flags when requesting */
+	allowed = KDBUS_NAME_REPLACE_EXISTING|
+		  KDBUS_NAME_ALLOW_REPLACEMENT|
+		  KDBUS_NAME_QUEUE;
+	if ((cmd_name->flags & ~allowed) != 0)
+		return -EINVAL;
+
+	if (!kdbus_check_strlen(cmd_name, name) ||
+	    !kdbus_name_is_valid(cmd_name->name)) {
+		ret = -EINVAL;
+		goto exit_free;
+	}
+
+	/* privileged users can act on behalf of someone else */
+	if (cmd_name->owner_id != 0) {
+		struct kdbus_conn *new_conn;
+		struct kdbus_bus *bus = conn->ep->bus;
+
+		if (!kdbus_bus_uid_is_privileged(bus)) {
+			ret = -EPERM;
+			goto exit_free;
+		}
+
+		mutex_lock(&bus->lock);
+		new_conn = kdbus_bus_find_conn_by_id(bus, cmd_name->owner_id);
+		mutex_unlock(&bus->lock);
+
+		if (!new_conn) {
+			ret = -ENXIO;
+			goto exit_free;
+		}
+
+		conn = new_conn;
+	} else {
+		kdbus_conn_ref(conn);
+	}
+
+	hash = kdbus_str_hash(cmd_name->name);
+
+	if (conn->ep->policy_db) {
+		if (!kdbus_policy_db_check_own_access(conn->ep->policy_db,
+						      conn, cmd_name->name)) {
+			ret = -EPERM;
+			goto exit_unref_conn;
+		}
+	}
+
+	ret = kdbus_name_acquire(reg, conn, cmd_name->name,
+				 &cmd_name->flags, &e);
+	if (ret < 0)
+		goto exit_unref_conn;
+
+	/* return flags to the caller */
+	if (copy_to_user(buf, cmd_name, size)) {
+		ret = -EFAULT;
+		kdbus_conn_kmsg_list_free(&notify_list);
+		kdbus_name_entry_release(e, NULL);
+	}
+
+exit_unref_conn:
+	kdbus_conn_kmsg_list_send(conn->ep, &notify_list);
+	kdbus_conn_unref(conn);
+
+exit_free:
+	kfree(cmd_name);
+	return ret;
+}
+
+/**
+ * kdbus_cmd_name_release() - release a name entry from a ioctl command buffer
+ * @reg:		The name registry
+ * @conn:		The connection that holds the name
+ * @buf:		The __user buffer as passed in by the ioctl
+ *
+ * Returns 0 on success, other values on error.
+ */
+int kdbus_cmd_name_release(struct kdbus_name_registry *reg,
+			   struct kdbus_conn *conn,
+			   void __user *buf)
+{
+	struct kdbus_name_entry *e;
+	struct kdbus_cmd_name *cmd_name;
+	LIST_HEAD(notify_list);
+	u64 size;
+	u32 hash;
+	int ret = 0;
+
+	if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_name))
+		return -EFAULT;
+
+	if ((size < sizeof(struct kdbus_cmd_name)) ||
+	    (size > (sizeof(struct kdbus_cmd_name) + KDBUS_NAME_MAX_LEN + 1)))
+		return -EMSGSIZE;
+
+	cmd_name = memdup_user(buf, size);
+	if (IS_ERR(cmd_name))
+		return PTR_ERR(cmd_name);
+
+	if (!kdbus_name_is_valid(cmd_name->name)) {
+		ret = -EINVAL;
+		goto exit_free;
+	}
+
+	hash = kdbus_str_hash(cmd_name->name);
+
+	mutex_lock(&reg->entries_lock);
+	e = __kdbus_name_lookup(reg, hash, cmd_name->name);
+	if (!e) {
+		ret = -ESRCH;
+		conn = NULL;
+		goto exit_unlock;
+	}
+
+	/* privileged users can act on behalf of someone else */
+	if (cmd_name->owner_id > 0) {
+		struct kdbus_bus *bus = conn->ep->bus;
+
+		if (!kdbus_bus_uid_is_privileged(bus)) {
+			ret = -EPERM;
+			goto exit_unlock;
+		}
+
+		mutex_lock(&bus->lock);
+		conn = kdbus_bus_find_conn_by_id(bus, cmd_name->owner_id);
+		mutex_unlock(&bus->lock);
+
+		if (!conn) {
+			ret = -ENXIO;
+			goto exit_unlock;
+		}
+	} else {
+		kdbus_conn_ref(conn);
+	}
+
+	ret = kdbus_name_release(e, conn, &notify_list);
+
+exit_unlock:
+	mutex_unlock(&reg->entries_lock);
+
+	if (conn) {
+		kdbus_conn_kmsg_list_send(conn->ep, &notify_list);
+		kdbus_conn_unref(conn);
+	}
+
+exit_free:
+	kfree(cmd_name);
+	return ret;
+}
+
+static int kdbus_name_list_write(struct kdbus_conn *conn,
+				 struct kdbus_conn *c,
+				 size_t *pos,
+				 struct kdbus_name_entry *e,
+				 bool write)
+{
+	size_t p = *pos;
+	const size_t len = sizeof(struct kdbus_cmd_name);
+	size_t nlen = 0;
+	int ret = 0;
+
+	if (e)
+		nlen = strlen(e->name) + 1;
+
+	if (write) {
+		struct kdbus_cmd_name n = {
+			.size = len + nlen,
+			.owner_id = c->id,
+			.flags = e ? e->flags : 0,
+			.conn_flags = c->flags,
+		};
+
+		/* write record */
+		ret = kdbus_pool_write(conn->pool, p, &n, len);
+		if (ret < 0)
+			return ret;
+		p += len;
+
+		/* append name */
+		if (e) {
+			ret = kdbus_pool_write(conn->pool, p, e->name, nlen);
+			if (ret < 0)
+				return ret;
+			p += KDBUS_ALIGN8(nlen);
+		}
+	} else {
+		p += len + KDBUS_ALIGN8(nlen);
+	}
+
+	*pos = p;
+	return 0;
+}
+
+static int kdbus_name_list_all(struct kdbus_conn *conn, u64 flags,
+			       size_t *pos, bool write)
+{
+	struct kdbus_conn *c;
+	size_t p = *pos;
+	int ret, i;
+
+	hash_for_each(conn->ep->bus->conn_hash, i, c, hentry) {
+		bool added = false;
+
+		/* skip activators */
+		if (!(flags & KDBUS_NAME_LIST_ACTIVATORS) &&
+		    c->flags & KDBUS_HELLO_ACTIVATOR)
+			continue;
+
+		/* all names the connection owns */
+		if (flags & (KDBUS_NAME_LIST_NAMES |
+			     KDBUS_NAME_LIST_ACTIVATORS)) {
+			struct kdbus_name_entry *e;
+
+			list_for_each_entry(e, &c->names_list, conn_entry) {
+				struct kdbus_conn *a = e->activator;
+
+				if ((flags & KDBUS_NAME_LIST_ACTIVATORS) &&
+				    a && a != c) {
+					ret = kdbus_name_list_write(conn, a, &p,
+								    e, write);
+					if (ret < 0)
+						return ret;
+
+					added = true;
+				}
+
+				if (flags & KDBUS_NAME_LIST_NAMES ||
+				    c->flags & KDBUS_HELLO_ACTIVATOR) {
+					ret = kdbus_name_list_write(conn, c, &p,
+								    e, write);
+					if (ret < 0)
+						return ret;
+
+					added = true;
+				}
+			}
+		}
+
+		/* queue of names the connection is currently waiting for */
+		if (flags & KDBUS_NAME_LIST_QUEUED) {
+			struct kdbus_name_queue_item *q;
+
+			list_for_each_entry(q, &c->names_queue_list, conn_entry) {
+				ret = kdbus_name_list_write(conn, c, &p,
+							    q->entry, write);
+				if (ret < 0)
+					return ret;
+
+				added = true;
+			}
+		}
+
+		/* nothing added so far, just add the unique ID */
+		if (!added && flags & KDBUS_NAME_LIST_UNIQUE) {
+			ret = kdbus_name_list_write(conn, c, &p, NULL, write);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	*pos = p;
+	return 0;
+}
+
+/**
+ * kdbus_cmd_name_list() - list names of a connection
+ * @reg:		The name registry
+ * @conn:		The connection holding the name entries
+ * @buf:		The __user buffer as passed in by the ioctl
+ *
+ * Returns 0 on success, other values on error.
+ */
+int kdbus_cmd_name_list(struct kdbus_name_registry *reg,
+			struct kdbus_conn *conn,
+			void __user *buf)
+{
+	struct kdbus_cmd_name_list *cmd_list;
+	struct kdbus_name_list list = {};
+	size_t size;
+	size_t off, pos;
+	int ret;
+
+	cmd_list = memdup_user(buf, sizeof(struct kdbus_cmd_name_list));
+	if (IS_ERR(cmd_list))
+		return PTR_ERR(cmd_list);
+
+	mutex_lock(&conn->ep->bus->lock);
+	mutex_lock(&reg->entries_lock);
+
+	/* size of header */
+	size = sizeof(struct kdbus_name_list);
+
+	/* size of records */
+	ret = kdbus_name_list_all(conn, cmd_list->flags, &size, false);
+	if (ret < 0)
+		goto exit_unlock;
+
+	ret = kdbus_pool_alloc_range(conn->pool, size, &off);
+	if (ret < 0)
+		goto exit_unlock;
+
+	/* copy header */
+	pos = off;
+	list.size = size;
+
+	ret = kdbus_pool_write(conn->pool, pos,
+			       &list, sizeof(struct kdbus_name_list));
+	if (ret < 0)
+		goto exit_pool_free;
+	pos += sizeof(struct kdbus_name_list);
+
+	/* copy data */
+	ret = kdbus_name_list_all(conn, cmd_list->flags, &pos, true);
+	if (ret < 0)
+		goto exit_pool_free;
+
+	/* return allocated data */
+	if (kdbus_offset_set_user(&off, buf, struct kdbus_cmd_name_list))
+		ret = -EFAULT;
+
+exit_pool_free:
+	if (ret < 0)
+		kdbus_pool_free_range(conn->pool, off);
+exit_unlock:
+	mutex_unlock(&reg->entries_lock);
+	mutex_unlock(&conn->ep->bus->lock);
+	kfree(cmd_list);
+
+	return ret;
+}
diff --git a/drivers/kdbus/names.h b/drivers/kdbus/names.h
new file mode 100644
index 0000000..0dbb63d
--- /dev/null
+++ b/drivers/kdbus/names.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_NAMES_H
+#define __KDBUS_NAMES_H
+
+#include <linux/hashtable.h>
+
+/**
+ * struct kdbus_name_registry - names registered for a bus
+ * @entries_hash:	Map of entries
+ * @entries_lock:	Registry data lock
+ * @name_id_next:	Next sequence number to assign to a name entry
+ */
+struct kdbus_name_registry {
+	DECLARE_HASHTABLE(entries_hash, 6);
+	struct mutex		entries_lock;
+	u64 name_id_next;
+};
+
+/**
+ * struct kdbus_name_entry - well-know name entry
+ * @name:		The well-known name
+ * @name_id:		Sequence number of name entry to be able to uniquely
+ *			identify a name over its registration lifetime
+ * @flags:		KDBUS_NAME_* flags
+ * @queue_list:		List of queued waiters for the well-known name
+ * @conn_entry:		Entry in connection
+ * @hentry:		Entry in registry map
+ * @conn:		Connection owning the name
+ * @activator:		Connection of the activator queuing incoming messages
+ */
+struct kdbus_name_entry {
+	char			*name;
+	u64			name_id;
+	u64			flags;
+	struct list_head	queue_list;
+	struct list_head	conn_entry;
+	struct hlist_node	hentry;
+	struct kdbus_conn	*conn;
+	struct kdbus_conn	*activator;
+};
+
+int kdbus_name_registry_new(struct kdbus_name_registry **reg);
+void kdbus_name_registry_free(struct kdbus_name_registry *reg);
+
+int kdbus_name_acquire(struct kdbus_name_registry *reg,
+		       struct kdbus_conn *conn,
+		       const char *name, u64 *flags,
+		       struct kdbus_name_entry **entry);
+int kdbus_cmd_name_acquire(struct kdbus_name_registry *reg,
+			   struct kdbus_conn *conn,
+			   void __user *buf);
+int kdbus_cmd_name_release(struct kdbus_name_registry *reg,
+			   struct kdbus_conn *conn,
+			   void __user *buf);
+int kdbus_cmd_name_list(struct kdbus_name_registry *reg,
+			struct kdbus_conn *conn,
+			void __user *buf);
+
+struct kdbus_name_entry *kdbus_name_lookup(struct kdbus_name_registry *reg,
+					   const char *name);
+void kdbus_name_remove_by_conn(struct kdbus_name_registry *reg,
+			       struct kdbus_conn *conn);
+
+bool kdbus_name_is_valid(const char *p);
+#endif
diff --git a/drivers/kdbus/namespace.c b/drivers/kdbus/namespace.c
new file mode 100644
index 0000000..a9aa379
--- /dev/null
+++ b/drivers/kdbus/namespace.c
@@ -0,0 +1,392 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "bus.h"
+#include "handle.h"
+#include "internal.h"
+#include "namespace.h"
+
+/* map of majors to namespaces */
+static DEFINE_IDR(kdbus_ns_major_idr);
+
+/* next namespace id sequence number */
+static u64 kdbus_ns_id_next;
+
+/* kdbus initial namespace */
+struct kdbus_ns *kdbus_ns_init;
+
+/* kdbus subsystem lock */
+static DEFINE_MUTEX(kdbus_subsys_lock);
+
+/* kdbus sysfs subsystem */
+struct bus_type kdbus_subsys = {
+	.name = KBUILD_MODNAME,
+};
+
+/* control nodes are world accessible */
+static char *kdbus_devnode_control(struct device *dev, umode_t *mode,
+				   kuid_t *uid, kgid_t *gid)
+{
+	struct kdbus_ns *ns = dev_get_drvdata(dev);
+
+	if (mode)
+		*mode = ns->mode;
+
+	return NULL;
+}
+
+static void kdbus_dev_release(struct device *dev)
+{
+	kfree(dev);
+}
+
+static struct device_type kdbus_devtype_control = {
+	.name		= "control",
+	.release	= kdbus_dev_release,
+	.devnode	= kdbus_devnode_control,
+};
+
+/**
+ * kdbus_ns_ref() - take a namespace reference
+ * @ns	:		Namespace
+ *
+ * Returns: the namespace itself
+ */
+struct kdbus_ns *kdbus_ns_ref(struct kdbus_ns *ns)
+{
+	kref_get(&ns->kref);
+	return ns;
+}
+
+/**
+ * kdbus_ns_disconnect() - invalidate a namespace
+ * @ns	:		Namespace
+ */
+void kdbus_ns_disconnect(struct kdbus_ns *ns)
+{
+	struct kdbus_bus *bus, *tmp;
+
+	mutex_lock(&ns->lock);
+	if (ns->disconnected) {
+		mutex_unlock(&ns->lock);
+		return;
+	}
+
+	ns->disconnected = true;
+	mutex_unlock(&ns->lock);
+
+	mutex_lock(&kdbus_subsys_lock);
+	if (ns->parent)
+		list_del(&ns->ns_entry);
+	mutex_unlock(&kdbus_subsys_lock);
+
+	/* remove any buses attached to this endpoint */
+	list_for_each_entry_safe(bus, tmp, &ns->bus_list, ns_entry) {
+		kdbus_bus_disconnect(bus);
+		kdbus_bus_unref(bus);
+	}
+
+	if (ns->dev) {
+		device_unregister(ns->dev);
+		ns->dev = NULL;
+	}
+	if (ns->major > 0) {
+		idr_remove(&kdbus_ns_major_idr, ns->major);
+		unregister_chrdev(ns->major, KBUILD_MODNAME);
+		ns->major = 0;
+	}
+}
+
+static void __kdbus_ns_free(struct kref *kref)
+{
+	struct kdbus_ns *ns = container_of(kref, struct kdbus_ns, kref);
+
+	kdbus_ns_disconnect(ns);
+	kdbus_ns_unref(ns->parent);
+	kfree(ns->name);
+	kfree(ns->devpath);
+	kfree(ns);
+}
+
+/**
+ * kdbus_ns_unref() - drop a namespace reference
+ * @ns	:		Namespace
+ *
+ * When the last reference is dropped, the namespace internal structure
+ * is freed.
+ *
+ * Returns: NULL
+ */
+struct kdbus_ns *kdbus_ns_unref(struct kdbus_ns *ns)
+{
+	if (!ns)
+		return NULL;
+
+	kref_put(&ns->kref, __kdbus_ns_free);
+	return NULL;
+}
+
+static struct kdbus_ns *kdbus_ns_find(struct kdbus_ns const *parent,
+				      const char *name)
+{
+	struct kdbus_ns *ns = NULL;
+	struct kdbus_ns *n;
+
+	list_for_each_entry(n, &parent->ns_list, ns_entry) {
+		if (strcmp(n->name, name))
+			continue;
+
+		ns = kdbus_ns_ref(n);
+		break;
+	}
+
+	return ns;
+}
+
+/**
+ * kdbus_ns_find_by_major() - lookup a namespace by its major device number
+ * @major:		Major number
+ *
+ * Looks up a namespace by major number. The returned namspace
+ * is ref'ed, and needs to be unref'ed by the user. Returns NULL if
+ * the namepace can't be found.
+ *
+ * Returns: the namespace, or NULL if not found
+ */
+struct kdbus_ns *kdbus_ns_find_by_major(unsigned int major)
+{
+	struct kdbus_ns *ns;
+
+	mutex_lock(&kdbus_subsys_lock);
+	ns = idr_find(&kdbus_ns_major_idr, major);
+	if (ns)
+		kdbus_ns_ref(ns);
+	mutex_unlock(&kdbus_subsys_lock);
+
+	return ns;
+}
+
+/**
+ * kdbus_ns_new() - create a new namespace
+ * @parent:		Parent namespace, NULL for initial one
+ * @name:		Name of the namespace, NULL for the initial one
+ * @mode:		The access mode for the "control" device node
+ * @ns:			The returned namespace
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_ns_new(struct kdbus_ns *parent, const char *name, umode_t mode,
+		 struct kdbus_ns **ns)
+{
+	struct kdbus_ns *n;
+	int ret;
+
+	BUG_ON(*ns);
+
+	if ((parent && !name) || (!parent && name))
+		return -EINVAL;
+
+	n = kzalloc(sizeof(struct kdbus_ns), GFP_KERNEL);
+	if (!n)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&n->bus_list);
+	INIT_LIST_HEAD(&n->ns_list);
+	kref_init(&n->kref);
+	n->mode = mode;
+	idr_init(&n->idr);
+	mutex_init(&n->lock);
+
+	mutex_lock(&kdbus_subsys_lock);
+
+	/* compose name and path of base directory in /dev */
+	if (!parent) {
+		/* initial namespace */
+		n->devpath = kstrdup(KBUILD_MODNAME, GFP_KERNEL);
+		if (!n->devpath) {
+			ret = -ENOMEM;
+			goto exit_unlock;
+		}
+	} else {
+		struct kdbus_ns *exists;
+
+		exists = kdbus_ns_find(parent, name);
+		if (exists) {
+			kdbus_ns_unref(exists);
+			ret = -EEXIST;
+			goto exit_unlock;
+		}
+
+		n->devpath = kasprintf(GFP_KERNEL, "%s/ns/%s",
+				       parent->devpath, name);
+		if (!n->devpath) {
+			ret = -ENOMEM;
+			goto exit_unlock;
+		}
+
+		n->name = kstrdup(name, GFP_KERNEL);
+		if (!n->name) {
+			ret = -ENOMEM;
+			goto exit_unlock;
+		}
+	}
+
+	/* get dynamic major */
+	ret = register_chrdev(0, KBUILD_MODNAME, &kdbus_device_ops);
+	if (ret < 0)
+		goto exit_unlock;
+
+	n->major = ret;
+
+	/*
+	 * kdbus_device_ops' dev_t finds the namespace in the major map,
+	 * and the bus in the minor map of that namespace
+	 */
+	ret = idr_alloc(&kdbus_ns_major_idr, n, n->major, 0, GFP_KERNEL);
+	if (ret < 0) {
+		if (ret == -ENOSPC)
+			ret = -EEXIST;
+		goto exit_unlock;
+	}
+
+	/* get id for this namespace */
+	n->id = kdbus_ns_id_next++;
+
+	/* register control device for this namespace */
+	n->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
+	if (!n->dev) {
+		ret = -ENOMEM;
+		goto exit_unlock;
+	}
+
+	dev_set_name(n->dev, "%s/%s", n->devpath, "control");
+	n->dev->bus = &kdbus_subsys;
+	n->dev->type = &kdbus_devtype_control;
+	n->dev->devt = MKDEV(n->major, 0);
+	dev_set_drvdata(n->dev, n);
+	ret = device_register(n->dev);
+	if (ret < 0) {
+		put_device(n->dev);
+		n->dev = NULL;
+		goto exit_unlock;
+	}
+
+	/* link into parent namespace */
+	if (parent) {
+		n->parent = kdbus_ns_ref(parent);
+		list_add_tail(&n->ns_entry, &parent->ns_list);
+	}
+	mutex_unlock(&kdbus_subsys_lock);
+
+	*ns = n;
+	return 0;
+
+exit_unlock:
+	mutex_unlock(&kdbus_subsys_lock);
+	kdbus_ns_unref(n);
+	return ret;
+}
+
+/**
+ * kdbus_ns_make_user() - create namespace data from user data
+ * @buf:		User data
+ * @make:		The returned copy of user data
+ * @name:		The name of the namespace to create
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_ns_make_user(void __user *buf,
+		       struct kdbus_cmd_make **make, char **name)
+{
+	u64 size;
+	struct kdbus_cmd_make *m;
+	const struct kdbus_item *item;
+	const char *n = NULL;
+	int ret;
+
+	if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_make))
+		return -EFAULT;
+
+	if (size < sizeof(struct kdbus_cmd_make) || size > KDBUS_MAKE_MAX_SIZE)
+		return -EMSGSIZE;
+
+	m = memdup_user(buf, size);
+	if (IS_ERR(m))
+		return PTR_ERR(m);
+
+	KDBUS_ITEM_FOREACH(item, m, items) {
+		size_t payload_size;
+
+		if (!KDBUS_ITEM_VALID(item, m)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		payload_size = item->size - KDBUS_ITEM_HEADER_SIZE;
+
+		switch (item->type) {
+		case KDBUS_ITEM_MAKE_NAME:
+			if (n) {
+				ret = -EEXIST;
+				goto exit;
+			}
+
+			if (payload_size < 2) {
+				ret = -EINVAL;
+				goto exit;
+			}
+
+			if (payload_size > KDBUS_MAKE_MAX_LEN + 1) {
+				ret = -ENAMETOOLONG;
+				goto exit;
+			}
+
+			if (!kdbus_validate_nul(item->str, payload_size)) {
+				ret = -EINVAL;
+				goto exit;
+			}
+
+			n = item->str;
+			continue;
+
+		default:
+			ret = -ENOTSUPP;
+			goto exit;
+		}
+	}
+
+	if (!KDBUS_ITEM_END(item, m))
+		return -EINVAL;
+
+	if (!name) {
+		ret = -EBADMSG;
+		goto exit;
+	}
+
+	*make = m;
+	*name = (char *)n;
+	return 0;
+
+exit:
+	kfree(m);
+	return ret;
+}
diff --git a/drivers/kdbus/namespace.h b/drivers/kdbus/namespace.h
new file mode 100644
index 0000000..93ff21b
--- /dev/null
+++ b/drivers/kdbus/namespace.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_NS_H
+#define __KDBUS_NS_H
+
+/**
+ * struct kdbus_namespace - namespace for buses
+ * @kref:		Reference counter
+ * @disconnected:	Invalidated data
+ * @name:		Name of the namespace
+ * @parent:		Parent namespace
+ * @ns_list:		List of child namespaces
+ * @id:			Global id of this namespace
+ * @devpath:		/dev base directory path
+ * @major:		Device major number for all nodes
+ * @mode:		Device node access mode
+ * @idr:		Map of endpoint minors to buses
+ * @dev:		Control device node, minor == 0
+ * @lock:		Namespace data lock
+ * @bus_id_next:	Next bus id sequence number
+ * @ns_entry:		Entry in parent namespace
+ * @bus_list:		Buses in this namespace
+ *
+ * A namespace provides a "control" device node. Every namespace has its
+ * own major number for its endpoint device nodes.
+ *
+ * The initial namespace is created at initialization time, is unnamed and
+ * stays around for forver.
+ *
+ * A namespace is created by opening the "control" device node of the
+ * parent namespace and issuing the KDBUS_CMD_NS_MAKE iotcl. Closing this
+ * file immediately destroys the entire namespace.
+ */
+struct kdbus_ns {
+	struct kref kref;
+	bool disconnected;
+	const char *name;
+	struct kdbus_ns *parent;
+	struct list_head ns_list;
+	u64 id;
+	const char *devpath;
+	unsigned int major;
+	umode_t mode;
+	struct idr idr;
+	struct device *dev;
+	struct mutex lock;
+	u64 bus_id_next;
+	struct list_head ns_entry;
+	struct list_head bus_list;
+};
+
+extern struct kdbus_ns *kdbus_ns_init;
+extern struct bus_type kdbus_subsys;
+
+struct kdbus_ns *kdbus_ns_ref(struct kdbus_ns *ns);
+struct kdbus_ns *kdbus_ns_unref(struct kdbus_ns *ns);
+void kdbus_ns_disconnect(struct kdbus_ns *ns);
+int kdbus_ns_new(struct kdbus_ns *parent, const char *name,
+		 umode_t mode, struct kdbus_ns **ns);
+int kdbus_ns_make_user(void __user *buf,
+		       struct kdbus_cmd_make **make, char **name);
+struct kdbus_ns *kdbus_ns_find_by_major(unsigned int major);
+#endif
diff --git a/drivers/kdbus/notify.c b/drivers/kdbus/notify.c
new file mode 100644
index 0000000..5bcd02a
--- /dev/null
+++ b/drivers/kdbus/notify.c
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include "message.h"
+#include "notify.h"
+
+static int kdbus_notify_reply(u64 id, u64 cookie, u64 msg_type,
+			      struct list_head *queue_list)
+{
+	struct kdbus_kmsg *kmsg = NULL;
+	int ret;
+
+	BUG_ON(id == 0);
+
+	ret = kdbus_kmsg_new(0, &kmsg);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * a kernel-generated notification can only contain one
+	 * struct kdbus_item, so make a shortcut here for
+	 * faster lookup in the match db.
+	 */
+	kmsg->notify_type = msg_type;
+	kmsg->msg.dst_id = id;
+	kmsg->msg.src_id = KDBUS_SRC_ID_KERNEL;
+	kmsg->msg.payload_type = KDBUS_PAYLOAD_KERNEL;
+	kmsg->msg.cookie_reply = cookie;
+	kmsg->msg.items[0].type = msg_type;
+
+	list_add_tail(&kmsg->queue_entry, queue_list);
+	return ret;
+}
+
+/**
+ * kdbus_notify_reply_timeout() - queue a timeout reply
+ * @id:			The destination's connection ID
+ * @cookie:		The cookie to set in the reply.
+ * @queue_list:		A queue list for the newly generated kdbus_kmsg.
+ *			The caller has to free all items in the list using
+ *			kdbus_kmsg_free(). Maybe NULL, in which case this
+ *			function does nothing.
+ *
+ * Queues a message that has a KDBUS_ITEM_REPLY_TIMEOUT item attached.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_notify_reply_timeout(u64 id, u64 cookie, struct list_head *queue_list)
+{
+	return kdbus_notify_reply(id, cookie, KDBUS_ITEM_REPLY_TIMEOUT,
+				  queue_list);
+}
+
+/**
+ * kdbus_notify_reply_dead() - queue a 'dead' reply
+ * @id:			The destination's connection ID
+ * @cookie:		The cookie to set in the reply.
+ * @queue_list:		A queue list for the newly generated kdbus_kmsg.
+ *			The caller has to free all items in the list using
+ *			kdbus_kmsg_free(). Maybe NULL, in which case this
+ *			function does nothing.
+ *
+ * Queues a message that has a KDBUS_ITEM_REPLY_DEAD item attached.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_notify_reply_dead(u64 id, u64 cookie, struct list_head *queue_list)
+{
+	return kdbus_notify_reply(id, cookie, KDBUS_ITEM_REPLY_DEAD,
+				  queue_list);
+}
+
+/**
+ * kdbus_notify_name_change() - queue a notification about a name owner change
+ * @type:		The type if the notification; KDBUS_ITEM_NAME_ADD,
+ *			KDBUS_ITEM_NAME_CHANGE or KDBUS_ITEM_NAME_REMOVE
+ * @old_id:		The id of the connection that used to own the name
+ * @new_id:		The id of the new owner connection
+ * @old_flags:		The flags to pass in the KDBUS_ITEM flags field for
+ *			the old owner
+ * @new_flags:		The flags to pass in the KDBUS_ITEM flags field for
+ *			the new owner
+ * @name:		The name that was removed or assigned to a new owner
+ * @queue_list:		A queue list for the newly generated kdbus_kmsg.
+ *			The caller has to free all items in the list using
+ *			kdbus_kmsg_free(). Maybe NULL, in which case this
+ *			function does nothing.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_notify_name_change(u64 type,
+			     u64 old_id, u64 new_id,
+			     u64 old_flags, u64 new_flags,
+			     const char *name,
+			     struct list_head *queue_list)
+{
+	struct kdbus_kmsg *kmsg = NULL;
+	size_t name_len;
+	size_t extra_size;
+	int ret;
+
+	if (!queue_list)
+		return 0;
+
+	name_len = strlen(name) + 1;
+	extra_size = sizeof(struct kdbus_notify_name_change) + name_len;
+	ret = kdbus_kmsg_new(extra_size, &kmsg);
+	if (ret < 0)
+		return ret;
+
+	kmsg->msg.dst_id = KDBUS_DST_ID_BROADCAST;
+	kmsg->msg.src_id = KDBUS_SRC_ID_KERNEL;
+	kmsg->notify_type = type;
+	kmsg->notify_old_id = old_id;
+	kmsg->notify_new_id = new_id;
+	kmsg->msg.items[0].type = type;
+	kmsg->msg.items[0].name_change.old.id = old_id;
+	kmsg->msg.items[0].name_change.old.flags = old_flags;
+	kmsg->msg.items[0].name_change.new.id = new_id;
+	kmsg->msg.items[0].name_change.new.flags = new_flags;
+	memcpy(kmsg->msg.items[0].name_change.name, name, name_len);
+	kmsg->notify_name = kmsg->msg.items[0].name_change.name;
+
+	list_add_tail(&kmsg->queue_entry, queue_list);
+	return ret;
+}
+
+/**
+ * kdbus_notify_id_change() - queue a notification about a unique ID change
+ * @type:		The type if the notification; KDBUS_ITEM_ID_ADD or
+ *			KDBUS_ITEM_ID_REMOVE
+ * @id:			The id of the connection that was added or removed
+ * @flags:		The flags to pass in the KDBUS_ITEM flags field
+ * @queue_list:		A queue list for the newly generated kdbus_kmsg.
+ *			The caller has to free all items in the list using
+ *			kdbus_kmsg_free(). Maybe NULL, in which case this
+ *			function does nothing.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_notify_id_change(u64 type, u64 id, u64 flags,
+			   struct list_head *queue_list)
+{
+	struct kdbus_kmsg *kmsg = NULL;
+	int ret;
+
+	ret = kdbus_kmsg_new(sizeof(struct kdbus_notify_id_change), &kmsg);
+	if (ret < 0)
+		return ret;
+
+	kmsg->msg.dst_id = KDBUS_DST_ID_BROADCAST;
+	kmsg->msg.src_id = KDBUS_SRC_ID_KERNEL;
+	kmsg->notify_type = type;
+
+	switch (type) {
+	case KDBUS_ITEM_ID_ADD:
+		kmsg->notify_new_id = id;
+		break;
+
+	case KDBUS_ITEM_ID_REMOVE:
+		kmsg->notify_old_id = id;
+		break;
+
+	default:
+		BUG();
+	}
+
+	kmsg->msg.items[0].type = type;
+	kmsg->msg.items[0].id_change.id = id;
+	kmsg->msg.items[0].id_change.flags = flags;
+
+	list_add_tail(&kmsg->queue_entry, queue_list);
+	return ret;
+}
diff --git a/drivers/kdbus/notify.h b/drivers/kdbus/notify.h
new file mode 100644
index 0000000..890e51f
--- /dev/null
+++ b/drivers/kdbus/notify.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_NOTIFY_H
+#define __KDBUS_NOTIFY_H
+
+int kdbus_notify_id_change(u64 type, u64 id, u64 flags,
+			   struct list_head *queue_list);
+int kdbus_notify_reply_timeout(u64 id, u64 cookie,
+			       struct list_head *queue_list);
+int kdbus_notify_reply_dead(u64 id, u64 cookie,
+			    struct list_head *queue_list);
+int kdbus_notify_name_change(u64 type,
+			     u64 old_id, u64 new_id,
+			     u64 old_flags, u64 new_flags,
+			     const char *name,
+			     struct list_head *queue_list);
+#endif
diff --git a/drivers/kdbus/policy.c b/drivers/kdbus/policy.c
new file mode 100644
index 0000000..e27f93f
--- /dev/null
+++ b/drivers/kdbus/policy.c
@@ -0,0 +1,465 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "connection.h"
+#include "names.h"
+#include "policy.h"
+
+#define KDBUS_POLICY_HASH_SIZE	64
+
+/**
+ * struct kdbus_policy_db - policy database
+ * @entries_hash:	Hashtable of entries
+ * @send_access_hash:	Hashtable of send access elements
+ * @entries_lock:	Mutex to protect the database's access entries
+ * @cache_lock:		Mutex to protect the database's cache
+ */
+struct kdbus_policy_db {
+	DECLARE_HASHTABLE(entries_hash, 6);
+	DECLARE_HASHTABLE(send_access_hash, 6);
+	struct mutex		entries_lock;
+	struct mutex		cache_lock;
+};
+
+/**
+ * struct kdbus_policy_db_cache_entry - a cached entry
+ * @conn_a:		Connection A
+ * @conn_b:		Connection B
+ * @hentry:		The hash table entry for the database's entries_hash
+ */
+struct kdbus_policy_db_cache_entry {
+	struct kdbus_conn	*conn_a;
+	struct kdbus_conn	*conn_b;
+	struct hlist_node	hentry;
+};
+
+/**
+ * struct kdbus_policy_db_entry_access - a database entry access item
+ * @type:		One of KDBUS_POLICY_ACCESS_* types
+ * @bits:		Access to grant. One of KDBUS_POLICY_*
+ * @id:			For KDBUS_POLICY_ACCESS_USER, the uid
+ *			For KDBUS_POLICY_ACCESS_GROUP, the gid
+ * @list:		List entry item for the entry's list
+ *
+ * This is the internal version of struct kdbus_policy_access.
+ */
+struct kdbus_policy_db_entry_access {
+	u8			type;	/* USER, GROUP, WORLD */
+	u8			bits;	/* RECV, SEND, OWN */
+	u64			id;	/* uid, gid, 0 */
+	struct list_head	list;
+};
+
+/**
+ * struct kdbus_policy_db_entry - a policy database entry
+ * @name:		The name to match the policy entry against
+ * @hentry:		The hash entry for the database's entries_hash
+ * @access_list:	List head for keeping tracks of the entry's
+ *			access items.
+ */
+struct kdbus_policy_db_entry {
+	char			*name;
+	struct hlist_node	hentry;
+	struct list_head	access_list;
+};
+
+/**
+ * kdbus_policy_db_free - drop a policy database reference
+ * @db:		The policy database
+ */
+void kdbus_policy_db_free(struct kdbus_policy_db *db)
+{
+	struct kdbus_policy_db_entry *e;
+	struct kdbus_policy_db_cache_entry *ce;
+	struct hlist_node *tmp;
+	unsigned int i;
+
+	/* purge entries */
+	mutex_lock(&db->entries_lock);
+	hash_for_each_safe(db->entries_hash, i, tmp, e, hentry) {
+		struct kdbus_policy_db_entry_access *a, *tmp;
+
+		list_for_each_entry_safe(a, tmp, &e->access_list, list) {
+			list_del(&a->list);
+			kfree(a);
+		}
+
+		hash_del(&e->hentry);
+		kfree(e->name);
+		kfree(e);
+	}
+	mutex_unlock(&db->entries_lock);
+
+	/* purge cache */
+	mutex_lock(&db->cache_lock);
+	hash_for_each_safe(db->send_access_hash, i, tmp, ce, hentry) {
+		hash_del(&ce->hentry);
+		kfree(ce);
+	}
+	mutex_unlock(&db->cache_lock);
+
+	kfree(db);
+}
+
+/**
+ * kdbus_policy_db_new() - create a new policy database
+ * @db:		The location where to store the new database
+ *
+ * Return 0 on success, or any other value in case of errors.
+ */
+int kdbus_policy_db_new(struct kdbus_policy_db **db)
+{
+	struct kdbus_policy_db *d;
+
+	BUG_ON(*db);
+
+	d = kzalloc(sizeof(*d), GFP_KERNEL);
+	if (!d)
+		return -ENOMEM;
+
+	hash_init(d->entries_hash);
+	hash_init(d->send_access_hash);
+	mutex_init(&d->entries_lock);
+	mutex_init(&d->cache_lock);
+
+	*db = d;
+
+	return 0;
+}
+
+static u64 kdbus_collect_entry_accesses(struct kdbus_policy_db_entry *db_entry,
+					struct kdbus_conn *conn)
+{
+	struct kdbus_policy_db_entry_access *a;
+	u64 uid = from_kuid(current_user_ns(), current_uid());
+	u64 gid = from_kgid(current_user_ns(), current_gid());
+	u64 access = 0;
+
+	list_for_each_entry(a, &db_entry->access_list, list) {
+		switch (a->type) {
+		case KDBUS_POLICY_ACCESS_USER:
+			if (uid == a->id)
+				access |= a->bits;
+			break;
+		case KDBUS_POLICY_ACCESS_GROUP:
+			if (gid == a->id)
+				access |= a->bits;
+			break;
+		case KDBUS_POLICY_ACCESS_WORLD:
+			access |= a->bits;
+			break;
+		}
+	}
+
+	return access;
+}
+
+static int __kdbus_policy_db_check_send_access(struct kdbus_policy_db *db,
+					       struct kdbus_conn *conn_src,
+					       struct kdbus_conn *conn_dst)
+{
+	struct kdbus_name_entry *name_entry;
+	struct kdbus_policy_db_entry *db_entry;
+	u64 access;
+	u32 hash;
+	int ret = -EPERM;
+
+	/*
+	 * Send access is granted if either the source connection has a
+	 * matching SEND rule or the receiver connection has a matching
+	 * RECV rule.
+	 * Hence, we walk the list of the names registered for each
+	 * connection.
+	 */
+	mutex_lock(&conn_src->lock);
+	list_for_each_entry(name_entry, &conn_src->names_list, conn_entry) {
+		hash = kdbus_str_hash(name_entry->name);
+		hash_for_each_possible(db->entries_hash, db_entry, hentry, hash) {
+			if (strcmp(db_entry->name, name_entry->name) != 0)
+				continue;
+
+			access = kdbus_collect_entry_accesses(db_entry, conn_src);
+			if (access & KDBUS_POLICY_SEND) {
+				ret = 0;
+				break;
+			}
+		}
+	}
+	mutex_unlock(&conn_src->lock);
+
+	if (ret == 0)
+		return 0;
+
+	mutex_lock(&conn_dst->lock);
+	list_for_each_entry(name_entry, &conn_dst->names_list, conn_entry) {
+		hash = kdbus_str_hash(name_entry->name);
+		hash_for_each_possible(db->entries_hash, db_entry, hentry, hash) {
+			if (strcmp(db_entry->name, name_entry->name) != 0)
+				continue;
+
+			access = kdbus_collect_entry_accesses(db_entry, conn_dst);
+			if (access & KDBUS_POLICY_RECV) {
+				ret = 0;
+				break;
+			}
+		}
+	}
+	mutex_unlock(&conn_dst->lock);
+
+	return ret;
+}
+
+static struct kdbus_policy_db_cache_entry *
+kdbus_policy_cache_entry_new(struct kdbus_conn *conn_a,
+			     struct kdbus_conn *conn_b)
+{
+	struct kdbus_policy_db_cache_entry *ce;
+
+	ce = kzalloc(sizeof(*ce), GFP_KERNEL);
+	if (!ce)
+		return NULL;
+
+	ce->conn_a = conn_a;
+	ce->conn_b = conn_b;
+
+	return ce;
+}
+
+/**
+ * kdbus_policy_db_check_send_access() - check if one connection is allowed
+ *				       to send a message to another connection
+ * @db:			The policy database
+ * @conn_src:		The source connection
+ * @conn_dst:		The destination connection
+ *
+ * Returns 0 if access is granted, -EPERM in case it's not, any any other
+ * value in case of errors during adding the cache item internally.
+ */
+int kdbus_policy_db_check_send_access(struct kdbus_policy_db *db,
+				      struct kdbus_conn *conn_src,
+				      struct kdbus_conn *conn_dst)
+{
+	int ret = 0;
+	unsigned int hash = 0;
+	struct kdbus_policy_db_cache_entry *ce;
+
+	/*
+	 * If there was a positive match for these two connections before,
+	 * there's an entry in the hash table for them.
+	 */
+	hash ^= hash_ptr(conn_src, KDBUS_POLICY_HASH_SIZE);
+	hash ^= hash_ptr(conn_dst, KDBUS_POLICY_HASH_SIZE);
+
+	mutex_lock(&db->cache_lock);
+	hash_for_each_possible(db->send_access_hash, ce, hentry, hash)
+		if (ce->conn_a == conn_src && ce->conn_b == conn_dst) {
+			mutex_unlock(&db->cache_lock);
+			return ret;
+		}
+	mutex_unlock(&db->cache_lock);
+
+	/*
+	 * Otherwise, walk the connection list and store and add
+	 * a hash table entry if send access is granted.
+	 */
+	mutex_lock(&db->entries_lock);
+	ret = __kdbus_policy_db_check_send_access(db, conn_src, conn_dst);
+	if (ret == 0) {
+		ce = kdbus_policy_cache_entry_new(conn_src, conn_dst);
+		if (!ce) {
+			ret = -ENOMEM;
+			goto exit_unlock_entries;
+		}
+
+		mutex_lock(&db->cache_lock);
+		hash_add(db->send_access_hash, &ce->hentry, hash);
+		mutex_unlock(&db->cache_lock);
+	}
+
+exit_unlock_entries:
+	mutex_unlock(&db->entries_lock);
+
+	return ret;
+}
+
+/**
+ * kdbus_policy_db_remove_conn() - remove all entries related to a connection
+ * @db:		The policy database
+ * @conn:	The connection which items to remove
+ */
+void kdbus_policy_db_remove_conn(struct kdbus_policy_db *db,
+				 struct kdbus_conn *conn)
+{
+	struct kdbus_policy_db_cache_entry *ce;
+	struct hlist_node *tmp;
+	int i;
+
+	mutex_lock(&db->cache_lock);
+	hash_for_each_safe(db->send_access_hash, i, tmp, ce, hentry)
+		if (ce->conn_a == conn || ce->conn_b == conn) {
+			hash_del(&ce->hentry);
+			kfree(ce);
+		}
+	mutex_unlock(&db->cache_lock);
+}
+
+/**
+ * kdbus_policy_db_check_own_access() - check whether a policy is allowed
+ *					to own a name
+ * @db:		The policy database
+ * @conn:	The connection to check
+ * @name:	The name to check
+ *
+ * Returns true if the connection is allowed to own the name, false otherwise.
+ */
+bool kdbus_policy_db_check_own_access(struct kdbus_policy_db *db,
+				      struct kdbus_conn *conn,
+				      const char *name)
+{
+	struct kdbus_policy_db_entry *db_entry;
+	u32 hash = kdbus_str_hash(name);
+	bool allowed = false;
+
+	/* Walk the list of the names registered for a connection ... */
+	mutex_lock(&db->entries_lock);
+	hash_for_each_possible(db->entries_hash, db_entry,
+			       hentry, hash) {
+		u64 access;
+
+		if (strcmp(db_entry->name, name) != 0)
+			continue;
+
+		access = kdbus_collect_entry_accesses(db_entry, conn);
+		if (access & KDBUS_POLICY_OWN) {
+			allowed = true;
+			goto exit_unlock;
+		}
+	}
+
+exit_unlock:
+	mutex_unlock(&db->entries_lock);
+
+	return allowed;
+}
+
+static int kdbus_policy_db_parse(struct kdbus_policy_db *db,
+				 const struct kdbus_cmd_policy *cmd,
+				 u64 size)
+{
+	const struct kdbus_item *item;
+	struct kdbus_policy_db_entry *current_entry = NULL;
+
+	KDBUS_ITEM_FOREACH(item, cmd, policies) {
+		if (!KDBUS_ITEM_VALID(item, cmd))
+			return -EINVAL;
+
+		switch (item->type) {
+		case KDBUS_ITEM_POLICY_NAME: {
+			struct kdbus_policy_db_entry *e;
+			u32 hash;
+
+			e = kzalloc(sizeof(*e), GFP_KERNEL);
+			if (!e)
+				return -ENOMEM;
+
+			hash = kdbus_str_hash(item->policy.name);
+			e->name = kstrdup(item->policy.name, GFP_KERNEL);
+			INIT_LIST_HEAD(&e->access_list);
+
+			mutex_lock(&db->entries_lock);
+			hash_add(db->entries_hash, &e->hentry, hash);
+			mutex_unlock(&db->entries_lock);
+
+			current_entry = e;
+			break;
+		}
+
+		case KDBUS_ITEM_POLICY_ACCESS: {
+			struct kdbus_policy_db_entry_access *a;
+
+			/*
+			 * A KDBUS_ITEM_POLICY_ACCESS item can only appear
+			 * after a KDBUS_ITEM_POLICY_NAME item.
+			 */
+			if (!current_entry)
+				return -EINVAL;
+
+			a = kzalloc(sizeof(*a), GFP_KERNEL);
+			if (!a)
+				return -ENOMEM;
+
+			a->type = item->policy.access.type;
+			a->bits = item->policy.access.bits;
+			a->id   = item->policy.access.id;
+			INIT_LIST_HEAD(&a->list);
+
+			mutex_lock(&db->entries_lock);
+			list_add_tail(&a->list, &current_entry->access_list);
+			mutex_unlock(&db->entries_lock);
+			break;
+		}
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	if (!KDBUS_ITEM_END(item, cmd))
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * kdbus_cmd_policy_set_from_user() - set a connection's policy rules
+ * @db:		The policy database
+ * @buf:	The __user buffer that was provided by the ioctl() call
+ *
+ * Returns 0 on success, or any other value in case of errors.
+ * This function is used in the context of the KDBUS_CMD_EP_POLICY_SET
+ * ioctl().
+ */
+int kdbus_cmd_policy_set_from_user(struct kdbus_policy_db *db, void __user *buf)
+{
+	struct kdbus_cmd_policy *cmd;
+	u64 size;
+	int ret;
+
+	if (kdbus_size_get_user(&size, buf, struct kdbus_cmd_policy))
+		return -EFAULT;
+
+	if (size <= sizeof(struct kdbus_cmd_policy))
+		return -EINVAL;
+
+	if (size > KDBUS_POLICY_MAX_SIZE)
+		return -EMSGSIZE;
+
+	cmd = memdup_user(buf, size);
+	if (IS_ERR(cmd))
+		return PTR_ERR(cmd);
+
+	ret = kdbus_policy_db_parse(db, cmd, size);
+	kfree(cmd);
+
+	return ret;
+}
diff --git a/drivers/kdbus/policy.h b/drivers/kdbus/policy.h
new file mode 100644
index 0000000..1430513
--- /dev/null
+++ b/drivers/kdbus/policy.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_POLICY_H
+#define __KDBUS_POLICY_H
+
+struct kdbus_conn;
+struct kdbus_policy_db;
+
+int kdbus_policy_db_new(struct kdbus_policy_db **db);
+void kdbus_policy_db_free(struct kdbus_policy_db *db);
+int kdbus_cmd_policy_set_from_user(struct kdbus_policy_db *db,
+				   void __user *buf);
+int kdbus_policy_db_check_send_access(struct kdbus_policy_db *db,
+				      struct kdbus_conn *conn_src,
+				      struct kdbus_conn *conn_dst);
+bool kdbus_policy_db_check_own_access(struct kdbus_policy_db *db,
+				      struct kdbus_conn *conn,
+				      const char *name);
+void kdbus_policy_db_remove_conn(struct kdbus_policy_db *db,
+				 struct kdbus_conn *conn);
+#endif
diff --git a/drivers/kdbus/pool.c b/drivers/kdbus/pool.c
new file mode 100644
index 0000000..3f5ae36
--- /dev/null
+++ b/drivers/kdbus/pool.c
@@ -0,0 +1,662 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/aio.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/rbtree.h>
+#include <linux/sched.h>
+#include <linux/shmem_fs.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "internal.h"
+#include "pool.h"
+
+/**
+ * struct kdbus_pool - the receiver's buffer
+ * @f:			The backing shmem file
+ * @size:		The size of the file
+ * @busy:		The currently used size
+ * @slices:		All slices sorted by address
+ * @slices_busy:	Tree of allocated slices
+ * @slices_free:	Tree of free slices
+ *
+ * The receiver's buffer, managed as a pool of allocated and free
+ * slices containing the queued messages.
+ *
+ * Messages sent with KDBUS_CMD_MSG_SEND are copied direcly by the
+ * sending process into the receiver's pool.
+ *
+ * Messages received with KDBUS_CMD_MSG_RECV just return the offset
+ * to the data placed in the pool.
+ *
+ * The internally allocated memory needs to be returned by the receiver
+ * with KDBUS_CMD_MSG_FREE.
+ */
+struct kdbus_pool {
+	struct file *f;
+	size_t size;
+	size_t busy;
+
+	struct list_head slices;
+	struct rb_root slices_busy;
+	struct rb_root slices_free;
+};
+
+/**
+ * struct kdbus_slice - allocated element in kdbus_pool
+ * @off:		Offset of slice in the shmem file
+ * @size:		Size of slice
+ * @entry:		Entry in "all slices" list
+ * @rb_node:		Entry in free or busy list
+ * @free:		Unused slice
+ *
+ * The pool has one or more slices, always spanning the entire size of the
+ * pool.
+ *
+ * Every slice is an element in a list sorted by the buffer address, to
+ * provide access to the next neighbor slice.
+ *
+ * Every slice is member in either the busy or the free tree. The free
+ * tree is organized by slice size, the busy tree organized by buffer
+ * offset.
+ */
+struct kdbus_slice {
+	size_t off;
+	size_t size;
+
+	struct list_head entry;
+	struct rb_node rb_node;
+	bool free;
+};
+
+static void __maybe_unused kdbus_pool_slices_dump(struct kdbus_pool *pool,
+						  const char *str)
+{
+	struct kdbus_slice *s;
+
+	pr_info("=== dump start '%s' pool=%p size=%zu ===\n",
+		str, pool, pool->size);
+
+	list_for_each_entry(s, &pool->slices, entry)
+		pr_info("  slice=%p free=%u, off=%zu size=%zu\n",
+			s, s->free, s->off, s->size);
+
+	pr_info("=== dump end '%s' pool=%p ===\n", str, pool);
+}
+
+static struct kdbus_slice *kdbus_pool_slice_new(size_t off, size_t size)
+{
+	struct kdbus_slice *slice;
+
+	slice = kzalloc(sizeof(struct kdbus_slice), GFP_KERNEL);
+	if (!slice)
+		return NULL;
+
+	slice->off = off;
+	slice->size = size;
+	slice->free = true;
+	return slice;
+}
+
+/* insert a slice into the free tree */
+static void kdbus_pool_add_free_slice(struct kdbus_pool *pool,
+				      struct kdbus_slice *slice)
+{
+	struct rb_node **n;
+	struct rb_node *pn = NULL;
+
+	n = &pool->slices_free.rb_node;
+	while (*n) {
+		struct kdbus_slice *pslice;
+
+		pn = *n;
+		pslice = rb_entry(pn, struct kdbus_slice, rb_node);
+		if (slice->size < pslice->size)
+			n = &pn->rb_left;
+		else
+			n = &pn->rb_right;
+	}
+
+	rb_link_node(&slice->rb_node, pn, n);
+	rb_insert_color(&slice->rb_node, &pool->slices_free);
+}
+
+/* insert a slice into the busy tree */
+static void kdbus_pool_add_busy_slice(struct kdbus_pool *pool,
+				      struct kdbus_slice *slice)
+{
+	struct rb_node **n;
+	struct rb_node *pn = NULL;
+
+	n = &pool->slices_busy.rb_node;
+	while (*n) {
+		struct kdbus_slice *pslice;
+
+		pn = *n;
+		pslice = rb_entry(pn, struct kdbus_slice, rb_node);
+		if (slice->off < pslice->off)
+			n = &pn->rb_left;
+		else if (slice->off > pslice->off)
+			n = &pn->rb_right;
+	}
+
+	rb_link_node(&slice->rb_node, pn, n);
+	rb_insert_color(&slice->rb_node, &pool->slices_busy);
+}
+
+/* find a slice by its pool offset */
+static struct kdbus_slice *kdbus_pool_find_slice(struct kdbus_pool *pool,
+						 size_t off)
+{
+	struct rb_node *n;
+
+	n = pool->slices_busy.rb_node;
+	while (n) {
+		struct kdbus_slice *s;
+
+		s = rb_entry(n, struct kdbus_slice, rb_node);
+		if (off < s->off)
+			n = n->rb_left;
+		else if (off > s->off)
+			n = n->rb_right;
+		else
+			return s;
+	}
+
+	return NULL;
+}
+
+/* allocate a slice from the pool with the given size */
+static int kdbus_pool_alloc_slice(struct kdbus_pool *pool,
+				  size_t size, struct kdbus_slice **slice)
+{
+	size_t slice_size = KDBUS_ALIGN8(size);
+	struct rb_node *n;
+	struct kdbus_slice *s;
+	struct rb_node *found = NULL;
+
+	/* search a free slice with the closest matching size */
+	n = pool->slices_free.rb_node;
+	while (n) {
+		s = rb_entry(n, struct kdbus_slice, rb_node);
+		if (slice_size < s->size) {
+			found = n;
+			n = n->rb_left;
+		} else if (slice_size > s->size) {
+			n = n->rb_right;
+		} else {
+			found = n;
+			break;
+		}
+	}
+
+	/* no slice with the minimum size found in the pool */
+	if (!found)
+		return -ENOBUFS;
+
+	/* no exact match, use the closest one */
+	if (!n)
+		s = rb_entry(found, struct kdbus_slice, rb_node);
+
+	/* move slice from free to the busy tree */
+	rb_erase(found, &pool->slices_free);
+	kdbus_pool_add_busy_slice(pool, s);
+
+	/* we got a slice larger than what we asked for? */
+	if (s->size > slice_size) {
+		struct kdbus_slice *s_new;
+
+		/* split-off the remainder of the size to its own slice */
+		s_new = kdbus_pool_slice_new(s->off + slice_size,
+					     s->size - slice_size);
+		if (!s_new)
+			return -ENOMEM;
+
+		list_add(&s_new->entry, &s->entry);
+		kdbus_pool_add_free_slice(pool, s_new);
+
+		/* adjust our size now that we split-off another slice */
+		s->size = slice_size;
+	}
+
+	s->free = false;
+	pool->busy += s->size;
+	*slice = s;
+	return 0;
+}
+
+/* return an allocated slice back to the pool */
+static void kdbus_pool_free_slice(struct kdbus_pool *pool,
+				  struct kdbus_slice *slice)
+{
+	rb_erase(&slice->rb_node, &pool->slices_busy);
+	pool->busy -= slice->size;
+
+	/* merge with the next free slice */
+	if (!list_is_last(&slice->entry, &pool->slices)) {
+		struct kdbus_slice *s;
+
+		s = list_entry(slice->entry.next, struct kdbus_slice, entry);
+		if (s->free) {
+			rb_erase(&s->rb_node, &pool->slices_free);
+			list_del(&s->entry);
+			slice->size += s->size;
+			kfree(s);
+		}
+	}
+
+	/* merge with previous free slice */
+	if (pool->slices.next != &slice->entry) {
+		struct kdbus_slice *s;
+
+		s = list_entry(slice->entry.prev, struct kdbus_slice, entry);
+		if (s->free) {
+			rb_erase(&s->rb_node, &pool->slices_free);
+			list_del(&slice->entry);
+			s->size += slice->size;
+			kfree(slice);
+			slice = s;
+		}
+	}
+
+	slice->free = true;
+	kdbus_pool_add_free_slice(pool, slice);
+}
+
+/**
+ * kdbus_pool_new() - create a new pool
+ * @pool:		Newly allocated pool
+ * @size:		Maximum size of the pool
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_pool_new(struct kdbus_pool **pool, size_t size)
+{
+	struct kdbus_pool *p;
+	struct file *f;
+	struct kdbus_slice *s;
+	int ret;
+
+	BUG_ON(*pool);
+
+	p = kzalloc(sizeof(struct kdbus_pool), GFP_KERNEL);
+	if (!p)
+		return -ENOMEM;
+
+	f = shmem_file_setup(KBUILD_MODNAME "-pool", size, 0);
+	if (IS_ERR(f)) {
+		ret = PTR_ERR(f);
+		goto exit_free_p;
+	}
+
+	/* allocate first slice spanning the entire pool */
+	s = kdbus_pool_slice_new(0, size);
+	if (!s) {
+		ret = -ENOMEM;
+		goto exit_put_shmem;
+	}
+
+	p->f = f;
+	p->size = size;
+	p->busy = 0;
+	p->slices_free = RB_ROOT;
+	p->slices_busy = RB_ROOT;
+
+	INIT_LIST_HEAD(&p->slices);
+	list_add(&s->entry, &p->slices);
+
+	kdbus_pool_add_free_slice(p, s);
+	*pool = p;
+	return 0;
+
+exit_put_shmem:
+	fput(f);
+exit_free_p:
+	kfree(p);
+	return ret;
+}
+
+/**
+ * kdbus_pool_free() - destroy pool
+ * @pool:		The receiver's pool
+ */
+void kdbus_pool_free(struct kdbus_pool *pool)
+{
+	struct kdbus_slice *s, *tmp;
+
+	if (!pool)
+		return;
+
+	list_for_each_entry_safe(s, tmp, &pool->slices, entry) {
+		list_del(&s->entry);
+		kfree(s);
+	}
+
+	fput(pool->f);
+	kfree(pool);
+}
+
+/**
+ * kdbus_pool_remain() - the number of free bytes in the pool
+ * @pool:		The receiver's pool
+ *
+ * Returns: the number of unallocated bytes in the pool
+ */
+size_t kdbus_pool_remain(const struct kdbus_pool *pool)
+{
+	return pool->size - pool->busy;
+}
+
+/**
+ * kdbus_pool_alloc_range() - allocate memory from a pool
+ * @pool:		The receiver's pool
+ * @size:		The number of bytes to allocate
+ * @off:		The offset in bytes in the pool's file
+ *
+ *
+ * The returned offset is used for kdbus_pool_free() to
+ * free the allocated memory.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_pool_alloc_range(struct kdbus_pool *pool, size_t size, size_t *off)
+{
+	struct kdbus_slice *s;
+	int ret;
+
+	ret = kdbus_pool_alloc_slice(pool, size, &s);
+	if (ret < 0)
+		return ret;
+
+	*off = s->off;
+	return 0;
+}
+
+/**
+ * kdbus_pool_free_range() - give allocated memory back to the pool
+ * @pool:		The receiver's pool
+ * @off:		Offset of allocated memory
+ *
+ * The offset was returned by the call to kdbus_pool_alloc_range(), the
+ * memory is returned to the pool.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_pool_free_range(struct kdbus_pool *pool, size_t off)
+{
+	struct kdbus_slice *slice;
+
+	if (!pool)
+		return 0;
+
+	if (off >= pool->size)
+		return -EINVAL;
+
+	slice = kdbus_pool_find_slice(pool, off);
+	if (!slice)
+		return -ENXIO;
+
+	kdbus_pool_free_slice(pool, slice);
+	return 0;
+}
+
+/* copy data from a file to ia page in the receiver's pool */
+static int kdbus_pool_copy_file(struct page *p, size_t start,
+				struct file *f, size_t off, size_t count)
+{
+	char *kaddr;
+	ssize_t n;
+	loff_t o = off;
+
+	kaddr = kmap(p);
+	n = f->f_op->read(f, (char __force __user *)kaddr + start, count, &o);
+	kunmap(p);
+	if (n < 0)
+		return n;
+	if (n != count)
+		return -EFAULT;
+
+	return 0;
+}
+
+/* copy data to a page in the receiver's pool */
+static int kdbus_pool_copy_data(struct page *p, size_t start,
+				void __user *from, size_t count)
+{
+	char *kaddr;
+	unsigned long remain;
+
+	if (fault_in_pages_readable(from, count) < 0)
+		return -EFAULT;
+
+	kaddr = kmap_atomic(p);
+	pagefault_disable();
+	remain = __copy_from_user_inatomic(kaddr + start, from, count);
+	pagefault_enable();
+	kunmap_atomic(kaddr);
+	if (remain > 0)
+		return -EFAULT;
+
+	cond_resched();
+	return 0;
+}
+
+/* copy data to the receiver's pool */
+static size_t
+kdbus_pool_copy(struct file *f_dst, size_t off_dst,
+		void __user *data, struct file *f_src, size_t off_src,
+		size_t len)
+{
+	struct address_space *mapping = f_dst->f_mapping;
+	const struct address_space_operations *aops = mapping->a_ops;
+	unsigned long fpos = off_dst;
+	unsigned long rem = len;
+	size_t dpos = 0;
+	int ret = 0;
+
+	while (rem > 0) {
+		struct page *p;
+		unsigned long o;
+		unsigned long n;
+		void *fsdata;
+		int status;
+
+		o = fpos & (PAGE_CACHE_SIZE - 1);
+		n = min_t(unsigned long, PAGE_CACHE_SIZE - o, rem);
+
+		status = aops->write_begin(f_dst, mapping, fpos, n, 0, &p,
+					   &fsdata);
+		if (status) {
+			ret = -EFAULT;
+			break;
+		}
+
+		if (data)
+			ret = kdbus_pool_copy_data(p, o, data + dpos, n);
+		else
+			ret = kdbus_pool_copy_file(p, o, f_src, off_src, n);
+		mark_page_accessed(p);
+
+		status = aops->write_end(f_dst, mapping, fpos, n, n, p, fsdata);
+
+		if (ret < 0)
+			break;
+		if (status != n) {
+			ret = -EFAULT;
+			break;
+		}
+
+		fpos += n;
+		rem -= n;
+		dpos += n;
+	}
+
+	return ret;
+}
+
+/**
+ * kdbus_pool_write_user() - copy user memory to the pool
+ * @pool:		The receiver's pool
+ * @off:		Offset of allocated memory
+ * @data:		User memory
+ * @len:		Number of bytes to copy
+ *
+ * The offset was returned by the call to kdbus_pool_alloc_range().
+ * The user memory at @data will be copied to the @off in the allocated
+ * memory in the pool.
+ *
+ * Returns: the numbers of bytes copied, negative errno on failure.
+ */
+ssize_t kdbus_pool_write_user(const struct kdbus_pool *pool, size_t off,
+			      void __user *data, size_t len)
+{
+	return kdbus_pool_copy(pool->f, off, data, NULL, 0, len);
+}
+
+/**
+ * kdbus_pool_write() - copy kernel memory to the pool
+ * @pool:		The receiver's pool
+ * @off:		Offset of allocated memory
+ * @data:		User memory
+ * @len:		Number of bytes to copy
+ *
+ * The offset was returned by the call to kdbus_pool_alloc_range().
+ * The user memory at @data will be copied to the @off in the allocated
+ * memory in the pool.
+ *
+ * Returns: the numbers of bytes copied, negative errno on failure.
+ */
+ssize_t kdbus_pool_write(const struct kdbus_pool *pool, size_t off,
+			 void *data, size_t len)
+{
+	mm_segment_t old_fs;
+	ssize_t ret;
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+	ret = kdbus_pool_copy(pool->f, off, (void __user *)data, NULL, 0, len);
+	set_fs(old_fs);
+
+	return ret;
+}
+
+/**
+ * kdbus_pool_write() - move memory from one pool into another one
+ * @dst_pool:		The receiver's pool to copy to
+ * @src_pool:		The receiver's pool to copy from
+ * @off:		Offset of allocated memory in the source pool,
+ *			Updated with the offset in the destination pool
+ * @len:		Number of bytes to copy
+ *
+ * Move memory from one pool to another. Memory will be allocated in the
+ * destination pool, the memory copied over, and the free()d in source
+ * pool.
+ *
+ * Returns: 0 on success, negative errno on failure.
+ */
+int kdbus_pool_move(struct kdbus_pool *dst_pool,
+		    struct kdbus_pool *src_pool,
+		    size_t *off, size_t len)
+{
+	mm_segment_t old_fs;
+	size_t new_off;
+	int ret;
+
+	ret = kdbus_pool_alloc_range(dst_pool, len, &new_off);
+	if (ret < 0)
+		return ret;
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+	ret = kdbus_pool_copy(dst_pool->f, new_off,
+			      NULL, src_pool->f, *off, len);
+	set_fs(old_fs);
+	if (ret < 0)
+		goto exit_free;
+
+	ret = kdbus_pool_free_range(src_pool, *off);
+	if (ret < 0)
+		goto exit_free;
+
+	*off = new_off;
+	return 0;
+
+exit_free:
+	kdbus_pool_free_range(dst_pool, new_off);
+	return ret;
+}
+
+/**
+ * kdbus_pool_flush_dcache() - flush memory area in the pool
+ * @pool:		The receiver's pool
+ * @off:		Offset to the memory
+ * @len:		Number of bytes to flush
+ *
+ * Dcache flushes are delayed to happen only right before the receiver
+ * gets the new buffer area announced. The mapped buffer is always
+ * read-only for the receiver, and only the area of the announced message
+ * needs to be flushed.
+ */
+void kdbus_pool_flush_dcache(const struct kdbus_pool *pool,
+			     size_t off, size_t len)
+{
+#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1
+	struct address_space *mapping = pool->f->f_mapping;
+	pgoff_t first = off >> PAGE_CACHE_SHIFT;
+	pgoff_t last = (off + len + PAGE_CACHE_SIZE-1) >> PAGE_CACHE_SHIFT;
+	pgoff_t i;
+
+	for (i = first; i < last; i++) {
+		struct page *page;
+
+		page = find_get_page(mapping, i);
+		if (!page)
+			continue;
+
+		flush_dcache_page(page);
+		put_page(page);
+	}
+#endif
+}
+
+/**
+ * kdbus_pool_mmap() -  map the pool into the process
+ * @pool:		The receiver's pool
+ * @vma:		passed by mmap() syscall
+ *
+ * Returns: the result of the mmap() call, negative errno on failure.
+ */
+int kdbus_pool_mmap(const struct kdbus_pool *pool, struct vm_area_struct *vma)
+{
+	/* deny write access to the pool */
+	if (vma->vm_flags & VM_WRITE)
+		return -EPERM;
+
+	/* do not allow to map more than the size of the file */
+	if ((vma->vm_end - vma->vm_start) > pool->size)
+		return -EFAULT;
+
+	/* replace the connection file with our shmem file */
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = get_file(pool->f);
+
+	return pool->f->f_op->mmap(pool->f, vma);
+}
diff --git a/drivers/kdbus/pool.h b/drivers/kdbus/pool.h
new file mode 100644
index 0000000..a450ff4
--- /dev/null
+++ b/drivers/kdbus/pool.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ * Copyright (C) 2013 Linux Foundation
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __KDBUS_POOL_H
+#define __KDBUS_POOL_H
+
+struct kdbus_pool;
+
+int kdbus_pool_new(struct kdbus_pool **pool, size_t size);
+void kdbus_pool_free(struct kdbus_pool *pool);
+
+int kdbus_pool_alloc_range(struct kdbus_pool *pool, size_t size, size_t *off);
+int kdbus_pool_free_range(struct kdbus_pool *pool, size_t off);
+size_t kdbus_pool_remain(const struct kdbus_pool *pool);
+ssize_t kdbus_pool_write(const struct kdbus_pool *pool, size_t off,
+			 void *data, size_t len);
+ssize_t kdbus_pool_write_user(const struct kdbus_pool *pool, size_t off,
+			 void __user *data, size_t len);
+int kdbus_pool_move(struct kdbus_pool *dst_pool,
+		    struct kdbus_pool *src_pool,
+		    size_t *offset, size_t size);
+void kdbus_pool_flush_dcache(const struct kdbus_pool *pool,
+			     size_t off, size_t len);
+int kdbus_pool_mmap(const struct kdbus_pool *pool, struct vm_area_struct *vma);
+#endif
diff --git a/drivers/kdbus/test/Makefile b/drivers/kdbus/test/Makefile
new file mode 100644
index 0000000..b4117bf
--- /dev/null
+++ b/drivers/kdbus/test/Makefile
@@ -0,0 +1,25 @@
+CFLAGS		+= -std=gnu99 -Wall -Wextra -g -Wno-unused-parameter -D_GNU_SOURCE
+TEST_COMMON	:= kdbus-enum.o kdbus-util.o
+CC		:= $(CROSS_COMPILE)gcc
+
+TESTS= \
+	test-kdbus \
+	test-kdbus-daemon \
+	test-kdbus-fuzz \
+	test-kdbus-benchmark \
+	test-kdbus-activator \
+	test-kdbus-monitor \
+	test-kdbus-chat
+
+all: $(TESTS)
+
+%.o: %.c ../kdbus.h
+	@echo '  TARGET_CC $@'
+	@$(CC) $(CFLAGS) -DKBUILD_MODNAME=\"$(KBUILD_MODNAME)\" -c $< -o $@
+
+test-%: $(TEST_COMMON) test-%.o
+	@echo '  TARGET_LD $@'
+	@$(CC) $(CFLAGS) $^ -o $@
+
+clean::
+	rm -f *.o $(TESTS)
diff --git a/drivers/kdbus/test/kdbus-enum.c b/drivers/kdbus/test/kdbus-enum.c
new file mode 100644
index 0000000..8207f6a
--- /dev/null
+++ b/drivers/kdbus/test/kdbus-enum.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+struct kdbus_enum_table {
+	long long id;
+	const char *name;
+};
+
+#define TABLE(what) static struct kdbus_enum_table kdbus_table_##what[]
+#define ENUM(_id) { .id=_id, .name=STRINGIFY(_id) }
+#define LOOKUP(what)								\
+	const char *enum_##what(long long id) {					\
+		for (size_t i = 0; i < ELEMENTSOF(kdbus_table_##what); i++)	\
+			if (id == kdbus_table_##what[i].id)			\
+				return kdbus_table_##what[i].name;		\
+		return "UNKNOWN";						\
+	}
+
+TABLE(CMD) = {
+	ENUM(KDBUS_CMD_BUS_MAKE),
+	ENUM(KDBUS_CMD_NS_MAKE),
+	ENUM(KDBUS_CMD_EP_MAKE),
+	ENUM(KDBUS_CMD_HELLO),
+	ENUM(KDBUS_CMD_MSG_SEND),
+	ENUM(KDBUS_CMD_MSG_RECV),
+	ENUM(KDBUS_CMD_NAME_LIST),
+	ENUM(KDBUS_CMD_NAME_RELEASE),
+	ENUM(KDBUS_CMD_CONN_INFO),
+	ENUM(KDBUS_CMD_MATCH_ADD),
+	ENUM(KDBUS_CMD_MATCH_REMOVE),
+	ENUM(KDBUS_CMD_EP_POLICY_SET),
+};
+LOOKUP(CMD);
+
+TABLE(MSG) = {
+	ENUM(_KDBUS_ITEM_NULL),
+	ENUM(KDBUS_ITEM_PAYLOAD_VEC),
+	ENUM(KDBUS_ITEM_PAYLOAD_OFF),
+	ENUM(KDBUS_ITEM_PAYLOAD_MEMFD),
+	ENUM(KDBUS_ITEM_FDS),
+	ENUM(KDBUS_ITEM_BLOOM),
+	ENUM(KDBUS_ITEM_DST_NAME),
+	ENUM(KDBUS_ITEM_CREDS),
+	ENUM(KDBUS_ITEM_PID_COMM),
+	ENUM(KDBUS_ITEM_TID_COMM),
+	ENUM(KDBUS_ITEM_EXE),
+	ENUM(KDBUS_ITEM_CMDLINE),
+	ENUM(KDBUS_ITEM_CGROUP),
+	ENUM(KDBUS_ITEM_CAPS),
+	ENUM(KDBUS_ITEM_SECLABEL),
+	ENUM(KDBUS_ITEM_AUDIT),
+	ENUM(KDBUS_ITEM_NAME),
+	ENUM(KDBUS_ITEM_TIMESTAMP),
+	ENUM(KDBUS_ITEM_NAME_ADD),
+	ENUM(KDBUS_ITEM_NAME_REMOVE),
+	ENUM(KDBUS_ITEM_NAME_CHANGE),
+	ENUM(KDBUS_ITEM_ID_ADD),
+	ENUM(KDBUS_ITEM_ID_REMOVE),
+	ENUM(KDBUS_ITEM_REPLY_TIMEOUT),
+	ENUM(KDBUS_ITEM_REPLY_DEAD),
+};
+LOOKUP(MSG);
+
+TABLE(PAYLOAD) = {
+	ENUM(KDBUS_PAYLOAD_KERNEL),
+	ENUM(KDBUS_PAYLOAD_DBUS),
+};
+LOOKUP(PAYLOAD);
diff --git a/drivers/kdbus/test/kdbus-enum.h b/drivers/kdbus/test/kdbus-enum.h
new file mode 100644
index 0000000..aeca119
--- /dev/null
+++ b/drivers/kdbus/test/kdbus-enum.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+#pragma once
+
+#include "../kdbus.h"
+
+const char *enum_CMD(long long id);
+const char *enum_MSG(long long id);
+const char *enum_MATCH(long long id);
+const char *enum_PAYLOAD(long long id);
diff --git a/drivers/kdbus/test/kdbus-util.c b/drivers/kdbus/test/kdbus-util.c
new file mode 100644
index 0000000..359a038
--- /dev/null
+++ b/drivers/kdbus/test/kdbus-util.c
@@ -0,0 +1,598 @@
+/*
+ * Copyright (C) 2013 Daniel Mack
+ * Copyright (C) 2013 Kay Sievers
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <assert.h>
+#include <poll.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+#define POOL_SIZE (16 * 1024LU * 1024LU)
+struct conn *connect_to_bus(const char *path, uint64_t hello_flags)
+{
+	int fd, ret;
+	struct kdbus_cmd_hello hello;
+	struct conn *conn;
+
+	memset(&hello, 0, sizeof(hello));
+
+	printf("-- opening bus connection %s\n", path);
+	fd = open(path, O_RDWR|O_CLOEXEC);
+	if (fd < 0) {
+		fprintf(stderr, "--- error %d (%m)\n", fd);
+		return NULL;
+	}
+
+	hello.conn_flags = hello_flags | KDBUS_HELLO_ACCEPT_FD;
+
+	hello.attach_flags = KDBUS_ATTACH_TIMESTAMP |
+			     KDBUS_ATTACH_CREDS |
+			     KDBUS_ATTACH_NAMES |
+			     KDBUS_ATTACH_COMM |
+			     KDBUS_ATTACH_EXE |
+			     KDBUS_ATTACH_CMDLINE |
+			     KDBUS_ATTACH_CAPS |
+			     KDBUS_ATTACH_CGROUP |
+			     KDBUS_ATTACH_SECLABEL |
+			     KDBUS_ATTACH_AUDIT;
+
+	hello.size = sizeof(struct kdbus_cmd_hello);
+	hello.pool_size = POOL_SIZE;
+
+	ret = ioctl(fd, KDBUS_CMD_HELLO, &hello);
+	if (ret < 0) {
+		fprintf(stderr, "--- error when saying hello: %d (%m)\n", ret);
+		return NULL;
+	}
+	printf("-- Our peer ID for %s: %llu -- bus uuid: '%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x'\n",
+		path, (unsigned long long)hello.id,
+		hello.id128[0],  hello.id128[1],  hello.id128[2],  hello.id128[3],
+		hello.id128[4],  hello.id128[5],  hello.id128[6],  hello.id128[7],
+		hello.id128[8],  hello.id128[9],  hello.id128[10], hello.id128[11],
+		hello.id128[12], hello.id128[13], hello.id128[14], hello.id128[15]);
+
+	conn = malloc(sizeof(*conn));
+	if (!conn) {
+		fprintf(stderr, "unable to malloc()!?\n");
+		return NULL;
+	}
+
+	conn->buf = mmap(NULL, POOL_SIZE, PROT_READ, MAP_SHARED, fd, 0);
+	if (conn->buf == MAP_FAILED) {
+		free(conn);
+		fprintf(stderr, "--- error mmap (%m)\n");
+		return NULL;
+	}
+
+	conn->fd = fd;
+	conn->id = hello.id;
+	return conn;
+}
+
+int msg_send(const struct conn *conn,
+		    const char *name,
+		    uint64_t cookie,
+		    uint64_t dst_id)
+{
+	struct kdbus_msg *msg;
+	const char ref1[1024 * 1024 + 3] = "0123456789_0";
+	const char ref2[] = "0123456789_1";
+	struct kdbus_item *item;
+	uint64_t size;
+	int memfd = -1;
+	int ret;
+
+	size = sizeof(struct kdbus_msg);
+	size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+	size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+	size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+
+	if (dst_id == KDBUS_DST_ID_BROADCAST)
+		size += KDBUS_ITEM_HEADER_SIZE + 64;
+	else {
+		ret = ioctl(conn->fd, KDBUS_CMD_MEMFD_NEW, &memfd);
+		if (ret < 0) {
+			fprintf(stderr, "KDBUS_CMD_MEMFD_NEW failed: %m\n");
+			return EXIT_FAILURE;
+		}
+
+		if (write(memfd, "kdbus memfd 1234567", 19) != 19) {
+			fprintf(stderr, "writing to memfd failed: %m\n");
+			return EXIT_FAILURE;
+		}
+
+		ret = ioctl(memfd, KDBUS_CMD_MEMFD_SEAL_SET, true);
+		if (ret < 0) {
+			fprintf(stderr, "memfd sealing failed: %m\n");
+			return EXIT_FAILURE;
+		}
+
+		size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_memfd));
+	}
+
+	if (name)
+		size += KDBUS_ITEM_SIZE(strlen(name) + 1);
+
+	msg = malloc(size);
+	if (!msg) {
+		fprintf(stderr, "unable to malloc()!?\n");
+		return EXIT_FAILURE;
+	}
+
+	memset(msg, 0, size);
+	msg->size = size;
+	msg->src_id = conn->id;
+	msg->dst_id = name ? 0 : dst_id;
+	msg->cookie = cookie;
+	msg->payload_type = KDBUS_PAYLOAD_DBUS;
+
+	item = msg->items;
+
+	if (name) {
+		item->type = KDBUS_ITEM_DST_NAME;
+		item->size = KDBUS_ITEM_HEADER_SIZE + strlen(name) + 1;
+		strcpy(item->str, name);
+		item = KDBUS_ITEM_NEXT(item);
+	}
+
+	item->type = KDBUS_ITEM_PAYLOAD_VEC;
+	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
+	item->vec.address = (uintptr_t)&ref1;
+	item->vec.size = sizeof(ref1);
+	item = KDBUS_ITEM_NEXT(item);
+
+	/* data padding for ref1 */
+	item->type = KDBUS_ITEM_PAYLOAD_VEC;
+	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
+	item->vec.address = (uintptr_t)NULL;
+	item->vec.size =  KDBUS_ALIGN8(sizeof(ref1)) - sizeof(ref1);
+	item = KDBUS_ITEM_NEXT(item);
+
+	item->type = KDBUS_ITEM_PAYLOAD_VEC;
+	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
+	item->vec.address = (uintptr_t)&ref2;
+	item->vec.size = sizeof(ref2);
+	item = KDBUS_ITEM_NEXT(item);
+
+	if (dst_id == KDBUS_DST_ID_BROADCAST) {
+		item->type = KDBUS_ITEM_BLOOM;
+		item->size = KDBUS_ITEM_HEADER_SIZE + 64;
+	} else {
+		item->type = KDBUS_ITEM_PAYLOAD_MEMFD;
+		item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_memfd);
+		item->memfd.size = 16;
+		item->memfd.fd = memfd;
+	}
+	item = KDBUS_ITEM_NEXT(item);
+
+	ret = ioctl(conn->fd, KDBUS_CMD_MSG_SEND, msg);
+	if (ret < 0) {
+		fprintf(stderr, "error sending message: %d err %d (%m)\n", ret, errno);
+		return EXIT_FAILURE;
+	}
+
+	if (memfd >= 0)
+		close(memfd);
+	free(msg);
+
+	return 0;
+}
+
+char *msg_id(uint64_t id, char *buf)
+{
+	if (id == 0)
+		return "KERNEL";
+	if (id == ~0ULL)
+		return "BROADCAST";
+	sprintf(buf, "%llu", (unsigned long long)id);
+	return buf;
+}
+
+void msg_dump(const struct conn *conn, const struct kdbus_msg *msg)
+{
+	const struct kdbus_item *item = msg->items;
+	char buf_src[32];
+	char buf_dst[32];
+	uint64_t timeout = 0;
+	uint64_t cookie_reply = 0;
+
+	if (msg->flags & KDBUS_MSG_FLAGS_EXPECT_REPLY)
+		timeout = msg->timeout_ns;
+	else
+		cookie_reply = msg->cookie_reply;
+
+	printf("MESSAGE: %s (%llu bytes) flags=0x%08llx, %s → %s, cookie=%llu, timeout=%llu cookie_reply=%llu\n",
+		enum_PAYLOAD(msg->payload_type), (unsigned long long)msg->size,
+		(unsigned long long)msg->flags,
+		msg_id(msg->src_id, buf_src), msg_id(msg->dst_id, buf_dst),
+		(unsigned long long)msg->cookie, (unsigned long long)timeout, (unsigned long long)cookie_reply);
+
+	KDBUS_ITEM_FOREACH(item, msg, items) {
+		if (item->size <= KDBUS_ITEM_HEADER_SIZE) {
+			printf("  +%s (%llu bytes) invalid data record\n", enum_MSG(item->type), item->size);
+			break;
+		}
+
+		switch (item->type) {
+		case KDBUS_ITEM_PAYLOAD_OFF: {
+			char *s;
+
+			if (item->vec.offset == ~0ULL)
+				s = "[\\0-bytes]";
+			else
+				s = (char *)conn->buf + item->vec.offset;
+
+			printf("  +%s (%llu bytes) off=%llu size=%llu '%s'\n",
+			       enum_MSG(item->type), item->size,
+			       (unsigned long long)item->vec.offset,
+			       (unsigned long long)item->vec.size, s);
+			break;
+		}
+
+		case KDBUS_ITEM_PAYLOAD_MEMFD: {
+			char *buf;
+			uint64_t size;
+
+			buf = mmap(NULL, item->memfd.size, PROT_READ, MAP_SHARED, item->memfd.fd, 0);
+			if (buf == MAP_FAILED) {
+				printf("mmap() fd=%i failed:%m", item->memfd.fd);
+				break;
+			}
+
+			if (ioctl(item->memfd.fd, KDBUS_CMD_MEMFD_SIZE_GET, &size) < 0) {
+				fprintf(stderr, "KDBUS_CMD_MEMFD_SIZE_GET failed: %m\n");
+				break;
+			}
+
+			printf("  +%s (%llu bytes) fd=%i size=%llu filesize=%llu '%s'\n",
+			       enum_MSG(item->type), item->size, item->memfd.fd,
+			       (unsigned long long)item->memfd.size, (unsigned long long)size, buf);
+			break;
+		}
+
+		case KDBUS_ITEM_CREDS:
+			printf("  +%s (%llu bytes) uid=%lld, gid=%lld, pid=%lld, tid=%lld, starttime=%lld\n",
+				enum_MSG(item->type), item->size,
+				item->creds.uid, item->creds.gid,
+				item->creds.pid, item->creds.tid,
+				item->creds.starttime);
+			break;
+
+		case KDBUS_ITEM_PID_COMM:
+		case KDBUS_ITEM_TID_COMM:
+		case KDBUS_ITEM_EXE:
+		case KDBUS_ITEM_CGROUP:
+		case KDBUS_ITEM_SECLABEL:
+		case KDBUS_ITEM_DST_NAME:
+			printf("  +%s (%llu bytes) '%s' (%zu)\n",
+			       enum_MSG(item->type), item->size, item->str, strlen(item->str));
+			break;
+
+		case KDBUS_ITEM_NAME: {
+			printf("  +%s (%llu bytes) '%s' (%zu) flags=0x%08llx\n",
+			       enum_MSG(item->type), item->size, item->name.name, strlen(item->name.name),
+			       item->name.flags);
+			break;
+		}
+
+		case KDBUS_ITEM_CMDLINE: {
+			size_t size = item->size - KDBUS_ITEM_HEADER_SIZE;
+			const char *str = item->str;
+			int count = 0;
+
+			printf("  +%s (%llu bytes) ", enum_MSG(item->type), item->size);
+			while (size) {
+				printf("'%s' ", str);
+				size -= strlen(str) + 1;
+				str += strlen(str) + 1;
+				count++;
+			}
+
+			printf("(%d string%s)\n", count, (count == 1) ? "" : "s");
+			break;
+		}
+
+		case KDBUS_ITEM_AUDIT:
+			printf("  +%s (%llu bytes) loginuid=%llu sessionid=%llu\n",
+			       enum_MSG(item->type), item->size,
+			       (unsigned long long)item->data64[0],
+			       (unsigned long long)item->data64[1]);
+			break;
+
+		case KDBUS_ITEM_CAPS: {
+			int n;
+			const uint32_t *cap;
+			int i;
+
+			printf("  +%s (%llu bytes) len=%llu bytes\n",
+			       enum_MSG(item->type), item->size,
+			       (unsigned long long)item->size - KDBUS_ITEM_HEADER_SIZE);
+
+			cap = item->data32;
+			n = (item->size - KDBUS_ITEM_HEADER_SIZE) / 4 / sizeof(uint32_t);
+
+			printf("    CapInh=");
+			for (i = 0; i < n; i++)
+				printf("%08x", cap[(0 * n) + (n - i - 1)]);
+
+			printf(" CapPrm=");
+			for (i = 0; i < n; i++)
+				printf("%08x", cap[(1 * n) + (n - i - 1)]);
+
+			printf(" CapEff=");
+			for (i = 0; i < n; i++)
+				printf("%08x", cap[(2 * n) + (n - i - 1)]);
+
+			printf(" CapInh=");
+			for (i = 0; i < n; i++)
+				printf("%08x", cap[(3 * n) + (n - i - 1)]);
+			printf("\n");
+			break;
+		}
+
+		case KDBUS_ITEM_TIMESTAMP:
+			printf("  +%s (%llu bytes) realtime=%lluns monotonic=%lluns\n",
+			       enum_MSG(item->type), item->size,
+			       (unsigned long long)item->timestamp.realtime_ns,
+			       (unsigned long long)item->timestamp.monotonic_ns);
+			break;
+
+		case KDBUS_ITEM_REPLY_TIMEOUT:
+			printf("  +%s (%llu bytes) cookie=%llu\n",
+			       enum_MSG(item->type), item->size, msg->cookie_reply);
+			break;
+
+		case KDBUS_ITEM_NAME_ADD:
+		case KDBUS_ITEM_NAME_REMOVE:
+		case KDBUS_ITEM_NAME_CHANGE:
+			printf("  +%s (%llu bytes) '%s', old id=%lld, new id=%lld, old_flags=0x%llx new_flags=0x%llx\n",
+				enum_MSG(item->type), (unsigned long long) item->size,
+				item->name_change.name, item->name_change.old.id,
+				item->name_change.new.id, item->name_change.old.flags,
+				item->name_change.new.flags);
+			break;
+
+		case KDBUS_ITEM_ID_ADD:
+		case KDBUS_ITEM_ID_REMOVE:
+			printf("  +%s (%llu bytes) id=%llu flags=%llu\n",
+			       enum_MSG(item->type), (unsigned long long) item->size,
+			       (unsigned long long) item->id_change.id,
+			       (unsigned long long) item->id_change.flags);
+			break;
+
+		default:
+			printf("  +%s (%llu bytes)\n", enum_MSG(item->type), item->size);
+			break;
+		}
+	}
+
+	if ((char *)item - ((char *)msg + msg->size) >= 8)
+		printf("invalid padding at end of message\n");
+
+	printf("\n");
+}
+
+int msg_recv(struct conn *conn)
+{
+	uint64_t off;
+	struct kdbus_msg *msg;
+	int ret;
+
+	ret = ioctl(conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	if (ret < 0) {
+		fprintf(stderr, "error receiving message: %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	msg = (struct kdbus_msg *)(conn->buf + off);
+	msg_dump(conn, msg);
+
+	ret = ioctl(conn->fd, KDBUS_CMD_FREE, &off);
+	if (ret < 0) {
+		fprintf(stderr, "error free message: %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	return 0;
+}
+
+int name_acquire(struct conn *conn, const char *name, uint64_t flags)
+{
+	struct kdbus_cmd_name *cmd_name;
+	int ret;
+	uint64_t size = sizeof(*cmd_name) + strlen(name) + 1;
+
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+	cmd_name->flags = flags;
+
+	ret = ioctl(conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	if (ret < 0) {
+		ret = -errno;
+		fprintf(stderr, "error aquiring name: %s\n", strerror(-ret));
+		return ret;
+	}
+
+	printf("%s(): flags after call: 0x%llx\n", __func__, cmd_name->conn_flags);
+
+	return 0;
+}
+
+int name_release(struct conn *conn, const char *name)
+{
+	struct kdbus_cmd_name *cmd_name;
+	int ret;
+	uint64_t size = sizeof(*cmd_name) + strlen(name) + 1;
+
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+
+	printf("conn %lld giving up name '%s'\n", (unsigned long long)conn->id, name);
+
+	ret = ioctl(conn->fd, KDBUS_CMD_NAME_RELEASE, cmd_name);
+	if (ret < 0) {
+		ret = -errno;
+		fprintf(stderr, "error releasing name: %s\n", strerror(-ret));
+		return ret;
+	}
+
+	return 0;
+}
+
+int name_list(struct conn *conn, uint64_t flags)
+{
+	struct kdbus_cmd_name_list cmd_list;
+	struct kdbus_name_list *list;
+	struct kdbus_cmd_name *name;
+	int ret;
+
+	cmd_list.flags = flags;
+
+	ret = ioctl(conn->fd, KDBUS_CMD_NAME_LIST, &cmd_list);
+	if (ret < 0) {
+		fprintf(stderr, "error listing names: %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	printf("REGISTRY:\n");
+	list = (struct kdbus_name_list *)(conn->buf + cmd_list.offset);
+	KDBUS_ITEM_FOREACH(name, list, names)
+		printf("%8llu flags=0x%08llx conn=0x%08llx '%s'\n", name->owner_id,
+		       name->flags, name->conn_flags,
+		       name->size > sizeof(struct kdbus_cmd_name) ? name->name : "");
+	printf("\n");
+
+	ret = ioctl(conn->fd, KDBUS_CMD_FREE, &cmd_list.offset);
+	if (ret < 0) {
+		fprintf(stderr, "error free name list: %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	return 0;
+}
+
+void append_policy(struct kdbus_cmd_policy *cmd_policy, struct kdbus_item *policy, __u64 max_size)
+{
+	struct kdbus_item *dst = (struct kdbus_item *) ((char *) cmd_policy + cmd_policy->size);
+
+	if (cmd_policy->size + policy->size > max_size)
+		return;
+
+	memcpy(dst, policy, policy->size);
+	cmd_policy->size += KDBUS_ALIGN8(policy->size);
+	free(policy);
+}
+
+struct kdbus_item *make_policy_name(const char *name)
+{
+	struct kdbus_item *p;
+	__u64 size;
+
+	size = offsetof(struct kdbus_item, policy.name) + strlen(name) + 1;
+	p = malloc(size);
+	if (!p)
+		return NULL;
+	memset(p, 0, size);
+	p->size = size;
+	p->type = KDBUS_ITEM_POLICY_NAME;
+	strcpy(p->policy.name, name);
+
+	return p;
+}
+
+struct kdbus_item *make_policy_access(__u64 type, __u64 bits, __u64 id)
+{
+	struct kdbus_item *p;
+	__u64 size = sizeof(*p);
+
+	p = malloc(size);
+	if (!p)
+		return NULL;
+
+	memset(p, 0, size);
+	p->size = size;
+	p->type = KDBUS_ITEM_POLICY_ACCESS;
+	p->policy.access.type = type;
+	p->policy.access.bits = bits;
+	p->policy.access.id = id;
+
+	return p;
+}
+
+int upload_policy(int fd, const char *name)
+{
+	struct kdbus_cmd_policy *cmd_policy;
+	struct kdbus_item *policy;
+	int ret;
+	int size = 0xffff;
+
+	cmd_policy = (struct kdbus_cmd_policy *) alloca(size);
+	memset(cmd_policy, 0, size);
+
+	policy = (struct kdbus_item *) cmd_policy->policies;
+	cmd_policy->size = offsetof(struct kdbus_cmd_policy, policies);
+
+	policy = make_policy_name(name);
+	append_policy(cmd_policy, policy, size);
+
+	policy = make_policy_access(KDBUS_POLICY_ACCESS_USER, KDBUS_POLICY_OWN, getuid());
+	append_policy(cmd_policy, policy, size);
+
+	policy = make_policy_access(KDBUS_POLICY_ACCESS_WORLD, KDBUS_POLICY_RECV, 0);
+	append_policy(cmd_policy, policy, size);
+
+	policy = make_policy_access(KDBUS_POLICY_ACCESS_WORLD, KDBUS_POLICY_SEND, 0);
+	append_policy(cmd_policy, policy, size);
+
+	ret = ioctl(fd, KDBUS_CMD_EP_POLICY_SET, cmd_policy);
+	if (ret < 0)
+		fprintf(stderr, "--- error setting EP policy: %d (%m)\n", ret);
+
+	return ret;
+}
+
+void add_match_empty(int fd)
+{
+	struct {
+		struct kdbus_cmd_match cmd;
+		struct kdbus_item item;
+	} buf;
+	int ret;
+
+	memset(&buf, 0, sizeof(buf));
+
+	buf.item.size = sizeof(uint64_t) * 3;
+	buf.item.type = KDBUS_ITEM_ID;
+	buf.item.id = KDBUS_MATCH_ID_ANY;
+
+	buf.cmd.size = sizeof(buf.cmd) + buf.item.size;
+
+	ret = ioctl(fd, KDBUS_CMD_MATCH_ADD, &buf);
+	if (ret < 0)
+		fprintf(stderr, "--- error adding conn match: %d (%m)\n", ret);
+}
diff --git a/drivers/kdbus/test/kdbus-util.h b/drivers/kdbus/test/kdbus-util.h
new file mode 100644
index 0000000..8446ad9
--- /dev/null
+++ b/drivers/kdbus/test/kdbus-util.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+#pragma once
+
+#define BIT(X) (1 << (X))
+
+#include "../kdbus.h"
+
+#define _STRINGIFY(x) #x
+#define STRINGIFY(x) _STRINGIFY(x)
+#define ELEMENTSOF(x) (sizeof(x)/sizeof((x)[0]))
+
+#define KDBUS_PTR(addr) ((void *)(uintptr_t)(addr))
+
+#define KDBUS_ALIGN8(l) (((l) + 7) & ~7)
+#define KDBUS_ITEM_HEADER_SIZE offsetof(struct kdbus_item, data)
+#define KDBUS_ITEM_SIZE(s) KDBUS_ALIGN8((s) + KDBUS_ITEM_HEADER_SIZE)
+
+#define KDBUS_ITEM_NEXT(item) \
+	(typeof(item))(((uint8_t *)item) + KDBUS_ALIGN8((item)->size))
+#define KDBUS_ITEM_FOREACH(item, head, first)				\
+	for (item = (head)->first;					\
+	     (uint8_t *)(item) < (uint8_t *)(head) + (head)->size;	\
+	     item = KDBUS_ITEM_NEXT(item))
+
+struct conn {
+	int fd;
+	uint64_t id;
+	void *buf;
+	size_t size;
+};
+
+int name_list(struct conn *conn, uint64_t flags);
+int name_release(struct conn *conn, const char *name);
+int name_acquire(struct conn *conn, const char *name, uint64_t flags);
+int msg_recv(struct conn *conn);
+void msg_dump(const struct conn *conn, const struct kdbus_msg *msg);
+char *msg_id(uint64_t id, char *buf);
+int msg_send(const struct conn *conn, const char *name, uint64_t cookie, uint64_t dst_id);
+struct conn *connect_to_bus(const char *path, uint64_t hello_flags);
+void append_policy(struct kdbus_cmd_policy *cmd_policy, struct kdbus_item *policy, __u64 max_size);
+struct kdbus_item *make_policy_name(const char *name);
+struct kdbus_item *make_policy_access(__u64 type, __u64 bits, __u64 id);
+int upload_policy(int fd, const char *name);
+void add_match_empty(int fd);
+
diff --git a/drivers/kdbus/test/test-kdbus-activator.c b/drivers/kdbus/test/test-kdbus-activator.c
new file mode 100644
index 0000000..b6ad4b5
--- /dev/null
+++ b/drivers/kdbus/test/test-kdbus-activator.c
@@ -0,0 +1,182 @@
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <errno.h>
+#include <assert.h>
+#include <poll.h>
+#include <sys/ioctl.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+#define POOL_SIZE (16 * 1024LU * 1024LU)
+static struct conn *make_activator(const char *path, const char *name)
+{
+	int fd, ret;
+	struct kdbus_cmd_hello *hello;
+	struct kdbus_item *item;
+	struct conn *conn;
+	size_t size, slen;
+
+	slen = strlen(name) + 1;
+	size = sizeof(*hello) + KDBUS_ITEM_SIZE(slen);
+
+	hello = alloca(size);
+	memset(hello, 0, size);
+
+	printf("-- opening ACTIVATOR bus connection %s\n", path);
+	fd = open(path, O_RDWR|O_CLOEXEC);
+	if (fd < 0) {
+		fprintf(stderr, "--- error %d (%m)\n", fd);
+		return NULL;
+	}
+
+	hello->size = size;
+	hello->pool_size = POOL_SIZE;
+	hello->conn_flags = KDBUS_HELLO_ACTIVATOR;
+
+	item = hello->items;
+	item->size = KDBUS_ITEM_SIZE(slen);
+	item->type = KDBUS_ITEM_NAME;
+	strcpy(item->str, name);
+
+	ret = ioctl(fd, KDBUS_CMD_HELLO, hello);
+	if (ret < 0) {
+		fprintf(stderr, "--- error when saying hello: %d (%m)\n", ret);
+		return NULL;
+	}
+	printf("-- Our peer ID for activator %s: %llu\n", name, (unsigned long long) hello->id);
+
+	conn = malloc(sizeof(*conn));
+	if (!conn) {
+		fprintf(stderr, "unable to malloc()!?\n");
+		return NULL;
+	}
+
+	conn->fd = fd;
+	conn->id = hello->id;
+
+	return conn;
+}
+
+
+int main(int argc, char *argv[])
+{
+	struct {
+		struct kdbus_cmd_make head;
+
+		/* bloom size item */
+		struct {
+			uint64_t size;
+			uint64_t type;
+			uint64_t bloom_size;
+		} bs;
+
+		/* name item */
+		uint64_t n_size;
+		uint64_t n_type;
+		char name[64];
+	} bus_make;
+	int fdc, ret;
+	char *bus;
+	struct conn *activator, *conn_a;
+	struct pollfd fds[2];
+	bool activator_done = false;
+
+	printf("-- opening /dev/" KBUILD_MODNAME "/control\n");
+	fdc = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+	if (fdc < 0) {
+		fprintf(stderr, "--- error %d (%m)\n", fdc);
+		return EXIT_FAILURE;
+	}
+
+	memset(&bus_make, 0, sizeof(bus_make));
+	bus_make.bs.size = sizeof(bus_make.bs);
+	bus_make.bs.type = KDBUS_ITEM_BLOOM_SIZE;
+	bus_make.bs.bloom_size = 64;
+
+	snprintf(bus_make.name, sizeof(bus_make.name), "%u-testbus", getuid());
+	bus_make.n_type = KDBUS_ITEM_MAKE_NAME;
+	bus_make.n_size = KDBUS_ITEM_HEADER_SIZE + strlen(bus_make.name) + 1;
+
+	bus_make.head.size = sizeof(struct kdbus_cmd_make) +
+			     sizeof(bus_make.bs) +
+			     bus_make.n_size;
+
+	printf("-- creating bus '%s'\n", bus_make.name);
+	ret = ioctl(fdc, KDBUS_CMD_BUS_MAKE, &bus_make);
+	if (ret) {
+		fprintf(stderr, "--- error %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	if (asprintf(&bus, "/dev/" KBUILD_MODNAME "/%s/bus", bus_make.name) < 0)
+		return EXIT_FAILURE;
+
+	activator = make_activator(bus, "foo.test.activator");
+
+	conn_a = connect_to_bus(bus, 0);
+	if (!activator || !conn_a)
+		return EXIT_FAILURE;
+
+	upload_policy(conn_a->fd, "foo.test.activator");
+	add_match_empty(conn_a->fd);
+
+	name_list(conn_a, KDBUS_NAME_LIST_NAMES |
+			KDBUS_NAME_LIST_UNIQUE |
+			KDBUS_NAME_LIST_ACTIVATORS |
+			KDBUS_NAME_LIST_QUEUED);
+
+	msg_send(conn_a, "foo.test.activator", 0xdeafbeef, KDBUS_DST_ID_NAME);
+
+	fds[0].fd = activator->fd;
+	fds[1].fd = conn_a->fd;
+
+	printf("-- entering poll loop ...\n");
+	for (;;) {
+		int i, nfds = sizeof(fds) / sizeof(fds[0]);
+
+		for (i = 0; i < nfds; i++) {
+			fds[i].events = POLLIN | POLLPRI;
+			fds[i].revents = 0;
+		}
+
+		ret = poll(fds, nfds, 3000);
+		if (ret <= 0)
+			break;
+
+		name_list(conn_a, KDBUS_NAME_LIST_NAMES);
+
+		if ((fds[0].revents & POLLIN) && !activator_done) {
+			printf("Starter was called back!\n");
+			ret = name_acquire(conn_a, "foo.test.activator", KDBUS_NAME_REPLACE_EXISTING);
+			if (ret != 0)
+				break;
+
+			activator_done = true;
+		}
+
+		if (fds[1].revents & POLLIN) {
+			msg_recv(conn_a);
+			break;
+		}
+	}
+
+	printf("-- closing bus connections\n");
+	close(activator->fd);
+	close(conn_a->fd);
+	free(activator);
+	free(conn_a);
+
+	printf("-- closing bus master\n");
+	close(fdc);
+	free(bus);
+
+	return EXIT_SUCCESS;
+}
diff --git a/drivers/kdbus/test/test-kdbus-benchmark.c b/drivers/kdbus/test/test-kdbus-benchmark.c
new file mode 100644
index 0000000..163734f
--- /dev/null
+++ b/drivers/kdbus/test/test-kdbus-benchmark.c
@@ -0,0 +1,336 @@
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <assert.h>
+#include <poll.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+#define SERVICE_NAME "foo.bar.echo"
+
+static char stress_payload[8192];
+
+struct stats {
+	uint64_t count;
+	uint64_t latency_acc;
+	uint64_t latency_low;
+	uint64_t latency_high;
+};
+
+static struct stats stats;
+
+static uint64_t
+timeval_diff(const struct timeval *hi, const struct timeval *lo)
+{
+	struct timeval r;
+
+	timersub(hi, lo, &r);
+
+	return (uint64_t) (r.tv_sec * 1000000ULL) +
+		(uint64_t) r.tv_usec;
+}
+
+static void reset_stats(void)
+{
+	stats.count = 0;
+	stats.latency_acc = 0;
+	stats.latency_low = UINT64_MAX;
+	stats.latency_high = 0;
+}
+
+static void dump_stats(void)
+{
+	if (stats.count > 0) {
+		printf("stats: %llu packets processed, latency (usecs) min/max/avg %llu/%llu/%llu\n",
+			(unsigned long long) stats.count,
+			(unsigned long long) stats.latency_low,
+			(unsigned long long) stats.latency_high,
+			(unsigned long long) (stats.latency_acc / stats.count));
+	} else {
+		printf("*** no packets received. bus stuck?\n");
+	}
+}
+
+static void add_stats(const struct timeval *tv)
+{
+	struct timeval now;
+	uint64_t diff;
+
+	gettimeofday(&now, NULL);
+	diff = timeval_diff(&now, tv);
+
+	stats.count++;
+	stats.latency_acc += diff;
+	if (stats.latency_low > diff)
+		stats.latency_low = diff;
+
+	if (stats.latency_high < diff)
+		stats.latency_high = diff;
+}
+
+static int
+send_echo_request(struct conn *conn, uint64_t dst_id)
+{
+	struct kdbus_msg *msg;
+	struct kdbus_item *item;
+	uint64_t size;
+	int memfd = -1;
+	int ret;
+	struct timeval now;
+
+	gettimeofday(&now, NULL);
+
+	size = sizeof(struct kdbus_msg);
+	size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+
+	ret = ioctl(conn->fd, KDBUS_CMD_MEMFD_NEW, &memfd);
+	if (ret < 0) {
+		fprintf(stderr, "KDBUS_CMD_MEMFD_NEW failed: %m\n");
+		return EXIT_FAILURE;
+	}
+
+	if (write(memfd, &now, sizeof(now)) != sizeof(now)) {
+		fprintf(stderr, "writing to memfd failed: %m\n");
+		return EXIT_FAILURE;
+	}
+
+	ret = ioctl(memfd, KDBUS_CMD_MEMFD_SEAL_SET, true);
+	if (ret < 0) {
+		fprintf(stderr, "memfd sealing failed: %m\n");
+		return EXIT_FAILURE;
+	}
+
+	size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_memfd));
+
+	msg = malloc(size);
+	if (!msg) {
+		fprintf(stderr, "unable to malloc()!?\n");
+		return EXIT_FAILURE;
+	}
+
+	memset(msg, 0, size);
+	msg->size = size;
+	msg->src_id = conn->id;
+	msg->dst_id = dst_id;
+	msg->payload_type = KDBUS_PAYLOAD_DBUS;
+
+	item = msg->items;
+
+	item->type = KDBUS_ITEM_PAYLOAD_VEC;
+	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
+	item->vec.address = (uintptr_t) stress_payload;
+	item->vec.size = sizeof(stress_payload);
+	item = KDBUS_ITEM_NEXT(item);
+
+	item->type = KDBUS_ITEM_PAYLOAD_MEMFD;
+	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_memfd);
+	item->memfd.size = sizeof(struct timeval);
+	item->memfd.fd = memfd;
+	item = KDBUS_ITEM_NEXT(item);
+
+	ret = ioctl(conn->fd, KDBUS_CMD_MSG_SEND, msg);
+	if (ret) {
+		fprintf(stderr, "error sending message: %d err %d (%m)\n", ret, errno);
+		return EXIT_FAILURE;
+	}
+
+	if (memfd >= 0)
+		close(memfd);
+	free(msg);
+
+	return 0;
+}
+
+static int
+handle_echo_reply(struct conn *conn)
+{
+	int ret;
+	uint64_t off;
+	struct kdbus_msg *msg;
+	const struct kdbus_item *item;
+
+	ret = ioctl(conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	if (ret < 0) {
+		fprintf(stderr, "error receiving message: %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	msg = (struct kdbus_msg *)(conn->buf + off);
+	item = msg->items;
+
+	KDBUS_ITEM_FOREACH(item, msg, items) {
+		switch (item->type) {
+		case KDBUS_ITEM_PAYLOAD_MEMFD: {
+			char *buf;
+
+			buf = mmap(NULL, item->memfd.size, PROT_READ, MAP_SHARED, item->memfd.fd, 0);
+			if (buf == MAP_FAILED) {
+				printf("mmap() fd=%i failed: %m", item->memfd.fd);
+				break;
+			}
+
+			add_stats((struct timeval *) buf);
+			munmap(buf, item->memfd.size);
+			close(item->memfd.fd);
+			break;
+		}
+
+		case KDBUS_ITEM_PAYLOAD_OFF: {
+			/* ignore */
+			break;
+		}
+		}
+	}
+
+	ret = ioctl(conn->fd, KDBUS_CMD_FREE, &off);
+	if (ret < 0) {
+		fprintf(stderr, "error free message: %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	struct {
+		struct kdbus_cmd_make head;
+
+		/* bloom size item */
+		struct {
+			uint64_t size;
+			uint64_t type;
+			uint64_t bloom_size;
+		} bs;
+
+		/* name item */
+		uint64_t n_size;
+		uint64_t n_type;
+		char name[64];
+	} bus_make;
+	int fdc, ret;
+	char *bus;
+	struct conn *conn_a;
+	struct conn *conn_b;
+	struct pollfd fds[2];
+	struct timeval start;
+	unsigned int i;
+
+	for (i = 0; i < sizeof(stress_payload); i++)
+		stress_payload[i] = i;
+
+	printf("-- opening /dev/" KBUILD_MODNAME "/control\n");
+	fdc = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+	if (fdc < 0) {
+		fprintf(stderr, "--- error %d (%m)\n", fdc);
+		return EXIT_FAILURE;
+	}
+
+	memset(&bus_make, 0, sizeof(bus_make));
+	bus_make.bs.size = sizeof(bus_make.bs);
+	bus_make.bs.type = KDBUS_ITEM_BLOOM_SIZE;
+	bus_make.bs.bloom_size = 64;
+
+	snprintf(bus_make.name, sizeof(bus_make.name), "%u-testbus", getuid());
+	bus_make.n_type = KDBUS_ITEM_MAKE_NAME;
+	bus_make.n_size = KDBUS_ITEM_HEADER_SIZE + strlen(bus_make.name) + 1;
+
+	bus_make.head.size = sizeof(struct kdbus_cmd_make) +
+			     sizeof(bus_make.bs) +
+			     bus_make.n_size;
+
+	printf("-- creating bus '%s'\n", bus_make.name);
+	ret = ioctl(fdc, KDBUS_CMD_BUS_MAKE, &bus_make);
+	if (ret) {
+		fprintf(stderr, "--- error %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	if (asprintf(&bus, "/dev/" KBUILD_MODNAME "/%s/bus", bus_make.name) < 0)
+		return EXIT_FAILURE;
+
+	conn_a = connect_to_bus(bus, 0);
+	if (!conn_a)
+		return EXIT_FAILURE;
+
+	conn_b = connect_to_bus(bus, 0);
+	if (!conn_b)
+		return EXIT_FAILURE;
+
+	upload_policy(conn_a->fd, SERVICE_NAME);
+
+	add_match_empty(conn_a->fd);
+	add_match_empty(conn_b->fd);
+
+	fds[0].fd = conn_a->fd;
+	fds[1].fd = conn_b->fd;
+
+	name_acquire(conn_a, SERVICE_NAME, 0);
+
+	gettimeofday(&start, NULL);
+	reset_stats();
+
+	ret = send_echo_request(conn_b, conn_a->id);
+	if (ret)
+		return EXIT_FAILURE;
+
+	printf("-- entering poll loop ...\n");
+
+	while (1) {
+		struct timeval now;
+		unsigned int nfds = sizeof(fds) / sizeof(fds[0]);
+		unsigned int i;
+
+		for (i = 0; i < nfds; i++) {
+			fds[i].events = POLLIN | POLLPRI | POLLHUP;
+			fds[i].revents = 0;
+		}
+
+		ret = poll(fds, nfds, 10);
+		if (ret < 0)
+			break;
+
+		if (fds[0].revents & POLLIN) {
+			ret = handle_echo_reply(conn_a);
+			if (ret)
+				break;
+
+			ret = send_echo_request(conn_b, conn_a->id);
+			if (ret)
+				break;
+		}
+
+		gettimeofday(&now, NULL);
+		if (timeval_diff(&now, &start) / 1000ULL > 1000ULL) {
+			start.tv_sec = now.tv_sec;
+			start.tv_usec = now.tv_usec;
+			dump_stats();
+			reset_stats();
+		}
+	}
+
+	printf("-- closing bus connections\n");
+
+	close(conn_a->fd);
+	close(conn_b->fd);
+
+	free(conn_a);
+	free(conn_b);
+
+	printf("-- closing bus master\n");
+	close(fdc);
+	free(bus);
+
+	return EXIT_SUCCESS;
+}
diff --git a/drivers/kdbus/test/test-kdbus-chat.c b/drivers/kdbus/test/test-kdbus-chat.c
new file mode 100644
index 0000000..d9e6b12
--- /dev/null
+++ b/drivers/kdbus/test/test-kdbus-chat.c
@@ -0,0 +1,171 @@
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <errno.h>
+#include <assert.h>
+#include <poll.h>
+#include <sys/ioctl.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+int main(int argc, char *argv[])
+{
+	struct {
+		struct kdbus_cmd_make head;
+
+		/* bloom size item */
+		struct {
+			uint64_t size;
+			uint64_t type;
+			uint64_t bloom_size;
+		} bs;
+
+		/* name item */
+		uint64_t n_size;
+		uint64_t n_type;
+		char name[64];
+	} bus_make;
+	int fdc, ret, cookie;
+	char *bus;
+	struct conn *conn_a, *conn_b;
+	struct pollfd fds[2];
+	int count;
+	int r;
+
+	printf("-- opening /dev/" KBUILD_MODNAME "/control\n");
+	fdc = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+	if (fdc < 0) {
+		fprintf(stderr, "--- error %d (%m)\n", fdc);
+		return EXIT_FAILURE;
+	}
+
+	memset(&bus_make, 0, sizeof(bus_make));
+	bus_make.bs.size = sizeof(bus_make.bs);
+	bus_make.bs.type = KDBUS_ITEM_BLOOM_SIZE;
+	bus_make.bs.bloom_size = 64;
+
+	snprintf(bus_make.name, sizeof(bus_make.name), "%u-testbus", getuid());
+	bus_make.n_type = KDBUS_ITEM_MAKE_NAME;
+	bus_make.n_size = KDBUS_ITEM_HEADER_SIZE + strlen(bus_make.name) + 1;
+
+	bus_make.head.size = sizeof(struct kdbus_cmd_make) +
+			     sizeof(bus_make.bs) +
+			     bus_make.n_size;
+
+	printf("-- creating bus '%s'\n", bus_make.name);
+	ret = ioctl(fdc, KDBUS_CMD_BUS_MAKE, &bus_make);
+	if (ret) {
+		fprintf(stderr, "--- error %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	if (asprintf(&bus, "/dev/" KBUILD_MODNAME "/%s/bus", bus_make.name) < 0)
+		return EXIT_FAILURE;
+
+	conn_a = connect_to_bus(bus, 0);
+	conn_b = connect_to_bus(bus, 0);
+	if (!conn_a || !conn_b)
+		return EXIT_FAILURE;
+
+	r = upload_policy(conn_a->fd, "foo.bar.test");
+	if (r < 0)
+		return EXIT_FAILURE;
+	r = upload_policy(conn_a->fd, "foo.bar.baz");
+	if (r < 0)
+		return EXIT_FAILURE;
+	r = upload_policy(conn_a->fd, "foo.bar.double");
+	if (r < 0)
+		return EXIT_FAILURE;
+
+	r = name_acquire(conn_a, "foo.bar.test", KDBUS_NAME_ALLOW_REPLACEMENT);
+	if (r < 0)
+		return EXIT_FAILURE;
+	r = name_acquire(conn_a, "foo.bar.baz", 0);
+	if (r < 0)
+		return EXIT_FAILURE;
+	r = name_acquire(conn_b, "foo.bar.baz", KDBUS_NAME_QUEUE);
+	if (r < 0)
+		return EXIT_FAILURE;
+
+	r = name_acquire(conn_a, "foo.bar.double", 0);
+	if (r < 0)
+		return EXIT_FAILURE;
+	r = name_acquire(conn_a, "foo.bar.double", 0);
+	if (r != -EALREADY)
+		return EXIT_FAILURE;
+
+	r = name_release(conn_a, "foo.bar.double");
+	if (r < 0)
+		return EXIT_FAILURE;
+	r = name_release(conn_a, "foo.bar.double");
+	if (r != -ESRCH)
+		return EXIT_FAILURE;
+
+	name_list(conn_b, KDBUS_NAME_LIST_UNIQUE|
+			  KDBUS_NAME_LIST_NAMES|
+			  KDBUS_NAME_LIST_QUEUED|
+			  KDBUS_NAME_LIST_ACTIVATORS);
+
+	add_match_empty(conn_a->fd);
+	add_match_empty(conn_b->fd);
+
+	cookie = 0;
+	msg_send(conn_b, NULL, 0xc0000000 | cookie, KDBUS_DST_ID_BROADCAST);
+
+	fds[0].fd = conn_a->fd;
+	fds[1].fd = conn_b->fd;
+
+	printf("-- entering poll loop ...\n");
+
+	for (count = 0;; count++) {
+		int i, nfds = sizeof(fds) / sizeof(fds[0]);
+
+		for (i = 0; i < nfds; i++) {
+			fds[i].events = POLLIN | POLLPRI | POLLHUP;
+			fds[i].revents = 0;
+		}
+
+		ret = poll(fds, nfds, 3000);
+		if (ret <= 0)
+			break;
+
+		if (fds[0].revents & POLLIN) {
+			if (count > 2)
+				name_release(conn_a, "foo.bar.baz");
+
+			msg_recv(conn_a);
+			msg_send(conn_a, NULL, 0xc0000000 | cookie++, conn_b->id);
+		}
+
+		if (fds[1].revents & POLLIN) {
+			msg_recv(conn_b);
+			msg_send(conn_b, NULL, 0xc0000000 | cookie++, conn_a->id);
+		}
+
+		name_list(conn_b, KDBUS_NAME_LIST_UNIQUE|
+				  KDBUS_NAME_LIST_NAMES|
+				  KDBUS_NAME_LIST_QUEUED|
+				  KDBUS_NAME_LIST_ACTIVATORS);
+
+		if (count > 10)
+			break;
+	}
+
+	printf("-- closing bus connections\n");
+	close(conn_a->fd);
+	close(conn_b->fd);
+	free(conn_a);
+	free(conn_b);
+
+	printf("-- closing bus master\n");
+	close(fdc);
+	free(bus);
+
+	return EXIT_SUCCESS;
+}
diff --git a/drivers/kdbus/test/test-kdbus-daemon.c b/drivers/kdbus/test/test-kdbus-daemon.c
new file mode 100644
index 0000000..fa29dde
--- /dev/null
+++ b/drivers/kdbus/test/test-kdbus-daemon.c
@@ -0,0 +1,115 @@
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <errno.h>
+#include <assert.h>
+#include <poll.h>
+#include <sys/ioctl.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+
+int main(int argc, char *argv[])
+{
+	struct {
+		struct kdbus_cmd_make head;
+
+		/* bloom size item */
+		struct {
+			uint64_t size;
+			uint64_t type;
+			uint64_t bloom_size;
+		} bs;
+
+		uint64_t n_size;
+		uint64_t n_type;
+		char name[64];
+	} bus_make;
+	int fd_owner;
+	char *bus;
+	struct conn *conn;
+	struct pollfd fds[2];
+	int count;
+	int ret;
+
+	printf("Starting Test Bus Daemon (press ENTER to exit)\n");
+
+	fd_owner = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+	if (fd_owner < 0) {
+		fprintf(stderr, "/dev/" KBUILD_MODNAME "/control: %m\n");
+		return EXIT_FAILURE;
+	}
+
+	memset(&bus_make, 0, sizeof(bus_make));
+	bus_make.bs.size = sizeof(bus_make.bs);
+	bus_make.bs.type = KDBUS_ITEM_BLOOM_SIZE;
+	bus_make.bs.bloom_size = 64;
+
+	snprintf(bus_make.name, sizeof(bus_make.name), "%u-testbus", getuid());
+	bus_make.n_type = KDBUS_ITEM_MAKE_NAME;
+	bus_make.n_size = KDBUS_ITEM_HEADER_SIZE + strlen(bus_make.name) + 1;
+
+	bus_make.head.size = sizeof(struct kdbus_cmd_make) +
+			     sizeof(bus_make.bs) +
+			     bus_make.n_size;
+
+	ret = ioctl(fd_owner, KDBUS_CMD_BUS_MAKE, &bus_make);
+	if (ret) {
+		fprintf(stderr, "KDBUS_CMD_BUS_MAKE: %m\n");
+		return EXIT_FAILURE;
+	}
+	printf("  Created bus '%s'\n", bus_make.name);
+
+	if (asprintf(&bus, "/dev/" KBUILD_MODNAME "/%s/bus", bus_make.name) < 0)
+		return EXIT_FAILURE;
+
+	conn = connect_to_bus(bus, 0);
+	if (!conn)
+		return EXIT_FAILURE;
+	printf("  Created connection %llu on bus '%s'\n", (unsigned long long)conn->id, bus_make.name);
+
+	upload_policy(conn->fd, "com.example.kdbus-test");
+	name_acquire(conn, "com.example.kdbus-test", 0);
+	printf("  Aquired name: com.example.kdbus-test\n");
+
+	fds[0].fd = conn->fd;
+	fds[1].fd = STDIN_FILENO;
+
+	printf("  Monitoring connections:\n");
+
+	for (count = 0;; count++) {
+		int i, nfds = sizeof(fds) / sizeof(fds[0]);
+
+		for (i = 0; i < nfds; i++) {
+			fds[i].events = POLLIN | POLLPRI | POLLHUP;
+			fds[i].revents = 0;
+		}
+
+		ret = poll(fds, nfds, -1);
+		if (ret <= 0)
+			break;
+
+		if (fds[0].revents & POLLIN)
+			msg_recv(conn);
+
+		/* stdin */
+		if (fds[1].revents & POLLIN)
+			break;
+	}
+
+	printf("  Closing bus connection\n");
+	close(conn->fd);
+	free(conn);
+
+	printf("  Closing bus\n");
+	close(fd_owner);
+	free(bus);
+
+	return EXIT_SUCCESS;
+}
diff --git a/drivers/kdbus/test/test-kdbus-fuzz.c b/drivers/kdbus/test/test-kdbus-fuzz.c
new file mode 100644
index 0000000..811ab55
--- /dev/null
+++ b/drivers/kdbus/test/test-kdbus-fuzz.c
@@ -0,0 +1,217 @@
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <errno.h>
+#include <assert.h>
+#include <poll.h>
+#include <sys/ioctl.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+static unsigned int ioctl_cmds[] = {
+	KDBUS_CMD_BUS_MAKE,
+	KDBUS_CMD_NS_MAKE,
+	KDBUS_CMD_EP_MAKE,
+	KDBUS_CMD_HELLO,
+	KDBUS_CMD_MSG_SEND,
+	KDBUS_CMD_MSG_RECV,
+	KDBUS_CMD_NAME_ACQUIRE,
+	KDBUS_CMD_NAME_RELEASE,
+	KDBUS_CMD_NAME_LIST,
+	KDBUS_CMD_CONN_INFO,
+	KDBUS_CMD_MATCH_ADD,
+	KDBUS_CMD_MATCH_REMOVE,
+	KDBUS_CMD_EP_POLICY_SET,
+};
+
+static const char *ioctl_name(unsigned int ioctl)
+{
+	switch(ioctl) {
+	case KDBUS_CMD_BUS_MAKE:
+		return "BUS_MAKE";
+	case KDBUS_CMD_NS_MAKE:
+		return "NS_MAKE";
+	case KDBUS_CMD_EP_MAKE:
+		return "EP_MAKE";
+	case KDBUS_CMD_HELLO:
+		return "HELLO";
+	case KDBUS_CMD_MSG_SEND:
+		return "MSG_SEND";
+	case KDBUS_CMD_MSG_RECV:
+		return "MSG_RECV";
+	case KDBUS_CMD_NAME_ACQUIRE:
+		return "NAME_ACQUIRE";
+	case KDBUS_CMD_NAME_RELEASE:
+		return "NAME_RELEASE";
+	case KDBUS_CMD_NAME_LIST:
+		return "NAME_LIST";
+	case KDBUS_CMD_CONN_INFO:
+		return "NAME_INFO";
+	case KDBUS_CMD_MATCH_ADD:
+		return "MATCH_ADD";
+	case KDBUS_CMD_MATCH_REMOVE:
+		return "MATCH_REMOVE";
+	case KDBUS_CMD_EP_POLICY_SET:
+		return "EP_POLICY_SET";
+	default:
+		return "unknown";
+	}
+}
+
+static int fd_table[100] = { -1 };
+
+static void add_fd(int fd)
+{
+	unsigned int i;
+
+	for (i = 0; i < ELEMENTSOF(fd_table); i++)
+		if (fd_table[i] == -1)  {
+			fd_table[i] = fd;
+			return;
+		}
+}
+
+static int make_bus(void)
+{
+	struct {
+		struct kdbus_cmd_make head;
+
+		/* bloom size item */
+		struct {
+			uint64_t size;
+			uint64_t type;
+			uint64_t bloom_size;
+		} bs;
+
+		/* name item */
+		uint64_t n_size;
+		uint64_t n_type;
+		char name[64];
+	} bus_make;
+	char name[10];
+	char *bus;
+	unsigned int i;
+	int ret, fdc;
+
+	printf("-- opening /dev/" KBUILD_MODNAME "/control\n");
+	fdc = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+	if (fdc < 0) {
+		fprintf(stderr, "--- error %d (%m)\n", fdc);
+		return EXIT_FAILURE;
+	}
+
+	add_fd(fdc);
+
+	memset(name, 0, sizeof(name));
+
+	for(i = 0; i < sizeof(name) - 1; i++)
+		name[i] =( random() % ('z' - 'a')) + 'a';
+
+	memset(&bus_make, 0, sizeof(bus_make));
+	snprintf(bus_make.name, sizeof(bus_make.name), "%u-%s", getuid(), name);
+	bus_make.head.flags = KDBUS_MAKE_ACCESS_WORLD;
+	bus_make.head.size = sizeof(struct kdbus_cmd_make) + strlen(bus_make.name) + 1;
+
+	bus_make.bs.size = sizeof(bus_make.bs);
+	bus_make.bs.type = KDBUS_ITEM_BLOOM_SIZE;
+	bus_make.bs.bloom_size = 64;
+
+	printf("-- creating bus '%s'\n", bus_make.name);
+	ret = ioctl(fdc, KDBUS_CMD_BUS_MAKE, &bus_make);
+	if (ret) {
+		fprintf(stderr, "--- error %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	if (asprintf(&bus, "/dev/" KBUILD_MODNAME "/%s/bus", bus_make.name) < 0)
+		return EXIT_FAILURE;
+
+	for (ret = 0; ret < random() % 20; ret++) {
+		struct conn *conn = connect_to_bus(bus, 0);
+		if (conn)
+			add_fd(conn->fd);
+	}
+
+	return 0;
+}
+
+static int get_random_fd(void)
+{
+	unsigned int i, count = 0;
+
+	for (i = 0; i < ELEMENTSOF(fd_table); i++)
+		if (fd_table[i] != -1)
+			count++;
+
+	if (count > 0)
+		count = random() % count;
+
+	for (i = 0; i < ELEMENTSOF(fd_table); i++)
+		if (fd_table[i] != -1)
+			if (count-- == 0)
+				return fd_table[i];
+
+	return -1;
+}
+
+static void close_random_fd(void)
+{
+	unsigned int i, count = 0;
+
+	for (i = 0; i < ELEMENTSOF(fd_table); i++)
+		if (fd_table[i] != -1)
+			count++;
+
+	if (count > 0)
+		count = random() % count;
+
+	for (i = 0; i < ELEMENTSOF(fd_table); i++)
+		if (fd_table[i] != -1)
+			if (count-- == 0) {
+				close(fd_table[i]);
+				fd_table[i] = -1;
+				return;
+			}
+}
+
+int main(int argc, char *argv[])
+{
+	unsigned int i;
+
+	srandom(time(NULL));
+
+	for (i = 0; i < ELEMENTSOF(fd_table); i++)
+		fd_table[i] = -1;
+
+	make_bus();
+	make_bus();
+
+	while(1) {
+		char buf[0xffff];
+		int fd = get_random_fd();
+		int cmd = ioctl_cmds[random() % ELEMENTSOF(ioctl_cmds)];
+		int ret;
+
+		if (random() % 1000 == 0)
+			make_bus();
+
+		if (random() % 1000 == 0)
+			close_random_fd();
+
+		for (i = 0; i < sizeof(buf); i++)
+			buf[i] = random();
+
+		errno = 0;
+		ret = ioctl(fd, cmd, buf);
+		printf(" ioctl(%13s) on fd %d returned\t%d\t(%m)\n",
+			ioctl_name(cmd), fd, ret);
+	}
+
+	return EXIT_SUCCESS;
+}
diff --git a/drivers/kdbus/test/test-kdbus-monitor.c b/drivers/kdbus/test/test-kdbus-monitor.c
new file mode 100644
index 0000000..754fba7
--- /dev/null
+++ b/drivers/kdbus/test/test-kdbus-monitor.c
@@ -0,0 +1,207 @@
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <assert.h>
+#include <poll.h>
+#include <signal.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+struct pcap_header {
+	uint32_t	magic;
+	uint16_t	major;
+	uint16_t	minor;
+	uint32_t	tz_offset;
+	uint32_t	ts_accurancy;
+	uint32_t	snapshot_len;
+	uint32_t	header_type;
+};
+
+struct pcap_entry {
+	uint32_t	tv_sec;
+	uint32_t	tv_usec;
+	uint32_t	len;
+	uint32_t	total_len;
+	uint8_t		data[0];
+};
+
+static void usage(const char *argv0)
+{
+	fprintf(stderr, "Usage: %s <bus-node> <output-file>\n", argv0);
+	fprintf(stderr, "       bus-node        The device node to connect to\n");
+	fprintf(stderr, "       output-file     The output file to write to\n");
+}
+
+static int dump_packet(struct conn *conn, int fd)
+{
+	int ret;
+	uint64_t off, size;
+	struct kdbus_msg *msg;
+	const struct kdbus_item *item;
+	struct timeval now;
+	struct pcap_entry entry;
+	uint64_t to_write;
+	void *data_to_write;
+
+	gettimeofday(&now, NULL);
+	entry.tv_sec = now.tv_sec;
+	entry.tv_usec = now.tv_usec;
+
+	ret = ioctl(conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	if (ret < 0) {
+		fprintf(stderr, "error receiving message: %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	msg = (struct kdbus_msg *)(conn->buf + off);
+	item = msg->items;
+	size = msg->size;
+
+	/* collect length of oob payloads */
+	KDBUS_ITEM_FOREACH(item, msg, items)
+		if (item->type == KDBUS_ITEM_PAYLOAD_OFF)
+			size += KDBUS_ALIGN8(item->vec.size);
+
+	entry.len = size;
+	entry.total_len = size;
+
+	size = write(fd, &entry, sizeof(entry));
+	if (size != sizeof(entry)) {
+		fprintf(stderr, "Unable to write: %m\n");
+		return EXIT_FAILURE;
+	}
+
+	size = write(fd, msg, msg->size);
+	if (size != msg->size) {
+		fprintf(stderr, "Unable to write: %m\n");
+		return EXIT_FAILURE;
+	}
+
+	KDBUS_ITEM_FOREACH(item, msg, items) {
+		switch (item->type) {
+		/* close all memfds */
+		case KDBUS_ITEM_PAYLOAD_MEMFD:
+			close(item->memfd.fd);
+			break;
+		case KDBUS_ITEM_PAYLOAD_OFF:
+			if (item->vec.offset != ~0ULL) {
+				to_write = item->vec.size;
+				data_to_write = (void *) msg + item->vec.offset;
+			} else {
+				/*add data padding to file*/
+				to_write = item->vec.size % 8;
+				data_to_write = "\0\0\0\0\0\0\0";
+			}
+
+			size = write(fd, data_to_write, to_write);
+			if (size != to_write) {
+				fprintf(stderr, "Unable to write: %m\n");
+				return EXIT_FAILURE;
+			}
+			break;
+		}
+	}
+
+	ret = ioctl(conn->fd, KDBUS_CMD_FREE, &off);
+	if (ret < 0) {
+		fprintf(stderr, "error free message: %d (%m)\n", ret);
+		return EXIT_FAILURE;
+	}
+
+	return 0;
+}
+
+static struct conn *conn;
+static int output_fd;
+static unsigned long long count = 0;
+
+static void do_exit(int foo)
+{
+	fprintf(stderr, "\n%llu packets received and dumped.\n", count);
+	fprintf(stderr, "-- closing bus connections\n");
+	close(conn->fd);
+	free(conn);
+	close(output_fd);
+}
+
+int main(int argc, char **argv)
+{
+	struct pcap_header header;
+	int output_fd;
+	int ret;
+	char *bus, *file;
+	struct pollfd fd;
+
+	if (argc < 3) {
+		usage(argv[0]);
+		return EXIT_FAILURE;
+	}
+
+	bus = argv[1];
+	file = argv[2];
+
+	output_fd = open(file, O_CREAT | O_RDWR, 0644);
+	if (output_fd < 0) {
+		fprintf(stderr, "Unable to open '%s': %m\n", file);
+		return EXIT_FAILURE;
+	}
+
+	conn = connect_to_bus(bus, KDBUS_HELLO_MONITOR);
+	if (!conn) {
+		fprintf(stderr, "Unable to connect as monitor: %m\n");
+		return EXIT_FAILURE;
+	}
+
+	memset(&header, 0, sizeof(header));
+	header.magic = 0xa1b2c3d4;
+	header.major = 2;
+	header.minor = 4;
+	header.snapshot_len = 0xffffffff;
+	header.header_type = 0x12345678;			/* FIXME */
+
+	ret = write(output_fd, &header, sizeof(header));
+	if (ret != sizeof(header)) {
+		fprintf(stderr, "Unable to write to '%s': %m\n", file);
+		return EXIT_FAILURE;
+	}
+
+	signal(SIGINT, do_exit);
+	fprintf(stderr, "Capturing. Press ^C to stop ...\n");
+
+	fd.fd = conn->fd;
+
+	while (1) {
+		fd.events = POLLIN | POLLPRI | POLLHUP;
+		fd.revents = 0;
+
+		ret = poll(&fd, 1, -1);
+		if (ret < 0)
+			break;
+
+		if (fd.revents & POLLIN) {
+			ret = dump_packet(conn, output_fd);
+			if (ret != 0) {
+				fprintf(stderr, "Unable to dump packet '%s': %m\n", file);
+				return EXIT_FAILURE;
+			}
+
+			count++;
+		}
+
+		if (fd.revents & (POLLHUP | POLLERR))
+			return EXIT_FAILURE;
+	}
+
+	return 0;
+}
diff --git a/drivers/kdbus/test/test-kdbus.c b/drivers/kdbus/test/test-kdbus.c
new file mode 100644
index 0000000..367f589
--- /dev/null
+++ b/drivers/kdbus/test/test-kdbus.c
@@ -0,0 +1,1225 @@
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <errno.h>
+#include <assert.h>
+#include <poll.h>
+#include <limits.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <getopt.h>
+
+#include "kdbus-util.h"
+#include "kdbus-enum.h"
+
+enum {
+	CHECK_OK,
+	CHECK_SKIP,
+	CHECK_ERR,
+};
+
+enum {
+	CHECK_CREATE_BUS	= 1 << 0,
+	CHECK_CREATE_CONN	= 1 << 1,
+};
+
+struct kdbus_conn {
+	int fd;
+	struct kdbus_cmd_hello hello;
+	void *buf;
+	size_t size;
+};
+
+struct kdbus_check_env {
+	char *buspath;
+	int control_fd;
+	struct kdbus_conn *conn;
+};
+
+
+struct kdbus_check {
+	const char *name;
+	int (*func)(struct kdbus_check_env *env);
+	unsigned int flags;
+};
+
+#define POOL_SIZE (16 * 1024LU * 1024LU)
+#define ATTACH_FLAGS 	KDBUS_ATTACH_TIMESTAMP	|	\
+			KDBUS_ATTACH_CREDS	|	\
+			KDBUS_ATTACH_NAMES	|	\
+			KDBUS_ATTACH_COMM	|	\
+			KDBUS_ATTACH_EXE	|	\
+			KDBUS_ATTACH_CMDLINE	|	\
+			KDBUS_ATTACH_CAPS	|	\
+			KDBUS_ATTACH_CGROUP	|	\
+			KDBUS_ATTACH_SECLABEL	|	\
+			KDBUS_ATTACH_AUDIT
+
+#define ASSERT_RETURN(cond)		\
+	if (!(cond)) {			\
+		fprintf(stderr, "Assertion '%s' failed in %s(), line %d\n", #cond, __func__, __LINE__);	\
+		return CHECK_ERR;	\
+	}
+
+static struct kdbus_conn *make_conn(const char *buspath, uint64_t flags)
+{
+	int ret;
+	struct kdbus_conn *conn;
+
+	conn = malloc(sizeof(*conn));
+	if (!conn) {
+		fprintf(stderr, "unable to malloc()!?\n");
+		return NULL;
+	}
+
+	memset(conn, 0, sizeof(*conn));
+
+	conn->fd = open(buspath, O_RDWR|O_CLOEXEC);
+	if (conn->fd < 0) {
+		fprintf(stderr, "--- error %d (%m)\n", conn->fd);
+		return NULL;
+	}
+
+	conn->hello.conn_flags = flags;
+
+	conn->hello.attach_flags = KDBUS_ATTACH_TIMESTAMP |
+				   KDBUS_ATTACH_CREDS |
+				   KDBUS_ATTACH_NAMES |
+				   KDBUS_ATTACH_COMM |
+				   KDBUS_ATTACH_EXE |
+				   KDBUS_ATTACH_CMDLINE |
+				   KDBUS_ATTACH_CAPS |
+				   KDBUS_ATTACH_CGROUP |
+				   KDBUS_ATTACH_SECLABEL |
+				   KDBUS_ATTACH_AUDIT;
+
+	conn->hello.size = sizeof(struct kdbus_cmd_hello);
+	conn->hello.pool_size = POOL_SIZE;
+
+	ret = ioctl(conn->fd, KDBUS_CMD_HELLO, &conn->hello);
+	if (ret < 0) {
+		fprintf(stderr, "--- error when saying hello: %d (%m)\n", ret);
+		return NULL;
+	}
+
+	conn->buf = mmap(NULL, POOL_SIZE, PROT_READ, MAP_SHARED, conn->fd, 0);
+	if (conn->buf == MAP_FAILED) {
+		free(conn);
+		fprintf(stderr, "--- error mmap (%m)\n");
+		return NULL;
+	}
+
+	return conn;
+}
+
+static void free_conn(struct kdbus_conn *conn)
+{
+	if (conn->buf)
+		munmap(conn->buf, conn->size);
+
+	if (conn->fd >= 0)
+		close(conn->fd);
+
+	free(conn);
+}
+
+static int conn_is_name_owner(const struct kdbus_conn *conn, uint64_t flags, const char *n)
+{
+	struct kdbus_cmd_name_list cmd_list;
+	struct kdbus_name_list *list;
+	struct kdbus_cmd_name *name;
+	int found = 0;
+	int ret;
+
+	cmd_list.flags = flags;
+
+	ret = ioctl(conn->fd, KDBUS_CMD_NAME_LIST, &cmd_list);
+	ASSERT_RETURN(ret == 0);
+
+	list = (struct kdbus_name_list *)(conn->buf + cmd_list.offset);
+	KDBUS_ITEM_FOREACH(name, list, names) {
+		if (name->size == sizeof(struct kdbus_cmd_name))
+			continue;
+
+		if (name->owner_id == conn->hello.id && strcmp(n, name->name) == 0) {
+			found = 1;
+			break;
+		}
+	}
+
+	ret = ioctl(conn->fd, KDBUS_CMD_FREE, &cmd_list.offset);
+	ASSERT_RETURN(ret == 0);
+
+	return found ? 0 : -1;
+}
+
+static int send_message(const struct kdbus_conn *conn,
+			const char *name,
+			uint64_t cookie,
+			uint64_t dst_id)
+{
+	struct kdbus_msg *msg;
+	const char ref1[1024 * 1024 + 3] = "0123456789_0";
+	const char ref2[] = "0123456789_1";
+	struct kdbus_item *item;
+	uint64_t size;
+	int memfd = -1;
+	int ret;
+
+	size = sizeof(struct kdbus_msg);
+	size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+	size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+	size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+
+	if (dst_id == KDBUS_DST_ID_BROADCAST)
+		size += KDBUS_ITEM_HEADER_SIZE + 64;
+	else {
+		ret = ioctl(conn->fd, KDBUS_CMD_MEMFD_NEW, &memfd);
+		ASSERT_RETURN(ret == 0);
+
+		ASSERT_RETURN(write(memfd, "kdbus memfd 1234567", 19) == 19);
+
+		ret = ioctl(memfd, KDBUS_CMD_MEMFD_SEAL_SET, 1);
+		ASSERT_RETURN(ret == 0);
+
+		size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_memfd));
+	}
+
+	if (name)
+		size += KDBUS_ITEM_SIZE(strlen(name) + 1);
+
+	msg = malloc(size);
+	ASSERT_RETURN(msg != NULL);
+
+	memset(msg, 0, size);
+	msg->size = size;
+	msg->src_id = conn->hello.id;
+	msg->dst_id = name ? 0 : dst_id;
+	msg->cookie = cookie;
+	msg->payload_type = KDBUS_PAYLOAD_DBUS;
+
+	item = msg->items;
+
+	if (name) {
+		item->type = KDBUS_ITEM_DST_NAME;
+		item->size = KDBUS_ITEM_HEADER_SIZE + strlen(name) + 1;
+		strcpy(item->str, name);
+		item = KDBUS_ITEM_NEXT(item);
+	}
+
+	item->type = KDBUS_ITEM_PAYLOAD_VEC;
+	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
+	item->vec.address = (uintptr_t)&ref1;
+	item->vec.size = sizeof(ref1);
+	item = KDBUS_ITEM_NEXT(item);
+
+	/* data padding for ref1 */
+	item->type = KDBUS_ITEM_PAYLOAD_VEC;
+	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
+	item->vec.address = (uintptr_t)NULL;
+	item->vec.size =  KDBUS_ALIGN8(sizeof(ref1)) - sizeof(ref1);
+	item = KDBUS_ITEM_NEXT(item);
+
+	item->type = KDBUS_ITEM_PAYLOAD_VEC;
+	item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);
+	item->vec.address = (uintptr_t)&ref2;
+	item->vec.size = sizeof(ref2);
+	item = KDBUS_ITEM_NEXT(item);
+
+	if (dst_id == KDBUS_DST_ID_BROADCAST) {
+		item->type = KDBUS_ITEM_BLOOM;
+		item->size = KDBUS_ITEM_HEADER_SIZE + 64;
+	} else {
+		item->type = KDBUS_ITEM_PAYLOAD_MEMFD;
+		item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_memfd);
+		item->memfd.size = 16;
+		item->memfd.fd = memfd;
+	}
+	item = KDBUS_ITEM_NEXT(item);
+
+	ret = ioctl(conn->fd, KDBUS_CMD_MSG_SEND, msg);
+	ASSERT_RETURN(ret == 0);
+
+	if (memfd >= 0)
+		close(memfd);
+	free(msg);
+
+	return 0;
+}
+
+/* -----------------------------------8<------------------------------- */
+static int check_nsmake(struct kdbus_check_env *env)
+{
+	int fd, fd2;
+	struct {
+		struct kdbus_cmd_make head;
+
+		/* name item */
+		uint64_t n_size;
+		uint64_t n_type;
+		char name[64];
+	} ns_make;
+	int ret;
+
+	fd = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+	ASSERT_RETURN(fd >= 0);
+
+	memset(&ns_make, 0, sizeof(ns_make));
+
+	ns_make.n_type = KDBUS_ITEM_MAKE_NAME;
+
+	/* create a new namespace */
+	snprintf(ns_make.name, sizeof(ns_make.name), "blah");
+	ns_make.n_size = KDBUS_ITEM_HEADER_SIZE + strlen(ns_make.name) + 1;
+	ns_make.head.size = sizeof(struct kdbus_cmd_make) + ns_make.n_size;
+	ret = ioctl(fd, KDBUS_CMD_NS_MAKE, &ns_make);
+	if (ret < 0 && errno == EPERM)
+		return CHECK_SKIP;
+	ASSERT_RETURN(ret == 0);
+
+	ASSERT_RETURN(access("/dev/" KBUILD_MODNAME "/ns/blah/control", F_OK) == 0);
+
+	/* can't use the same fd for ns make twice */
+	ret = ioctl(fd, KDBUS_CMD_NS_MAKE, &ns_make);
+	ASSERT_RETURN(ret == -1 && errno == EBADFD);
+
+	/* can't register the same name twice */
+	fd2 = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+	ret = ioctl(fd2, KDBUS_CMD_NS_MAKE, &ns_make);
+	ASSERT_RETURN(ret == -1 && errno == EEXIST);
+	close(fd2);
+
+	close(fd);
+	ASSERT_RETURN(access("/dev/" KBUILD_MODNAME "/ns/blah/control", F_OK) < 0);
+
+	return CHECK_OK;
+}
+
+/* -----------------------------------8<------------------------------- */
+
+static int check_busmake(struct kdbus_check_env *env)
+{
+	struct {
+		struct kdbus_cmd_make head;
+
+		/* bloom size item */
+		struct {
+			uint64_t size;
+			uint64_t type;
+			uint64_t bloom_size;
+		} bs;
+
+		/* name item */
+		uint64_t n_size;
+		uint64_t n_type;
+		char name[64];
+	} bus_make;
+	char s[PATH_MAX];
+	int ret;
+
+	env->control_fd = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+	ASSERT_RETURN(env->control_fd >= 0);
+
+	memset(&bus_make, 0, sizeof(bus_make));
+
+	bus_make.bs.size = sizeof(bus_make.bs);
+	bus_make.bs.type = KDBUS_ITEM_BLOOM_SIZE;
+	bus_make.bs.bloom_size = 64;
+
+	bus_make.n_type = KDBUS_ITEM_MAKE_NAME;
+
+#if 0
+	/* check some illegal names */
+	snprintf(bus_make.name, sizeof(bus_make.name), "foo");
+	bus_make.n_size = KDBUS_ITEM_HEADER_SIZE + strlen(bus_make.name) + 1;
+	bus_make.head.size = sizeof(struct kdbus_cmd_make) + bus_make.n_size;
+	ret = ioctl(env->control_fd, KDBUS_CMD_BUS_MAKE, &bus_make);
+	ASSERT_RETURN(ret == -1 && errno == EINVAL);
+#endif
+
+	/* create a new bus */
+	snprintf(bus_make.name, sizeof(bus_make.name), "%u-blah", getuid());
+	bus_make.n_size = KDBUS_ITEM_HEADER_SIZE + strlen(bus_make.name) + 1;
+	bus_make.head.size = sizeof(struct kdbus_cmd_make) +
+			     sizeof(uint64_t) * 3 +
+			     bus_make.n_size;
+	ret = ioctl(env->control_fd, KDBUS_CMD_BUS_MAKE, &bus_make);
+	ASSERT_RETURN(ret == 0);
+	snprintf(s, sizeof(s), "/dev/" KBUILD_MODNAME "/%u-blah/bus", getuid());
+	ASSERT_RETURN(access(s, F_OK) == 0);
+
+#if 0
+	/* can't use the same fd for bus make twice */
+	ret = ioctl(env->control_fd, KDBUS_CMD_BUS_MAKE, &bus_make);
+	ASSERT_RETURN(ret == -1 && errno == EBADFD);
+#endif
+
+	return CHECK_OK;
+}
+
+static int check_hello(struct kdbus_check_env *env)
+{
+	struct kdbus_cmd_hello hello;
+	int fd, ret;
+
+	memset(&hello, 0, sizeof(hello));
+
+	fd = open(env->buspath, O_RDWR|O_CLOEXEC);
+	if (fd < 0)
+		return CHECK_ERR;
+
+	hello.conn_flags = KDBUS_HELLO_ACCEPT_FD;
+	hello.attach_flags = ATTACH_FLAGS;
+	hello.size = sizeof(struct kdbus_cmd_hello);
+	hello.pool_size = POOL_SIZE;
+
+	/* an unaligned hello must result in -EFAULT */
+	ret = ioctl(fd, KDBUS_CMD_HELLO, (char *) &hello + 1);
+	ASSERT_RETURN(ret == -1 && errno == EFAULT);
+
+	/* a size of 0 must return EMSGSIZE */
+	hello.size = 1;
+	ret = ioctl(fd, KDBUS_CMD_HELLO, &hello);
+	ASSERT_RETURN(ret == -1 && errno == EMSGSIZE);
+
+	hello.size = sizeof(struct kdbus_cmd_hello);
+
+	/* check faulty flags */
+	hello.conn_flags = 1ULL << 32;
+	ret = ioctl(fd, KDBUS_CMD_HELLO, &hello);
+	ASSERT_RETURN(ret == -1 && errno == 524);
+
+	hello.conn_flags = KDBUS_HELLO_ACCEPT_FD;
+
+	/* check for faulty pool sizes */
+	hello.pool_size = 0;
+	ret = ioctl(fd, KDBUS_CMD_HELLO, &hello);
+	ASSERT_RETURN(ret == -1 && errno == EFAULT);
+
+	hello.pool_size = 4097;
+	ret = ioctl(fd, KDBUS_CMD_HELLO, &hello);
+	ASSERT_RETURN(ret == -1 && errno == EFAULT);
+
+	hello.pool_size = POOL_SIZE;
+
+	/* success test */
+	ret = ioctl(fd, KDBUS_CMD_HELLO, &hello);
+	ASSERT_RETURN(ret == 0);
+
+	close(fd);
+	fd = open(env->buspath, O_RDWR|O_CLOEXEC);
+	ASSERT_RETURN(fd >= 0);
+
+	/* no ACTIVATOR flag without a name */
+	hello.conn_flags = KDBUS_HELLO_ACTIVATOR;
+	ret = ioctl(fd, KDBUS_CMD_HELLO, &hello);
+	ASSERT_RETURN(ret == -1 && errno == EINVAL);
+
+	return CHECK_OK;
+}
+
+static int check_byebye(struct kdbus_check_env *env)
+{
+	struct kdbus_conn *conn;
+	uint64_t off;
+	int ret;
+
+	/* create a 2nd connection */
+	conn = make_conn(env->buspath, 0);
+	ASSERT_RETURN(conn != NULL);
+
+	add_match_empty(conn->fd);
+	add_match_empty(env->conn->fd);
+
+	/* send over 1st connection */
+	ret = send_message(env->conn, NULL, 0, KDBUS_DST_ID_BROADCAST);
+	ASSERT_RETURN(ret == 0);
+
+	/* say byebye on the 2nd, which must fail */
+	ret = ioctl(conn->fd, KDBUS_CMD_BYEBYE, 0);
+	ASSERT_RETURN(ret == -1 && errno == EBUSY);
+
+	/* receive the message */
+	ret = ioctl(conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	ASSERT_RETURN(ret == 0);
+
+	ret = ioctl(conn->fd, KDBUS_CMD_FREE, &off);
+	ASSERT_RETURN(ret == 0);
+
+	/* and try again */
+	ret = ioctl(conn->fd, KDBUS_CMD_BYEBYE, 0);
+	ASSERT_RETURN(ret == 0);
+
+	/* a 2nd try should result in -EBADFD */
+	ret = ioctl(conn->fd, KDBUS_CMD_BYEBYE, 0);
+	ASSERT_RETURN(ret == -1 && errno == EBADFD);
+
+	free_conn(conn);
+
+	return CHECK_OK;
+}
+
+static int check_monitor(struct kdbus_check_env *env)
+{
+	struct kdbus_cmd_name *cmd_name;
+	struct kdbus_conn *conn;
+	size_t size;
+	char *name;
+	int ret;
+
+	conn = make_conn(env->buspath, KDBUS_HELLO_MONITOR);
+	ASSERT_RETURN(conn != NULL);
+
+	/* taking a name must fail */
+	name = "foo.bla.blaz";
+	ret = upload_policy(conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	size = sizeof(*cmd_name) + strlen(name) + 1;
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+	cmd_name->flags = 0;
+
+	/* check that we can acquire a name */
+	ret = ioctl(conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == -1 && errno == EPERM);
+
+	free_conn(conn);
+
+	return CHECK_OK;
+}
+
+static int check_name_basic(struct kdbus_check_env *env)
+{
+	struct kdbus_cmd_name *cmd_name;
+	uint64_t size;
+	char *name;
+	int ret;
+
+	name = "foo.bla.blaz";
+	ret = upload_policy(env->conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	size = sizeof(*cmd_name) + strlen(name) + 1;
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+	cmd_name->flags = 0;
+
+	/* check that we can acquire a name */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	ret = conn_is_name_owner(env->conn, KDBUS_NAME_LIST_NAMES, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* ... and release it again */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_RELEASE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	ret = conn_is_name_owner(env->conn, KDBUS_NAME_LIST_NAMES, name);
+	ASSERT_RETURN(ret != 0);
+
+	/* check that we can't release it again */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_RELEASE, cmd_name);
+	ASSERT_RETURN(ret == -1 && errno == ESRCH);
+
+	/* check that we can't release a name that we don't own */
+	cmd_name->name[0] = 'x';
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_RELEASE, cmd_name);
+	ASSERT_RETURN(ret == -1 && errno == ESRCH);
+
+	return CHECK_OK;
+}
+
+static int check_name_conflict(struct kdbus_check_env *env)
+{
+	struct kdbus_cmd_name *cmd_name;
+	struct kdbus_conn *conn;
+	uint64_t size;
+	char *name;
+	int ret;
+
+	name = "foo.bla.blaz";
+	ret = upload_policy(env->conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	size = sizeof(*cmd_name) + strlen(name) + 1;
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+	cmd_name->flags = 0;
+
+	/* create a 2nd connection */
+	conn = make_conn(env->buspath, 0);
+	ASSERT_RETURN(conn != NULL);
+
+	/* allow the new connection to own the same name */
+	ret = upload_policy(conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* acquire name from the 1st connection */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	ret = conn_is_name_owner(env->conn, KDBUS_NAME_LIST_NAMES, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* check that we can't acquire it again from the 1st connection */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == -1 && errno == EALREADY);
+
+	/* check that we also can't acquire it again from the 2nd connection */
+	ret = ioctl(conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == -1 && errno == EEXIST);
+
+	free_conn(conn);
+
+	return CHECK_OK;
+}
+
+static int check_name_queue(struct kdbus_check_env *env)
+{
+	struct kdbus_cmd_name *cmd_name;
+	struct kdbus_conn *conn;
+	uint64_t size;
+	char *name;
+	int ret;
+
+	name = "foo.bla.blaz";
+	ret = upload_policy(env->conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	size = sizeof(*cmd_name) + strlen(name) + 1;
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+	cmd_name->flags = KDBUS_NAME_ALLOW_REPLACEMENT;
+
+	/* create a 2nd connection */
+	conn = make_conn(env->buspath, 0);
+	ASSERT_RETURN(conn != NULL);
+
+	/* allow the new connection to own the same name */
+	ret = upload_policy(conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* acquire name from the 1st connection */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	ret = conn_is_name_owner(env->conn, KDBUS_NAME_LIST_NAMES, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* queue the 2nd connection as waiting owner */
+	cmd_name->flags = KDBUS_NAME_QUEUE;
+	ret = ioctl(conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	ASSERT_RETURN(cmd_name->flags & KDBUS_NAME_IN_QUEUE);
+
+	/* release name from 1st connection */
+	cmd_name->flags = 0;
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_RELEASE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	/* now the name should be owned by the 2nd connection */
+	ret = conn_is_name_owner(conn, KDBUS_NAME_LIST_NAMES, name);
+	ASSERT_RETURN(ret == 0);
+
+	free_conn(conn);
+
+	return CHECK_OK;
+}
+
+static int check_conn_info(struct kdbus_check_env *env)
+{
+	int ret;
+	struct {
+		struct kdbus_cmd_conn_info cmd_info;
+		char name[64];
+	} buf;
+
+	buf.cmd_info.size = sizeof(struct kdbus_cmd_conn_info);
+	buf.cmd_info.flags = 0;
+	buf.cmd_info.id = env->conn->hello.id;
+
+	ret = ioctl(env->conn->fd, KDBUS_CMD_CONN_INFO, &buf);
+	ASSERT_RETURN(ret == 0);
+
+	/* try to pass a name that is longer than the buffer's size */
+	strcpy(buf.cmd_info.name, "foo.bar.bla");
+	buf.cmd_info.id = 0;
+	buf.cmd_info.size = sizeof(struct kdbus_cmd_conn_info) + 10;
+	ret = ioctl(env->conn->fd, KDBUS_CMD_CONN_INFO, &buf);
+	ASSERT_RETURN(ret == -1 && errno == EINVAL);
+
+	return CHECK_OK;
+}
+
+static int check_match_id_add(struct kdbus_check_env *env)
+{
+	struct {
+		struct kdbus_cmd_match cmd;
+		struct {
+			uint64_t size;
+			uint64_t type;
+			struct kdbus_notify_id_change chg;
+		} item;
+	} buf;
+	struct kdbus_conn *conn;
+	struct kdbus_item *item;
+	struct kdbus_msg *msg;
+	uint64_t off;
+	int ret;
+
+	memset(&buf, 0, sizeof(buf));
+
+	buf.cmd.size = sizeof(buf);
+	buf.cmd.cookie = 0xdeafbeefdeaddead;
+	buf.item.size = sizeof(buf.item);
+	buf.item.type = KDBUS_ITEM_ID_ADD;
+	buf.item.chg.id = KDBUS_MATCH_ID_ANY;
+
+	/* match on id add */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MATCH_ADD, &buf);
+	ASSERT_RETURN(ret == 0);
+
+	/* create 2nd connection */
+	conn = make_conn(env->buspath, 0);
+	ASSERT_RETURN(conn != NULL);
+
+	/* 1st connection should have received a notification */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	ASSERT_RETURN(ret == 0);
+
+	msg = (struct kdbus_msg *)(env->conn->buf + off);
+	item = &msg->items[0];
+	ASSERT_RETURN(item->type == KDBUS_ITEM_ID_ADD);
+	ASSERT_RETURN(item->id_change.id == conn->hello.id);
+
+	free_conn(conn);
+
+	return CHECK_OK;
+}
+
+static int check_match_id_remove(struct kdbus_check_env *env)
+{
+	struct {
+		struct kdbus_cmd_match cmd;
+		struct {
+			uint64_t size;
+			uint64_t type;
+			struct kdbus_notify_id_change chg;
+		} item;
+	} buf;
+	struct kdbus_conn *conn;
+	struct kdbus_item *item;
+	struct kdbus_msg *msg;
+	uint64_t off;
+	size_t id;
+	int ret;
+
+	/* create 2nd connection */
+	conn = make_conn(env->buspath, 0);
+	id = conn->hello.id;
+	ASSERT_RETURN(conn != NULL);
+
+	memset(&buf, 0, sizeof(buf));
+	buf.cmd.size = sizeof(buf);
+	buf.cmd.cookie = 0xdeafbeefdeaddead;
+	buf.item.size = sizeof(buf.item);
+	buf.item.type = KDBUS_ITEM_ID_REMOVE;
+	buf.item.chg.id = id;
+
+	/* register match on 2nd connection */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MATCH_ADD, &buf);
+	ASSERT_RETURN(ret == 0);
+
+	/* remove 2nd connection again */
+	free_conn(conn);
+
+	/* 1st connection should have received a notification */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	ASSERT_RETURN(ret == 0);
+
+	msg = (struct kdbus_msg *)(env->conn->buf + off);
+	item = &msg->items[0];
+	ASSERT_RETURN(item->type == KDBUS_ITEM_ID_REMOVE);
+	ASSERT_RETURN(item->id_change.id == id);
+
+	return CHECK_OK;
+}
+
+static int check_match_name_add(struct kdbus_check_env *env)
+{
+	struct {
+		struct kdbus_cmd_match cmd;
+		struct {
+			uint64_t size;
+			uint64_t type;
+			struct kdbus_notify_name_change chg;
+			char name[64];
+		} item;
+	} buf;
+	struct kdbus_cmd_name *cmd_name;
+	struct kdbus_item *item;
+	struct kdbus_msg *msg;
+	uint64_t size, off;
+	char *name;
+	int ret;
+
+	name = "foo.bla.blaz";
+	ret = upload_policy(env->conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* install the match rule */
+	memset(&buf, 0, sizeof(buf));
+	buf.cmd.size = sizeof(buf);
+	buf.item.size = sizeof(buf.item);
+	buf.item.type = KDBUS_ITEM_NAME_ADD;
+	buf.item.chg.old.id = KDBUS_MATCH_ID_ANY;
+	buf.item.chg.new.id = KDBUS_MATCH_ID_ANY;
+	strncpy(buf.item.name, name, sizeof(buf.item.name));
+
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MATCH_ADD, &buf);
+	ASSERT_RETURN(ret == 0);
+
+	/* acquire the name */
+	size = sizeof(*cmd_name) + strlen(name) + 1;
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+	cmd_name->flags = 0;
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	/* we should have received a notification */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	ASSERT_RETURN(ret == 0);
+
+	msg = (struct kdbus_msg *)(env->conn->buf + off);
+	item = &msg->items[0];
+	ASSERT_RETURN(item->type == KDBUS_ITEM_NAME_ADD);
+	ASSERT_RETURN(item->name_change.old.id == 0);
+	ASSERT_RETURN(item->name_change.new.id == env->conn->hello.id);
+	ASSERT_RETURN(strcmp(item->name_change.name, name) == 0);
+
+	return CHECK_OK;
+}
+
+static int check_match_name_remove(struct kdbus_check_env *env)
+{
+	struct {
+		struct kdbus_cmd_match cmd;
+		struct {
+			uint64_t size;
+			uint64_t type;
+			struct kdbus_notify_name_change chg;
+			char name[64];
+		} item;
+	} buf;
+	struct kdbus_cmd_name *cmd_name;
+	struct kdbus_item *item;
+	struct kdbus_msg *msg;
+	uint64_t size, off;
+	char *name;
+	int ret;
+
+	name = "foo.bla.blaz";
+	ret = upload_policy(env->conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* acquire the name */
+	size = sizeof(*cmd_name) + strlen(name) + 1;
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+	cmd_name->flags = 0;
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	/* install the match rule */
+	memset(&buf, 0, sizeof(buf));
+	buf.cmd.size = sizeof(buf);
+	buf.item.size = sizeof(buf.item);
+	buf.item.type = KDBUS_ITEM_NAME_REMOVE;
+	buf.item.chg.old.id = KDBUS_MATCH_ID_ANY;
+	buf.item.chg.new.id = KDBUS_MATCH_ID_ANY;
+	strncpy(buf.item.name, name, sizeof(buf.item.name));
+
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MATCH_ADD, &buf);
+	ASSERT_RETURN(ret == 0);
+
+	/* release the name again */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_RELEASE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	/* we should have received a notification */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	ASSERT_RETURN(ret == 0);
+
+	msg = (struct kdbus_msg *)(env->conn->buf + off);
+	item = &msg->items[0];
+	ASSERT_RETURN(item->type == KDBUS_ITEM_NAME_REMOVE);
+	ASSERT_RETURN(item->name_change.old.id == env->conn->hello.id);
+	ASSERT_RETURN(item->name_change.new.id == 0);
+	ASSERT_RETURN(strcmp(item->name_change.name, name) == 0);
+
+	return CHECK_OK;
+}
+
+static int check_match_name_change(struct kdbus_check_env *env)
+{
+	struct {
+		struct kdbus_cmd_match cmd;
+		struct {
+			uint64_t size;
+			uint64_t type;
+			struct kdbus_notify_name_change chg;
+			char name[64];
+		} item;
+	} buf;
+	struct kdbus_cmd_name *cmd_name;
+	struct kdbus_item *item;
+	struct kdbus_conn *conn;
+	struct kdbus_msg *msg;
+	uint64_t size, off;
+	char *name;
+	int ret;
+
+	name = "foo.bla.blaz";
+	ret = upload_policy(env->conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* acquire the name */
+	size = sizeof(*cmd_name) + strlen(name) + 1;
+	cmd_name = alloca(size);
+
+	memset(cmd_name, 0, size);
+	strcpy(cmd_name->name, name);
+	cmd_name->size = size;
+	cmd_name->flags = KDBUS_NAME_ALLOW_REPLACEMENT;
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	/* install the match rule */
+	memset(&buf, 0, sizeof(buf));
+	buf.cmd.size = sizeof(buf);
+	buf.item.size = sizeof(buf.item);
+	buf.item.type = KDBUS_ITEM_NAME_CHANGE;
+	buf.item.chg.old.id = KDBUS_MATCH_ID_ANY;
+	buf.item.chg.new.id = KDBUS_MATCH_ID_ANY;
+	strncpy(buf.item.name, name, sizeof(buf.item.name));
+
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MATCH_ADD, &buf);
+	ASSERT_RETURN(ret == 0);
+
+	/* create a 2nd connection */
+	conn = make_conn(env->buspath, 0);
+	ASSERT_RETURN(conn != NULL);
+
+	/* allow the new connection to own the same name */
+	ret = upload_policy(conn->fd, name);
+	ASSERT_RETURN(ret == 0);
+
+	/* queue the 2nd connection as waiting owner */
+	cmd_name->flags = KDBUS_NAME_QUEUE;
+	ret = ioctl(conn->fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+	ASSERT_RETURN(cmd_name->flags & KDBUS_NAME_IN_QUEUE);
+
+	/* release name from 1st connection */
+	cmd_name->flags = 0;
+	ret = ioctl(env->conn->fd, KDBUS_CMD_NAME_RELEASE, cmd_name);
+	ASSERT_RETURN(ret == 0);
+
+	/* we should have received a notification */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	ASSERT_RETURN(ret == 0);
+
+	msg = (struct kdbus_msg *)(env->conn->buf + off);
+	item = &msg->items[0];
+	ASSERT_RETURN(item->type == KDBUS_ITEM_NAME_CHANGE);
+	ASSERT_RETURN(item->name_change.old.id == env->conn->hello.id);
+	ASSERT_RETURN(item->name_change.new.id == conn->hello.id);
+	ASSERT_RETURN(strcmp(item->name_change.name, name) == 0);
+
+	free_conn(conn);
+
+	return CHECK_OK;
+}
+
+static int check_msg_basic(struct kdbus_check_env *env)
+{
+	struct kdbus_conn *conn;
+	struct kdbus_msg *msg;
+	uint64_t cookie = 0x1234abcd5678eeff;
+	struct pollfd fd;
+	uint64_t off;
+	int ret;
+
+	/* create a 2nd connection */
+	conn = make_conn(env->buspath, 0);
+	ASSERT_RETURN(conn != NULL);
+
+	add_match_empty(conn->fd);
+	add_match_empty(env->conn->fd);
+
+	/* send over 1st connection */
+	ret = send_message(env->conn, NULL, cookie, KDBUS_DST_ID_BROADCAST);
+	ASSERT_RETURN(ret == 0);
+
+	/* ... and receive on the 2nd */
+	fd.fd = conn->fd;
+	fd.events = POLLIN | POLLPRI | POLLHUP;
+	fd.revents = 0;
+
+	ret = poll(&fd, 1, 100);
+	ASSERT_RETURN(ret > 0 && (fd.revents & POLLIN));
+
+	ret = ioctl(conn->fd, KDBUS_CMD_MSG_RECV, &off);
+	ASSERT_RETURN(ret == 0);
+
+	msg = (struct kdbus_msg *)(conn->buf + off);
+	ASSERT_RETURN(msg->cookie == cookie);
+
+	ret = ioctl(conn->fd, KDBUS_CMD_FREE, &off);
+	ASSERT_RETURN(ret == 0);
+
+	free_conn(conn);
+
+	return CHECK_OK;
+}
+
+static int check_msg_free(struct kdbus_check_env *env)
+{
+	int ret;
+	uint64_t off = 0;
+
+	/* free an unallocated buffer */
+	ret = ioctl(env->conn->fd, KDBUS_CMD_FREE, &off);
+	ASSERT_RETURN(ret == -1 && errno == ENXIO);
+
+	/* free a buffer out of the pool's bounds */
+	off = env->conn->size + 1;
+	ret = ioctl(env->conn->fd, KDBUS_CMD_FREE, &off);
+	ASSERT_RETURN(ret == -1 && errno == ENXIO);
+
+	return CHECK_OK;
+}
+
+/* -----------------------------------8<------------------------------- */
+
+static int check_prepare_env(const struct kdbus_check *c, struct kdbus_check_env *env)
+{
+	if (c->flags & CHECK_CREATE_BUS) {
+		struct {
+			struct kdbus_cmd_make head;
+
+			/* bloom size item */
+			struct {
+				uint64_t size;
+				uint64_t type;
+				uint64_t bloom_size;
+			} bs;
+
+			/* name item */
+			uint64_t n_size;
+			uint64_t n_type;
+			char name[64];
+		} bus_make;
+		unsigned int i;
+		char n[32];
+		int ret;
+
+		env->control_fd = open("/dev/" KBUILD_MODNAME "/control", O_RDWR|O_CLOEXEC);
+		ASSERT_RETURN(env->control_fd >= 0);
+
+		memset(&bus_make, 0, sizeof(bus_make));
+		bus_make.bs.size = sizeof(bus_make.bs);
+		bus_make.bs.type = KDBUS_ITEM_BLOOM_SIZE;
+		bus_make.bs.bloom_size = 64;
+
+		for (i = 0; i < sizeof(n); i++)
+			n[i] = 'a' + (random() % ('z' - 'a'));
+
+		snprintf(bus_make.name, sizeof(bus_make.name), "%u-%s", getuid(), n);
+
+		bus_make.n_type = KDBUS_ITEM_MAKE_NAME;
+		bus_make.n_size = KDBUS_ITEM_HEADER_SIZE + strlen(bus_make.name) + 1;
+
+		bus_make.head.size = sizeof(struct kdbus_cmd_make) +
+				     sizeof(bus_make.bs) +
+				     bus_make.n_size;
+
+		ret = ioctl(env->control_fd, KDBUS_CMD_BUS_MAKE, &bus_make);
+		ASSERT_RETURN(ret == 0);
+
+		ret = asprintf(&env->buspath, "/dev/" KBUILD_MODNAME "/%s/bus", bus_make.name);
+		ASSERT_RETURN(ret >= 0);
+	}
+
+	if (c->flags & CHECK_CREATE_CONN) {
+		env->conn = make_conn(env->buspath, 0);
+		if (!env->conn)
+			return EXIT_FAILURE;
+	}
+
+	return 0;
+}
+
+void check_unprepare_env(const struct kdbus_check *c, struct kdbus_check_env *env)
+{
+	if (env->conn) {
+		free_conn(env->conn);
+		env->conn = NULL;
+	}
+
+	if (env->control_fd >= 0) {
+		close(env->control_fd);
+		env->control_fd = -1;
+	}
+
+	if (env->buspath) {
+		free(env->buspath);
+		env->buspath = NULL;
+	}
+}
+
+static const struct kdbus_check checks[] = {
+	{ "bus make",		check_busmake,			0					},
+	{ "hello",		check_hello,			CHECK_CREATE_BUS			},
+	{ "byebye",		check_byebye,			CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "monitor",		check_monitor,			CHECK_CREATE_BUS			},
+	{ "name basics",	check_name_basic,		CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "name conflict",	check_name_conflict,		CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "name queue",		check_name_queue,		CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "message basic",	check_msg_basic,		CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "message free",	check_msg_free,			CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "connection info",	check_conn_info,		CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "match id add",	check_match_id_add,		CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "match id remove",	check_match_id_remove,		CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "match name add",	check_match_name_add,		CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "match name remove",	check_match_name_remove,	CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "match name change",	check_match_name_change,	CHECK_CREATE_BUS | CHECK_CREATE_CONN	},
+	{ "ns make",		check_nsmake,			0					},
+	{ NULL, NULL, 0 }
+};
+
+static int run_tests(void)
+{
+	int ret;
+	unsigned int fail_cnt = 0;
+	unsigned int skip_cnt = 0;
+	unsigned int ok_cnt = 0;
+	unsigned int i;
+	const struct kdbus_check *c;
+	struct kdbus_check_env env;
+
+	sync();
+
+	memset(&env, 0, sizeof(env));
+
+	for (c = checks; c->name; c++) {
+		ret = check_prepare_env(c, &env);
+		if (ret != 0) {
+			printf("PREPARATION OF TEST '%s' FAILED!\n", c->name);
+			fail_cnt++;
+			continue;
+		}
+
+		printf("RUNNING TEST '%s' ", c->name);
+		for (i = 0; i < 30 - strlen(c->name); i++)
+			printf(".");
+		printf(" ");
+
+		ret = c->func(&env);
+
+		switch (ret) {
+		case CHECK_OK:
+			printf("OK");
+			ok_cnt++;
+			break;
+		case CHECK_SKIP:
+			printf("SKIPPED");
+			skip_cnt++;
+			break;
+		case CHECK_ERR:
+			printf("ERROR");
+			fail_cnt++;
+			break;
+		}
+
+		printf("\n");
+
+		check_unprepare_env(c, &env);
+	}
+
+	printf("\nSUMMARY: %d tests passed, %d skipped, %d failed\n", ok_cnt, skip_cnt, fail_cnt);
+
+	return fail_cnt > 0 ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+static int arg_count = 1;
+static int arg_loop = 0;
+
+int main(int argc, char *argv[])
+{
+	int c, ret;
+
+	enum {
+		ARG_VERSION = 0x100,
+	};
+
+	static const struct option options[] = {
+		{ "count",	required_argument,	NULL, 'c'	},
+		{ "loop",	no_argument,		NULL, 'l'	},
+		{ NULL,		0,			NULL, 0		}
+	};
+
+	while ((c = getopt_long(argc, argv, "c:l", options, NULL)) >= 0) {
+
+		switch (c) {
+
+		case 'c':
+			arg_count = atoi(optarg);
+			break;
+
+		case 'l':
+			arg_loop = 1;
+			break;
+
+		default:
+			printf("Unknown option code %c", c);
+			return -EINVAL;
+		}
+	}
+
+	if (arg_loop)
+		for(;;)
+			run_tests();
+
+	for (c = 0; c < arg_count; c++)
+		ret = run_tests();
+
+	return ret > 0 ? EXIT_FAILURE : EXIT_SUCCESS;
+}
